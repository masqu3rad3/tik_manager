// ===============================================================================================================
// Submit a Maya job to the deadline system.
// Install this in the Deadline Repository.
//
// Copyright (c) Thinkbox Software Inc
// All rights reserved.
// ===============================================================================================================

// ===============================================================================================================
// Adds Thinkbox shelf and button to Maya UI if necessary.
// ===============================================================================================================

// Only update the Maya UI if we're not in batch mode.
int $batchMode = `about -batch`;
if( !$batchMode )
{
	string $newName = "Deadline";
	string $newButtonName = "DeadlineButton";
	string $fileName = ( `internalVar -userShelfDir` + "shelf_" + $newName + ".mel" );

	int $addShelf = true;
	if( `file -q -exists $fileName` )
		$addShelf = false;
	else
	{
		// Check for existing shelves in optionVars.
		string $shelfName;
		int $shelfCount = `optionVar -q numShelves`;
		for( $i = 1; $i <= $shelfCount; $i++ )
		{
			$varName = "shelfName" + $i;
			$shelfName = `optionVar -q $varName`;
			if( $shelfName == $newName )
			{
				$addShelf = false;
				break;
			}
		}
		
		// Add the shelf if necessary.
		if( $addShelf )
			addNewShelfTab $newName;
	}

	int $addButton = true;
	string $buttonArray[] = `shelfLayout -q -childArray $newName`;
	for( $cnt = 0; $cnt < size( $buttonArray ); $cnt++ )
	{
		$buttonAnnotation = `shelfButton -q -annotation $buttonArray[$cnt]`;
		if( $buttonAnnotation == "Submit To Deadline" )
		{
			$addButton = false;
			break;
		}
	}

	if( $addButton )
	{
		//string $imagePath = "commandButton.xpm";
		string $imagePath  = CheckSlashes( ( CallDeadlineCommand( "-getrepositorypath submission/Maya/Main", false) ) + "/Submit.png" );

		shelfButton -parent $newName -annotation "Submit To Deadline" -image1 $imagePath -command ("SubmitJobToDeadline") $newButtonName;
	}
}

// ===============================================================================================================
// Globals
// ===============================================================================================================

global string $DeadlineSubmitterWindow;
global string $ProjectPathGrp;
global string $ImageOutputPathGrp;
global string $StartupScriptPathGrp;
global string $MentalRayFilenameGrp;
global string $VRayFilenameGrp;
global string $LimitGroupGrp;
global string $DependenciesGrp;
global string $MachineListGrp;
global string $JobNameGrp;

global string $MayaRenderOptionsRollout;
global string $MayaRenderOptionsArnoldRollout;
global string $MayaRenderOptionsMentalRayRollout;
global string $MayaRenderOptionsRedshiftRollout;
global string $MayaRenderOptionsIRayRollout;
global string $MayaRenderOptionsVRayRollout;
global string $MayaRenderOptionsTileRollout;
global string $MayaRenderOptionsJigsawRollout;
global string $MentalRayExportRollout;
global string $MentalRayExportRenderJobRollout;
global string $VrayExportRollout;
global string $VrayExportRenderJobRollout;
global string $VrayExportVrimgJobRollout;
global string $RendermanExportRollout;
global string $RendermanExportRenderJobRollout;
global string $ArnoldExportRollout;
global string $ArnoldExportRenderJobRollout;

global string $OverrideLayerSettingsDialog;


global int $MayaRenderJobType = 1;
global int $MentalRayExportJobType = 2;
global int $VRayExportJobType = 3;
global int $RendermanExportJobType = 4;
global int $ArnoldExportJobType = 5;
global int $MaxwellExportJobType = 6;

global int $BifrostSimulationJobType = 7;
global int $AlembicExportJobType = 8;
global int $MayaScriptJobType = 9;
global int $FluidCachingJobType = 10;
global int $GeometryCachingJobType = 11;

global int $JigsawRegionRenderType = 1;
global int $TileRegionRenderType = 2;

global int $BlankImageCompType = 1;
global int $PreviousImageCompType = 2;
global int $SelectedImageCompType = 3;

//Vray
global string $VrayLimitGroupGrp;
global string $VrayMachineListGrp;

//Mental Ray
global string $MentalLimitGroupGrp;
global string $MentalMachineListGrp;

//Renderman
global string $RendermanLimitGroupGrp;
global string $RendermanMachineListGrp;

//Arnold
global string $ArnoldLimitGroupGrp;
global string $ArnoldMachineListGrp;

//Maxwell
global string $MaxwellLimitGroupGrp;
global string $MaxwellMachineListGrp;
global string $MaxwellOutputScriptListGrp;

global string $QuickDraftFormats[];
global string $QuickDraftFormatFile[];
global string $QuickDraftFormatMovie[];
global string $QuickDraftResolutions[];
global string $QuickDraftResolutionsDisplay[];
global string $QuickDraftCodecsName[];
global string $QuickDraftCodecsList[];
global string $QuickDraftFrameRates[];

global string $QuickDraftRestrictions[];
global string $QuickDraftFormatOptions[];

//Repository Paths
global string $ShotgunRepoPath = "";
global string $FTrackRepoPath = "";
global string $NIMRepoPath = "";
global string $DraftRepoPath = "";
global string $MayaRepoPath = "";


//=================================================================
// SHOTGUN / FTRACK / NIM

global string $ShotgunResultsBox;
global string $SGInfoKeys[];
global string $SGInfoValues[];

global string $FTInfoKeys[];
global string $FTInfoValues[];

global string $PulledFTInfoKeys[];
global string $PulledFTInfoValues[];

global string $NimInfoKeys[];
global string $NimInfoValues[];

//=================================================================


//--------------------------------------------------------
// Browsing functions that call Deadline command.
//--------------------------------------------------------

// Set the project directory in the text field.
global proc SetProjectDir()
{
	global string $ProjectPathGrp;
	string $newdir = CallDeadlineCommand( "-getdirectory \"" + `textFieldButtonGrp -q -text $ProjectPathGrp` + "\"", false );
	if( $newdir != "" )
		textFieldButtonGrp -e -text $newdir $ProjectPathGrp;
	
	SavePersistentDeadlineOptions();
}

// Set the output image directory in the text field.
global proc SetImageDir()
{
	global string $ImageOutputPathGrp;
	string $newdir = CallDeadlineCommand( "-getdirectory \"" + `textFieldButtonGrp -q -text $ImageOutputPathGrp` + "\"", false );
	if( $newdir != "" )
		textFieldButtonGrp -e -text $newdir $ImageOutputPathGrp;
	
	SavePersistentDeadlineOptions();
}

// Set the startup script path in the text field.
global proc SetStartupScriptPath()
{
	global string $StartupScriptPathGrp;
	string $newpath = CallDeadlineCommand( "-SelectFilenameLoad \"" + `textFieldButtonGrp -q -text $StartupScriptPathGrp` + "\" \"Melscript Files (*.mel);;Python Files (*.py);;All files (*)\"", false );
	if( $newpath != "" )
		textFieldButtonGrp -e -text $newpath $StartupScriptPathGrp;
	
	SavePersistentDeadlineOptions();
}

// Set the startup script path in the text field.
global proc SetCompositeOverPath()
{
	global string $CompositeNamePathGrp;
	string $newpath = CallDeadlineCommand( "-SelectFilenameLoad \"" + `textFieldButtonGrp -q -text $CompositeNamePathGrp` + "\" \"All files (*)\"", false );
	if( $newpath != "" )
		textFieldButtonGrp -e -text $newpath $CompositeNamePathGrp;
	
	SavePersistentDeadlineOptions();
}

// Set the mental ray export filename in the text field.
global proc SetMentalRayFilename()
{
	global string $MentalRayFilenameGrp;
	string $newFilename = CallDeadlineCommand( "-selectfilenamesave \"" + `textFieldButtonGrp -q -text $MentalRayFilenameGrp` + "\" \"Mental Ray Files (*.mi);;All Files (*)\"", false );
	if( $newFilename != "" )
		textFieldButtonGrp -e -text $newFilename $MentalRayFilenameGrp;
	
	SavePersistentDeadlineOptions();
}

global proc SetVRayFilename()
{
	global string $VRayFilenameGrp;
	string $newFilename = CallDeadlineCommand( "-selectfilenamesave \"" + `textFieldButtonGrp -q -text $VRayFilenameGrp` + "\" \"VRay Scene Files (*.vrscene);;All Files (*)\"", false );
	if( $newFilename != "" )
		textFieldButtonGrp -e -text $newFilename $VRayFilenameGrp;
	
	SavePersistentDeadlineOptions();
}

// Set the limit groups in the limit group field.
global proc SetLimitGroups()
{
	global string $LimitGroupGrp;
	string $newLimitGroups = CallDeadlineCommand( "-selectlimitgroups \"" + `textFieldButtonGrp -q -text $LimitGroupGrp` + "\"", false );
	print( "limit groups: " + $newLimitGroups + "\n" );
	if( $newLimitGroups != "Action was cancelled by user" )
		textFieldButtonGrp -e -text $newLimitGroups $LimitGroupGrp;
	
	SavePersistentDeadlineOptions();
}

// Set the limit groups in the limit group field.
global proc SetVrayLimitGroups()
{
	global string $VrayLimitGroupGrp;
	string $newLimitGroups = CallDeadlineCommand( "-selectlimitgroups \"" + `textFieldButtonGrp -q -text $VrayLimitGroupGrp` + "\"", false );
	print( "limit groups: " + $newLimitGroups + "\n" );
	if( $newLimitGroups != "Action was cancelled by user" )
		textFieldButtonGrp -e -text $newLimitGroups $VrayLimitGroupGrp;
	
	SavePersistentDeadlineOptions();
}

// Set the limit groups in the limit group field.
global proc SetMentalLimitGroups()
{
	global string $MentalLimitGroupGrp;
	string $newLimitGroups = CallDeadlineCommand( "-selectlimitgroups \"" + `textFieldButtonGrp -q -text $MentalLimitGroupGrp` + "\"", false );
	print( "limit groups: " + $newLimitGroups + "\n" );
	if( $newLimitGroups != "Action was cancelled by user" )
		textFieldButtonGrp -e -text $newLimitGroups $MentalLimitGroupGrp;
	
	SavePersistentDeadlineOptions();
}

// Set the limit groups in the limit group field.
global proc SetRendermanLimitGroups()
{
	global string $RendermanLimitGroupGrp;
	string $newLimitGroups = CallDeadlineCommand( "-selectlimitgroups \"" + `textFieldButtonGrp -q -text $RendermanLimitGroupGrp` + "\"", false );
	print( "limit groups: " + $newLimitGroups + "\n" );
	if( $newLimitGroups != "Action was cancelled by user" )
		textFieldButtonGrp -e -text $newLimitGroups $RendermanLimitGroupGrp;
	
	SavePersistentDeadlineOptions();
}

// Set the limit groups in the limit group field.
global proc SetArnoldLimitGroups()
{
	global string $ArnoldLimitGroupGrp;
	string $newLimitGroups = CallDeadlineCommand( "-selectlimitgroups \"" + `textFieldButtonGrp -q -text $ArnoldLimitGroupGrp` + "\"", false );
	print( "limit groups: " + $newLimitGroups + "\n" );
	if( $newLimitGroups != "Action was cancelled by user" )
		textFieldButtonGrp -e -text $newLimitGroups $ArnoldLimitGroupGrp;
	
	SavePersistentDeadlineOptions();
}

// Set the limit groups in the limit group field.
global proc SetMaxwellLimitGroups()
{
	global string $MaxwellLimitGroupGrp;
	string $newLimitGroups = CallDeadlineCommand( "-selectlimitgroups \"" + `textFieldButtonGrp -q -text $MaxwellLimitGroupGrp` + "\"", false );
	print( "limit groups: " + $newLimitGroups + "\n" );
	if( $newLimitGroups != "Action was cancelled by user" )
		textFieldButtonGrp -e -text $newLimitGroups $MaxwellLimitGroupGrp;
	
	SavePersistentDeadlineOptions();
}

// Set the startup script path in the text field.
global proc SetMaxwellOutputScript()
{
	global string $MaxwellOutputScriptListGrp;
	string $newpath = CallDeadlineCommand( "-SelectFilenameSave \"" + `textFieldButtonGrp -q -text $MaxwellOutputScriptListGrp` + "\" \"Maxwell Files (*.mxs)\"", false );
	if( $newpath != "" )
		textFieldButtonGrp -e -text $newpath $MaxwellOutputScriptListGrp;
	
	SavePersistentDeadlineOptions();
}

// Set the dependencies in the job dependency field.
global proc SetDependencies()
{
	global string $DependenciesGrp;
	string $newDependencies = CallDeadlineCommand( "-selectdependencies \"" + `textFieldButtonGrp -q -text $DependenciesGrp` + "\"", false );
	if( $newDependencies != "Action was cancelled by user" )
		textFieldButtonGrp -e -text $newDependencies $DependenciesGrp;
	
	SavePersistentDeadlineOptions();
}

// Set the machine list in the machine list field.
global proc SetMachineList()
{
	global string $MachineListGrp;
	string $newMachineList = CallDeadlineCommand( "-selectmachinelist \"" + `textFieldButtonGrp -q -text $MachineListGrp` + "\"", false );
	if( $newMachineList != "Action was cancelled by user" )
		textFieldButtonGrp -e -text $newMachineList $MachineListGrp;
	
	SavePersistentDeadlineOptions();
}

// Set the machine list in the vray machine list field.
global proc SetVrayMachineList()
{
	global string $VrayMachineListGrp;
	string $newMachineList = CallDeadlineCommand( "-selectmachinelist \"" + `textFieldButtonGrp -q -text $VrayMachineListGrp` + "\"", false );
	if( $newMachineList != "Action was cancelled by user" )
		textFieldButtonGrp -e -text $newMachineList $VrayMachineListGrp;
	
	SavePersistentDeadlineOptions();
}

// Set the machine list in the vray machine list field.
global proc SetMentalMachineList()
{
	global string $MentalMachineListGrp;
	string $newMachineList = CallDeadlineCommand( "-selectmachinelist \"" + `textFieldButtonGrp -q -text $MentalMachineListGrp` + "\"", false );
	if( $newMachineList != "Action was cancelled by user" )
		textFieldButtonGrp -e -text $newMachineList $MentalMachineListGrp;
	
	SavePersistentDeadlineOptions();
}

// Set the machine list in the vray machine list field.
global proc SetRendermanMachineList()
{
	global string $RendermanMachineListGrp;
	string $newMachineList = CallDeadlineCommand( "-selectmachinelist \"" + `textFieldButtonGrp -q -text $RendermanMachineListGrp` + "\"", false );
	if( $newMachineList != "Action was cancelled by user" )
		textFieldButtonGrp -e -text $newMachineList $RendermanMachineListGrp;
	
	SavePersistentDeadlineOptions();
}

// Set the machine list in the vray machine list field.
global proc SetArnoldMachineList()
{
	global string $ArnoldMachineListGrp;
	string $newMachineList = CallDeadlineCommand( "-selectmachinelist \"" + `textFieldButtonGrp -q -text $ArnoldMachineListGrp` + "\"", false );
	if( $newMachineList != "Action was cancelled by user" )
		textFieldButtonGrp -e -text $newMachineList $ArnoldMachineListGrp;
	
	SavePersistentDeadlineOptions();
}

// Set the machine list in the vray machine list field.
global proc SetMaxwellMachineList()
{
	global string $MaxwellMachineListGrp;
	string $newMachineList = CallDeadlineCommand( "-selectmachinelist \"" + `textFieldButtonGrp -q -text $MaxwellMachineListGrp` + "\"", false );
	if( $newMachineList != "Action was cancelled by user" )
		textFieldButtonGrp -e -text $newMachineList $MaxwellMachineListGrp;
	
	SavePersistentDeadlineOptions();
}

// Set the job name to be the scene name.
global proc SetJobName()
{
	global string $JobNameGrp;
	string $newJobName = GetStrippedSceneFileName();
	textFieldButtonGrp -e -text $newJobName $JobNameGrp;
	
	SavePersistentDeadlineOptions();
}

// Set the Maya script path in the text field
global proc SetMayaOutputScript()
{
	global string $MayaScriptButtonGrp;
	string $newpath = CallDeadlineCommand( "-SelectFilenameLoad \"" + `textFieldButtonGrp -q -text $MayaScriptButtonGrp` + "\" \"Melscript Files (*.mel);;Python FIles (*.py)\"", false );

	if( $newpath != "" )
		textFieldButtonGrp -e -text $newpath $MayaScriptButtonGrp;
	
	SavePersistentDeadlineOptions();
}

// Set the folder that BiFrost caches will be written to
global proc SetBifrostCacheDirectory()
{
	global string $BifrostDirectoryButtonGrp;
	
	//string $newdir = CallDeadlineCommand( "-getdirectory \"" + `textFieldButtonGrp -q -text $ProjectPathGrp`            + "\"", false );
	//print(`textFieldButtonGrp -q -text $BifrostDirectoryButtonGrp`);
	string $newdir = CheckSlashes( CallDeadlineCommand( "-getdirectory \"" + `textFieldButtonGrp -q -text $BifrostDirectoryButtonGrp` + "\"", false ) );

	if( $newdir != "" )
		textFieldButtonGrp -e -text $newdir $BifrostDirectoryButtonGrp;
	
	SavePersistentDeadlineOptions();
}

// Set the file that the Alembic cache will be written to
global proc SetAlembicCacheFile()
{
	global string $AlembicFileButtonGrp;
	
	string $newfile = CheckSlashes( CallDeadlineCommand( "-SelectFilenameSave \"" + `textFieldButtonGrp -q -text $AlembicFileButtonGrp` + "\" \"Alembic Files (*.abc)\"", false ) );

	if( $newfile != "" )
		textFieldButtonGrp -e -text $newfile $AlembicFileButtonGrp;
	
	SavePersistentDeadlineOptions();
}

// Set the output directory for the geometric cache
global proc SetGeometricCacheDirectory()
{
	global string $GeometryCachingDirButtonGrp;

	string $newfile =  CheckSlashes( CallDeadlineCommand( "-getdirectory \"" + `textFieldButtonGrp -q -text $GeometryCachingDirButtonGrp` + "\"", false ) );

	if( $newfile != "" )
		textFieldButtonGrp -e -text $newfile $GeometryCachingDirButtonGrp;

	SavePersistentDeadlineOptions();
}

// Set the output directory for the fluid cache
global proc SetFluidCacheDirectory()
{
	global string $FluidCachingDirButtonGrp;

	string $newDir = CheckSlashes( CallDeadlineCommand( "-getDirectory \"" + `textFieldButtonGrp -q -text $FluidCachingDirButtonGrp` + "\"", false ) );

	if( $newDir != "" )
	{
		textFieldButtonGrp -e -text $newDir $FluidCachingDirButtonGrp;
	}

	SavePersistentDeadlineOptions();
}

// Get the repository path for Shotgun, checks to see if it's already
// been fetched and if so returns what's already stored, if not goes and gets it
global proc string GetShotgunRepoPath()
{
	global string $ShotgunRepoPath;

	if( $ShotgunRepoPath == "" )
	{
		$ShotgunRepoPath = CheckSlashes( CallDeadlineCommand( "-getrepositorypath events/Shotgun/", false ) );
	}

	return $ShotgunRepoPath;
}

// Get the repository path for FTrack, checks to see if it's already
// been fetched and if so returns what's already stored, if not goes and gets it
global proc string GetFTrackRepoPath()
{
	global string $FTrackRepoPath;

	if( $FTrackRepoPath == "" )
	{
		$FTrackRepoPath = CheckSlashes( CallDeadlineCommand( "-getrepositorypath submission/FTrack/Main/", false ) );
	}

	return $FTrackRepoPath;
}

// Get the repository path for NIM, checks to see if it's already
// been fetched and if so returns what's already stored, if not goes and gets it
global proc string GetNIMRepoPath()
{
	global string $NIMRepoPath;

	if( $NIMRepoPath == "" )
	{
		$NIMRepoPath = CheckSlashes( CallDeadlineCommand( "-getrepositorypath events/NIM/", false ) );
	}

	return $NIMRepoPath;
}

// Get the repository path for Draft, checks to see if it's already
// been fetched and if so returns what's already stored, if not goes and gets it
global proc string GetDraftRepoPath()
{
	global string $DraftRepoPath;

	if( $DraftRepoPath == "" )
	{
		$DraftRepoPath = CheckSlashes( CallDeadlineCommand( "-getrepositorypath submission/Draft/Main/", false ) );
	}

	return $DraftRepoPath;
}

// Get the repository path for Maya, checks to see if it's already
// been fetched and if so returns what's already stored, if not goes and gets it
global proc string GetMayaRepoPath()
{
	global string $MayaRepoPath;

	if( $MayaRepoPath == "" )
	{
		$MayaRepoPath = CheckSlashes( CallDeadlineCommand( "-getrepositorypath submission/Maya/Main/", false ) );
	}

	return $MayaRepoPath;
}

//=================================================================
// SHOTGUN / FTRACK / NIM

global proc ConnectButtonPressed()
{
	string $selectedIntegration = `optionMenuGrp -q -value frw_projectManagement`;
	string $additionalArgs[] = {};
	
	if( $selectedIntegration == "Shotgun" )
	{
		global string $SGInfoKeys[];
		global string $SGInfoValues[];

		string $shotgunUIScript = CheckSlashes( GetShotgunRepoPath() + "ShotgunUI.py" );	

		int $id = stringArrayFind( "UserName", 0, $SGInfoKeys );
		if($id >= 0)
			stringArrayInsertAtIndex( size($additionalArgs), $additionalArgs, "UserName="+$SGInfoValues[$id] );
			
		$id = stringArrayFind( "TaskName", 0, $SGInfoKeys );
		if($id >= 0)
			stringArrayInsertAtIndex( size($additionalArgs), $additionalArgs, "TaskName="+$SGInfoValues[$id] );
			
		$id = stringArrayFind( "ProjectName", 0, $SGInfoKeys );
		if($id >= 0)
			stringArrayInsertAtIndex( size($additionalArgs), $additionalArgs, "ProjectName="+$SGInfoValues[$id] );
			
		$id = stringArrayFind( "EntityName", 0, $SGInfoKeys );
		if($id >= 0)
			stringArrayInsertAtIndex( size($additionalArgs), $additionalArgs, "EntityName="+$SGInfoValues[$id] );
			
		$id = stringArrayFind( "SequenceName", 0, $SGInfoKeys );
		if($id >= 0)
			stringArrayInsertAtIndex( size($additionalArgs), $additionalArgs, "SequenceName="+$SGInfoValues[$id] );
		
		GetProjMgmtInfo( $shotgunUIScript, $additionalArgs, $SGInfoKeys, $SGInfoValues );
	}
	else if( $selectedIntegration == "FTrack" )
	{
		global string $FTInfoKeys[];
		global string $FTInfoValues[];
		
		global string $PulledFTInfoKeys[];
		global string $PulledFTInfoValues[];
		
		string $keys[] = $FTInfoKeys;
		string $values[] = $FTInfoValues;
		
		if( size($PulledFTInfoKeys) > 0 )
		{
			$keys = $PulledFTInfoKeys;
			$values = $PulledFTInfoValues;
		}
		
		string $ftrackUIScript = CheckSlashes( GetFTrackRepoPath() + "FTrackUI.py" );	
		
		int $id = stringArrayFind( "FT_Username", 0, $keys );
		if($id >= 0)
			stringArrayInsertAtIndex( size($additionalArgs), $additionalArgs, "UserName=\""+$values[$id]+"\"" );
			
		$id = stringArrayFind( "FT_TaskName", 0, $keys );
		if($id >= 0)
			stringArrayInsertAtIndex( size($additionalArgs), $additionalArgs, "TaskName=\""+$values[$id]+"\"" );
			
		$id = stringArrayFind( "FT_ProjectName", 0, $keys );
		if($id >= 0)
			stringArrayInsertAtIndex( size($additionalArgs), $additionalArgs, "ProjectName=\""+$values[$id]+"\"" );
			
		$id = stringArrayFind( "FT_AssetName", 0, $keys );
		if($id >= 0)
			stringArrayInsertAtIndex( size($additionalArgs), $additionalArgs, "AssetName=\""+$values[$id]+"\"" );
	
		GetProjMgmtInfo( $ftrackUIScript, $additionalArgs, $FTInfoKeys, $FTInfoValues );
		if( size($FTInfoKeys) >0 )
		{
			clear $PulledFTInfoKeys;
			clear $PulledFTInfoValues;
		}
	}
	//=================================================================
	// NIM
	else if( $selectedIntegration == "NIM" )
	{
		// GET NIM defaultRenderGlobals and seed NimInfoKeys

		string $nim_renderName = `textFieldGrp -q -label frw_projMgmtVersion`;
		string $nim_description = `textFieldGrp -q -label frw_projMgmtDescription`;
		
		global string $NimInfoKeys[];
		global string $NimInfoValues[];

		$arg_string = "";
		for( $i = 0; $i < size( $NimInfoKeys ); $i++ ){
			stringArrayInsertAtIndex( size($additionalArgs), $additionalArgs, $NimInfoKeys[$i]+"=\""+$NimInfoValues[$i]+"\"" );
		}

		string $nimUIScript = CheckSlashes( GetNIMRepoPath() + "NIM_UI.py" );	

		GetProjMgmtInfo( $nimUIScript, $additionalArgs, $NimInfoKeys, $NimInfoValues );
	}
	// END NIM
	//=================================================================
}

global proc tryGetFtrackData()
{
	global string $FTInfoKeys[];
	global string $FTInfoValues[];
	
	global string $PulledFTInfoKeys[];
	global string $PulledFTInfoValues[];

	string $ftrackScript = CheckSlashes( GetFTrackRepoPath() + "FTrackLoadData.py" );	

		
	string $tempInfo[];
	python("execfile(\""+$ftrackScript+"\")");
	$tempInfo = python("getFtrackData()");
	if(stringArrayFind("[Error]", 0, $tempInfo) < 0)
	{
		int $keyCount = 0;

		$cleared = false;

		for ( $i = 0; $i < size( $tempInfo ); $i++ )
		{
			if ( match( ".+=", $tempInfo[ $i ] ) != "" )
			{
				if ( !$cleared )
				{
					//Only clear lists once we're sure we have valid output
					clear $PulledFTInfoKeys;
					clear $PulledFTInfoValues;
					clear $FTInfoKeys;
					clear $FTInfoValues;
					$cleared = true;
				}

				string $tokens[];
				string $value = "";

				if ( tokenize( $tempInfo[ $i ], "=", $tokens ) > 1 )
					$value = $tokens[1];

				string $key = $tokens[0];

				$keyCount++;
				stringArrayInsertAtIndex( $keyCount, $PulledFTInfoKeys, $key );
				stringArrayInsertAtIndex( $keyCount, $PulledFTInfoValues, $value );
			}
		}
		if(size($PulledFTInfoKeys) == 8)
		{
			$FTInfoKeys = $PulledFTInfoKeys;
			$FTInfoValues = $PulledFTInfoValues;
			
			clear $PulledFTInfoKeys;
			clear $PulledFTInfoValues;
		}
	}
}


//Fills the given key/value arrasy with info retrieved by running the given script
global proc GetProjMgmtInfo( string $scriptPath, string $additionalArgs[] , string $keyArray[], string $valueArray[] )
{   
	
	$pmResults = CallDeadlineCommand( "-ExecuteScript \"" + $scriptPath + "\" Maya "+stringArrayToString($additionalArgs, " "), false );

	string $tempInfo[];
	$tempInfo = stringToStringArray( $pmResults, "\n" );

	if( size($tempInfo) > 0 )
	{
		int $keyCount = 0;

		$cleared = false;

		for ( $i = 0; $i < size( $tempInfo ); $i++ )
		{
			if ( match( ".+=", $tempInfo[ $i ] ) != "" )
			{
				if ( !$cleared )
				{
					//Only clear lists once we're sure we have valid output
					clear $keyArray;
					clear $valueArray;
					$cleared = true;
				}

				string $tokens[];
				string $value = "";

				if ( tokenize( $tempInfo[ $i ], "=", $tokens ) > 1 )
					$value = $tokens[1];

				string $key = $tokens[0];

				$keyCount++;
				stringArrayInsertAtIndex( $keyCount, $keyArray, $key );
				stringArrayInsertAtIndex( $keyCount, $valueArray, $value );
			}
		}

		UpdateProjectManagementUI( true );
	}
}

global proc ReadQuickDraftFiles()
{
	global string $QuickDraftFrameRates[];
	
	string $draftFolder = CheckSlashes( GetDraftRepoPath() );	
	
	string $formatFile = $draftFolder+"/formats.txt";
	ReadInFormatsFile($formatFile);
	
	string $resolutionsFile = $draftFolder+"/resolutions.txt";
	ReadInResolutionsFile($resolutionsFile);
	
	string $codecsFile = $draftFolder+"/codecs.txt";
	ReadInCodecsFile($codecsFile);
	
	string $frameRatesFile = $draftFolder+"/frameRates.txt";
	$QuickDraftFrameRates = ReadInDraftFile($frameRatesFile);
	
	string $restrictionsFile = $draftFolder+"/restrictions.txt";
	ReadInRestrictionsFile($restrictionsFile);
}

global proc ReadInFormatsFile( string $filename )
{
	global string $QuickDraftFormats[];
	global string $QuickDraftFormatFile[];
	global string $QuickDraftFormatMovie[];

	clear($QuickDraftFormats);
	clear($QuickDraftFormatFile);
	clear($QuickDraftFormatMovie);

	int $fileId = `fopen $filename "r"` ;  
	string $nextLine = `fgetline $fileId` ;  
	while (size($nextLine) > 0) 
	{  
		string $words[];
		int $numTokens = `tokenize $nextLine "," $words`;
		if($numTokens >2)
		{
			string $name = strip($words[1]) + " ("+strip($words[0])+")";
			
			stringArrayInsertAtIndex( size($QuickDraftFormats), $QuickDraftFormats, $name );
			stringArrayInsertAtIndex( size($QuickDraftFormatFile), $QuickDraftFormatFile, strip($words[0]) );
			stringArrayInsertAtIndex( size($QuickDraftFormatMovie), $QuickDraftFormatMovie, strip($words[2]) );
		}
		$nextLine = `fgetline $fileId` ;  
	}
	fclose $fileId;
}

global proc ReadInResolutionsFile( string $filename )
{
	global string $QuickDraftResolutions[];
	global string $QuickDraftResolutionsDisplay[];

	clear($QuickDraftResolutions);
	clear($QuickDraftResolutionsDisplay);

	int $fileId = `fopen $filename "r"` ;  
	string $nextLine = `fgetline $fileId` ;  
	while (size($nextLine) > 0) 
	{  
		string $words[];
		int $numTokens = `tokenize $nextLine "," $words`;
		if($numTokens >1)
		{
			stringArrayInsertAtIndex( size($QuickDraftResolutions), $QuickDraftResolutions, strip($words[0]) );
			stringArrayInsertAtIndex( size($QuickDraftResolutionsDisplay), $QuickDraftResolutionsDisplay, strip($words[1]) );
		}
		$nextLine = `fgetline $fileId` ;  
	}
	fclose $fileId;
}

global proc string[] ReadInDraftFile( string $filename )
{
	string $results[] = {};
	int $fileId = `fopen $filename "r"` ;  
	string $nextLine = `fgetline $fileId` ;  
	while (size($nextLine) > 0) 
	{  
		stringArrayInsertAtIndex( size($results), $results, strip($nextLine) );
		$nextLine = `fgetline $fileId` ;  
	}
	fclose $fileId;
	return $results;
}

global proc ReadInCodecsFile( string $filename )
{
	global string $QuickDraftCodecsName[];
	global string $QuickDraftCodecsList[];

	clear($QuickDraftCodecsName);
	clear($QuickDraftCodecsList);

	int $fileId = `fopen $filename "r"`;
	string $nextLine = `fgetline $fileId`;
	while (size($nextLine) > 0)
	{
		string $words[];
		int $numTokens = `tokenize $nextLine ":" $words`;
		if($numTokens > 1)
		{
			stringArrayInsertAtIndex( size($QuickDraftCodecsName), $QuickDraftCodecsName, strip($words[0]) );
			stringArrayInsertAtIndex( size($QuickDraftCodecsList), $QuickDraftCodecsList, strip($words[1]) );
		}
		$nextLine = `fgetline $fileId`;
	}
	fclose $fileId;
}

global proc ReadInRestrictionsFile( string $filename )
{
	global string $QuickDraftRestrictionsName[];
	global string $QuickDraftRestrictionsType[];
	global string $QuickDraftRestrictionsList[];

	clear($QuickDraftRestrictionsName);
	clear($QuickDraftRestrictionsType);
	clear($QuickDraftRestrictionsList);

	string $results[] = {};
	int $fileId = `fopen $filename "r"` ;  
	string $nextLine = `fgetline $fileId` ;  
	while (size($nextLine) > 0) 
	{  
		string $words[];
		int $numTokens = `tokenize $nextLine ":" $words`;
		if($numTokens >1)
		{
			string $innerWords[] = {};
			int $innerNumTokens = `tokenize $words[1] "=" $innerWords`;
			if($innerNumTokens >1)
			{
				stringArrayInsertAtIndex( size($QuickDraftRestrictionsName), $QuickDraftRestrictionsName, strip($words[0]) );
				stringArrayInsertAtIndex( size($QuickDraftRestrictionsType), $QuickDraftRestrictionsType, strip($innerWords[0]) );
				stringArrayInsertAtIndex( size($QuickDraftRestrictionsList), $QuickDraftRestrictionsList, strip($innerWords[1]) );
			}
		}
		$nextLine = `fgetline $fileId` ;  
	}
	fclose $fileId;
}

global proc string[] GetCodecs(string $currentFormat) 
{
	global string $QuickDraftFormats[];
	global string $QuickDraftFormatFile[];
	global string $QuickDraftCodecsName[];
	global string $QuickDraftCodecsList[];
	string $result[];

	int $index = stringArrayFind( $currentFormat, 0, $QuickDraftFormats );
	if( $index >= 0)
	{
		$currentFormat = $QuickDraftFormatFile[$index];
	}
	else
	{
		$currentFormat = "";
	}
	$index = stringArrayFind( $currentFormat, 0, $QuickDraftCodecsName );
	if( $index >= 0 )
	{
		tokenize $QuickDraftCodecsList[$index] "," $result;
	}
	else
	{
		print( "Error in Deadline Submission Script: could not find Quick Draft format \"" + $currentFormat + "\"\n" );
	}

	for( $i = 0; $i < size( $result ); $i++ )
	{
		$result[$i] = strip( $result[$i] );
	}

	return $result;
}

global proc string[] ApplyRestrictions(string $name, string $type, string $effects[])
{
	global string $QuickDraftRestrictionsName[];
	global string $QuickDraftRestrictionsType[];
	global string $QuickDraftRestrictionsList[];
	for( $i = 0; $i < size( $QuickDraftRestrictionsName ); $i++ )
	{
		if( $QuickDraftRestrictionsName[$i] == $name )
		{
			if( $QuickDraftRestrictionsType[$i] == $type )
			{
				string $result[] = {};
				string $list[] = {};
				int $innerNumTokens = `tokenize $QuickDraftRestrictionsList[$i] "," $list`;
				if($innerNumTokens >0)
				{
					for( $j = 0; $j < $innerNumTokens; $j++ )
					{
						if( stringArrayContains( strip($list[$j]), $effects) )
						{
							stringArrayInsertAtIndex( size($result), $result, strip($list[$j]) );
						}
					}
				}
				return $result;
			}
		}
	}
	
	return $effects;
}

global proc CreateVersionChanged()
{
	UpdateProjectManagementUI( false );
}

global proc ProjectManagementChanged()
{
	$selection = `optionMenuGrp -q -value frw_projectManagement`;
	ChangeProjectManager( $selection );
}

global proc ChangeProjectManager( string $switchTo )
{
	string $versionLabel = "Version Name";
	string $descLabel = "Version Description";
	string $miscLabel = "Selected Entity";
	string $createVersionLabel = "Create New Version";
	string $draftUseValuesLabel = "Use Shotgun Values";
	string $draftUploadlabel = "Upload to Shotgun";
	$filmstripOptionsVisible = true;

	//Integration-specific overrides
	if( $switchTo == "FTrack" )
	{
		$versionLabel = "Selected Asset";
		$miscLabel = "Miscellaneous Info";
		$createVersionLabel = "Create New Version";
		$draftUseValuesLabel = "Use FTrack Values";
		$draftUploadlabel = "Upload to FTrack";
		$filmstripOptionsVisible = false;
	}
	else if ( $switchTo == "Shotgun" )
	{
		$versionLabel = "Version Name";
		$descLabel = "Version Description";
		$miscLabel = "Selected Entity";
		$createVersionLabel = "Create New Version";
		$draftUseValuesLabel = "Use Shotgun Values";
		$draftUploadlabel = "Upload to Shotgun";
	}
	else if ( $switchTo == "NIM" )
	{
		$versionLabel = "Render Name";
		$descLabel = "Description";
		$miscLabel = "NIM Details";
		$createVersionLabel = "Add NIM Render";
		$draftUseValuesLabel = "Use NIM Values";
		$draftUploadlabel = "Upload to NIM";
		$filmstripOptionsVisible = false;
	}
	else
		return;

	textFieldGrp -e -label $versionLabel frw_projMgmtVersion;
	textFieldGrp -e -label $descLabel frw_projMgmtDescription;
	checkBox -e -label $createVersionLabel frw_projMgmtCreateVersion;
	text -e -label $miscLabel frw_projMgmtDetailsLabel;

	checkBox -e -visible $filmstripOptionsVisible frw_projMgmtCreateFilmstrip;
	
	checkBox -e -label $draftUploadlabel frw_uploadDraftToShotgun;
	
	button -e -label $draftUseValuesLabel frw_projMgmtCreateVersionDataButton;

	UpdateProjectManagementUI( `checkBox -q -value frw_projMgmtCreateVersion` );
}

//Updates the Project Management UI based on the current Info Key/Values
global proc UpdateProjectManagementUI( int $forceOn )
{
	string $projectManagement = `optionMenuGrp -q -value frw_projectManagement`;

	$createValue = false;
	$createEnabled = false;

	$versionValue = "";
	$versionEnabled = false;

	$descValue = "";
	$descEnabled = false;

	$infoValue = "";
	$infoEnabled = false;

	$draftOptionsEnabled = false;
	$draftIntegrationEnabled = false;

	if( $projectManagement == "Shotgun" )
	{
		global string $SGInfoKeys[];
		global string $SGInfoValues[];

		if( size( $SGInfoKeys ) > 0 )
		{
			$createEnabled = true;
			$createValue = $forceOn || `checkBox -q -value frw_projMgmtCreateVersion`;

			$versionEnabled = $createValue;
			$descEnabled = $createValue;
			$infoEnabled = $createValue;
			$draftOptionsEnabled = $createValue;

			for( $i = 0; $i < size( $SGInfoKeys ); $i++ )
			{
				string $key = $SGInfoKeys[$i];
				string $value = $SGInfoValues[$i];

				if( $key == "VersionName" )
					$versionValue = $value;
				else if( $key == "Description" )
					$descValue = $value;
				else  if( $key == "UserName" )
					$infoValue += "User Name: " + $value + "\n";
				else if( $key == "TaskName" )
					$infoValue += "Task Name: " + $value + "\n";
				else if( $key == "ProjectName" )
					$infoValue += "Project Name: " + $value + "\n";
				else if( $key == "EntityName" )
					$infoValue += "Entity Name: " + $value + "\n";
				else if( $key == "EntityType" )
					$infoValue += "Entity Type: " + $value + "\n";
				else if( $key == "DraftTemplate" )
					$infoValue += "DraftTemplate: " + $value + "\n";
			}
		}
	}
	else if( $projectManagement == "FTrack" )
	{
		global string $FTInfoKeys[];
		global string $FTInfoValues[];

		if( size( $FTInfoKeys ) > 0 )
		{
			$createEnabled = true;
			$createValue = $forceOn || `checkBox -q -value frw_projMgmtCreateVersion`;

			$versionEnabled = false;
			$descEnabled = $createValue;
			$infoEnabled = $createValue;

			for( $i = 0; $i < size( $FTInfoKeys ); $i++ )
			{
				string $key = $FTInfoKeys[$i];
				string $value = $FTInfoValues[$i];

				if ( $key == "FT_AssetName" )
					$versionValue = $value;
				else if ( $key == "FT_Description" )
					$descValue = $value;
				else if ( $key == "FT_Username" )
					$infoValue += "User Name: " + $value + "\n";
				else if ( $key == "FT_TaskName" )
					$infoValue += "Task Name: " + $value + "\n";
				else if ( $key == "FT_ProjectName" )
					$infoValue += "Project Name: " + $value + "\n";
			}
		}
	}
	else if( $projectManagement == "NIM" )
	{
		// THIS GETS DUMPED INTO "SELECTED ENTITY"
		global string $NimInfoKeys[];
		global string $NimInfoValues[];

		if( size( $NimInfoKeys ) > 0 )
		{
			$createEnabled = true;
			$createValue = $forceOn || `checkBox -q -value frw_projMgmtCreateVersion`;

			$versionEnabled = $createValue;
			$descEnabled = $createValue;
			$infoEnabled = $createValue;
			$draftOptionsEnabled = $createValue;

			for( $i = 0; $i < size( $NimInfoKeys ); $i++ )
			{
				string $key = $NimInfoKeys[$i];
				string $value = $NimInfoValues[$i];

				if( $key == "nim_renderName" )
					$versionValue = $value;
				else if( $key == "nim_description" )
					$descValue = $value;
				else  if( $key == "nim_basename" )
					$infoValue += "Basename: " + $value + "\n";
				else if( $key == "nim_jobName" )
					$infoValue += "Job Name: " + $value + "\n";
				else if( $key == "nim_class" )
					$infoValue += "Class: " + $value + "\n";
				else if( $key == "nim_assetName" )
					$infoValue += "Asset Name: " + $value + "\n";
				else if( $key == "nim_showName" )
					$infoValue += "Show Name: " + $value + "\n";
				else if( $key == "nim_shotName" )
					$infoValue += "Shot Name: " + $value + "\n";
				else if( $key == "nim_taskID" )
					$infoValue += "Task ID: " + $value + "\n";
				else if( $key == "nim_itemID" )
					$infoValue += "Item ID: " + $value + "\n";
				else if( $key == "nim_jobID" )
					$infoValue += "Job ID: " + $value + "\n";
				else if( $key == "nim_fileID" )
					$infoValue += "File ID: " + $value + "\n";
			}
		}
	}
	
	$draftIntegrationEnabled = $createValue && `checkBox -q -value frw_submitDraftJob`;
	$quickDraftEnable = (`radioButtonGrp -q -select frw_UseQuickDraftRadio` == 1);

	checkBox -e -enable $createEnabled -value $createValue frw_projMgmtCreateVersion;
	textFieldGrp -e -enable $versionEnabled -text $versionValue frw_projMgmtVersion;
	textFieldGrp -e -enable $descEnabled -text $descValue frw_projMgmtDescription;
	text -e -enable $infoEnabled frw_projMgmtDetailsLabel;
	scrollField -e -enable $infoEnabled -text $infoValue frw_projMgmtDetails;

	checkBox -e -enable $draftIntegrationEnabled frw_uploadDraftToShotgun;
	button -e -enable ($draftIntegrationEnabled && !$quickDraftEnable) frw_projMgmtCreateVersionDataButton;

	text -e -enable $descEnabled frw_projMgmtDraftLabel;
	checkBox -e -enable $descEnabled frw_projMgmtCreateMovie;
	checkBox -e -enable $draftOptionsEnabled frw_projMgmtCreateFilmstrip;
}

//Updates the Project Management Info Key/Values based on the UI
global proc UpdatePMInfo()
{
	string $projectManagement = `optionMenuGrp -q -value frw_projectManagement`;

	if ($projectManagement == "Shotgun")
	{
		global string $SGInfoKeys[];
		global string $SGInfoValues[];

		for ( $i = 0; $i < size( $SGInfoKeys ); $i++ )
		{
			string $key = $SGInfoKeys[$i];

			if ($key == "VersionName")
				$SGInfoValues[$i] = `textFieldGrp -q -text frw_projMgmtVersion`;
			else if ($key == "Description")
				$SGInfoValues[$i] = `textFieldGrp -q -text frw_projMgmtDescription`;
		}
	}
	else if ($projectManagement == "FTrack" )
	{
		global string $FTInfoKeys[];
		global string $FTInfoValues[];

		for ( $i = 0; $i < size( $FTInfoKeys ); $i++ )
		{
			string $key = $FTInfoKeys[$i];

			if ($key == "FT_Description")
				$FTInfoValues[$i] = `textFieldGrp -q -text frw_projMgmtDescription`;
		}
	}
	else if ($projectManagement == "NIM" )
	{
		
		global string $NimInfoKeys[];
		global string $NimInfoValues[];

		for ( $i = 0; $i < size( $NimInfoKeys ); $i++ )
		{
			string $key = $NimInfoKeys[$i];

			if ($key == "nim_renderName")
				$NimInfoValues[$i] = `textFieldGrp -q -text frw_projMgmtVersion`;
			if ($key == "nim_description")
				$NimInfoValues[$i] = `textFieldGrp -q -text frw_projMgmtDescription`;
		}
		
	}

	SavePersistentDeadlineOptions();
}
//=================================================================


//=================================================================
// DRAFT

global proc UsePMValues()
{
	string $projectManagement = `optionMenuGrp -q -value frw_projectManagement`;

	if ($projectManagement == "Shotgun")
	{
		UseShotgunValues();
	}
	if ($projectManagement == "FTrack")
	{
		UseFTrackValues();
	}
	else if ($projectManagement == "NIM" )
	{
		UseNimValues();
	}	
}


//Use values from Shotgun to fill out the Draft fields
global proc UseShotgunValues()
{
	global string $SGInfoKeys[];
	global string $SGInfoValues[];
	
	string $task = "";
	string $project = "";
	string $entity = "";
	
	for( $i = 0; $i < size( $SGInfoKeys ); $i++ )
	{
		if( $SGInfoKeys[ $i ] == "UserName" )
			textFieldGrp -e -text $SGInfoValues[ $i ] frw_DraftUser;
		else if( $SGInfoKeys[ $i ] == "DraftTemplate" )
			textFieldGrp -e -text $SGInfoValues[ $i ] frw_DraftTemplate;
		else if( $SGInfoKeys[ $i ] == "TaskName" )
			$task = $SGInfoValues[ $i ];
		else if( $SGInfoKeys[ $i ] == "ProjectName" )
			$project = $SGInfoValues[ $i ];
		else if( $SGInfoKeys[ $i ] == "EntityName" )
			$entity = $SGInfoValues[ $i ];
	}
	
	if( size( $task ) > 0 )
		textFieldGrp -e -text $task frw_DraftEntity;
	else if( size( $project ) > 0 && size( $entity ) > 0 )
		textFieldGrp -e -text ($project + " > " + $entity) frw_DraftEntity;
	
	textFieldGrp -e -text `textFieldGrp -q -text frw_projMgmtVersion` frw_DraftVersion;
}


//Use values from NIM to fill out the Draft fields
global proc UseFTrackValues()
{
	global string $FTInfoKeys[];
	global string $FTInfoValues[];

	if( size( $FTInfoKeys ) > 0 )
	{
		for( $i = 0; $i < size( $FTInfoKeys ); $i++ )
		{
			string $key = $FTInfoKeys[$i];
			string $value = $FTInfoValues[$i];
			
			if ( $key == "FT_Username" )
				textFieldGrp -e -text $value frw_DraftUser;
			else if ( $key == "FT_TaskName" )
				textFieldGrp -e -text $value frw_DraftEntity;
			
			textFieldGrp -e -text `textFieldGrp -q -text frw_projMgmtVersion` frw_DraftVersion;
		}
	}
}

//Use values from NIM to fill out the Draft fields
global proc UseNimValues()
{
	global string $NimInfoKeys[];
	global string $NimInfoValues[];
	
	string $jobName = "";
	string $taskID = "";
	string $nim_shotName = "";
	string $nim_assetName = "";
	
	for( $i = 0; $i < size( $NimInfoKeys ); $i++ )
	{
		if( $NimInfoKeys[ $i ] == "nim_user" )
			textFieldGrp -e -text $NimInfoValues[ $i ] frw_DraftUser;

		else if( $NimInfoKeys[ $i ] == "nim_jobName" )
			$jobName = $NimInfoValues[ $i ];

		else if( $NimInfoKeys[ $i ] == "nim_taskID" )
			$taskID = $NimInfoValues[ $i ];

		else if( $NimInfoKeys[ $i ] == "nim_shotName" )
			$nim_shotName = $NimInfoValues[ $i ];

		else if( $NimInfoKeys[ $i ] == "nim_assetName" )
			$nim_assetName = $NimInfoValues[ $i ];
	}

	string $entity = "";
	if ( size( $nim_assetName ) > 0 )
		$entity = $nim_assetName;
	else if ( size( $nim_shotName ) > 0 )
		$entity = $nim_shotName;
	
	if( size( $taskID ) > 0 )
		textFieldGrp -e -text $taskID frw_DraftEntity;

	else if( size( $entity ) > 0 )
		textFieldGrp -e -text $entity frw_DraftEntity;
	
	textFieldGrp -e -text `textFieldGrp -q -text frw_projMgmtVersion` frw_DraftVersion;
}

//Gets a Draft Template file.
global proc GetDraftTemplate()
{
	string $newDraftTemplate = CallDeadlineCommand( "-SelectFilenameLoad \"" + `textFieldButtonGrp -q -text frw_DraftTemplate` + "\" \"Python Script Files (*.py);;All Files (*)\"", false );
	if( $newDraftTemplate != "Action was cancelled by user" )
	{	
		textFieldButtonGrp -e -text $newDraftTemplate frw_DraftTemplate;
		SavePersistentDeadlineOptions();
	}
}

global proc UseDraftChanged()
{
	$enable = `checkBox -q -value frw_submitDraftJob`;

	radioButtonGrp -e -enable $enable frw_UseQuickDraftRadio;

	UseQuickDraftChanged();
}

global proc UseQuickDraftChanged()
{
	$draftEnable = `checkBox -q -value frw_submitDraftJob`;
	$quickDraftEnable = (`radioButtonGrp -q -select frw_UseQuickDraftRadio` == 1);
	$createShotgunVersion = `checkBox -q -value frw_projMgmtCreateVersion`;

	optionMenuGrp -e -enable ($draftEnable && $quickDraftEnable) frw_UseQuickDraftFormat;
	optionMenuGrp -e -enable ($draftEnable && $quickDraftEnable) frw_UseQuickDraftResolution;	
	
	checkBox -e -enable ($draftEnable && $createShotgunVersion) frw_uploadDraftToShotgun;
	textFieldButtonGrp -e -enable ($draftEnable && !$quickDraftEnable) frw_DraftTemplate;
	textFieldGrp -e -enable ($draftEnable && !$quickDraftEnable) frw_DraftUser;
	textFieldGrp -e -enable ($draftEnable && !$quickDraftEnable) frw_DraftEntity;
	textFieldGrp -e -enable ($draftEnable && !$quickDraftEnable) frw_DraftVersion;
	textFieldGrp -e -enable ($draftEnable && !$quickDraftEnable) frw_DraftExtraArgs;
	button -e -enable ($draftEnable && $createShotgunVersion && !$quickDraftEnable) frw_projMgmtCreateVersionDataButton;
	
	UpdateCustomDraftFormatOptionsEnabled();
}

global proc int CheckEnableQuality(string $currentFormat, string $currentCodec)
{
	global string $QuickDraftRestrictionsName[];
	global string $QuickDraftRestrictionsType[];
	global string $QuickDraftRestrictionsList[];

	for( $i = 0; $i < size( $QuickDraftRestrictionsName ); $i++ )
	{
		if( $QuickDraftRestrictionsName[$i] == $currentFormat )
		{
			if( $QuickDraftRestrictionsType[$i] == "EnableQuality" )
			{
				string $list[] = {};
				int $innerNumTokens = `tokenize $QuickDraftRestrictionsList[$i] "," $list`;
				if($innerNumTokens >0)
				{
					for( $j = 0; $j < $innerNumTokens; $j++ )
					{
						if( strip($list[$j]) == strip($currentCodec) )
						{
							return true;
						}
					}
				}
			}
		}
	}
	return false;
}

global proc UpdateCustomDraftFormatOptionsEnabled()
{
	global string $QuickDraftFormats[];
	global string $QuickDraftFormatFile[];
	global string $QuickDraftFormatMovie[];
	
	$draftEnable = `checkBox -q -value frw_submitDraftJob`;
	$quickDraftEnable = (`radioButtonGrp -q -select frw_UseQuickDraftRadio` == 1);
	
	string $currentFormat = `optionMenuGrp -q -value frw_UseQuickDraftFormat`;
	string $currentCodec = `optionMenuGrp -q -value frw_UseQuickDraftCodecs`;
	int $index = stringArrayFind( $currentFormat, 0, $QuickDraftFormats );
	if( $index >= 0)
	{
		$currentFormat = $QuickDraftFormatFile[ $index ];
	}
	else
	{
		$currentFormat = "";
		print( "Error in Deadline Submission Script: could not find Quick Draft format \"" + $currentFormat + "\"\n" );
	}
	
	$qualityEnable = CheckEnableQuality( $currentFormat, $currentCodec );

	$isMovie = false;
	if( $index >= 0 )
	{
		$isMovie = ( $QuickDraftFormatMovie[$index] == "movie" );
	}

	optionMenuGrp -e -enable ($draftEnable && $quickDraftEnable) frw_UseQuickDraftCodecs;
	optionMenuGrp -e -enable ($draftEnable && $isMovie && $quickDraftEnable) frw_UseQuickDraftFrameRate;
	intSliderGrp -e -enable ($draftEnable && $quickDraftEnable && $qualityEnable) frw_UseQuickDraftQuality;
	
	SavePersistentDeadlineOptions();
}

global proc CustomDraftFormatChanged()
{
	global string $QuickDraftFormats[];
	global string $QuickDraftFormatMovie[];
	global string $QuickDraftCodecsName[];
	global string $QuickDraftCodecsList[];
	global string $QuickDraftFormatFile[];
	global string $QuickDraftFrameRates[];
	
	string $currentFormat = `optionMenuGrp -q -value frw_UseQuickDraftFormat`;
	string $currentCodec = `optionMenuGrp -q -value frw_UseQuickDraftCodecs`;
	string $codecs[] = GetCodecs($currentFormat);
	int $index = stringArrayFind( $currentFormat, 0, $QuickDraftFormats );
	if( $index >= 0)
	{
		$currentFormat = $QuickDraftFormatFile[ $index ];
	}
	else
	{
		$currentFormat = "";
	}
	
	
	$codecs = ApplyRestrictions( $currentFormat, "Codec", $codecs);
	
	string $codecsToRemove[] = `optionMenuGrp -q -ill frw_UseQuickDraftCodecs`;
	
	string $item;
	for ($item in $codecsToRemove)
		deleteUI $item;
	
	for( $i = 0; $i < size( $codecs ); ++$i )
	{ 
		menuItem -label $codecs[$i] -parent "frw_UseQuickDraftCodecs|OptionMenu";
		if( $codecs[$i] == $currentCodec )
		{
			optionMenuGrp -e -select ($i+1) frw_UseQuickDraftCodecs;
		}
	}
	
	$currentCodec = `optionMenuGrp -q -value frw_UseQuickDraftCodecs`;
	string $currentFrameRate = `optionMenuGrp -q -value frw_UseQuickDraftFrameRate`;
	
	string $frameRates[] = $QuickDraftFrameRates;
	$frameRates = ApplyRestrictions( $currentFormat, "FrameRate", $frameRates);
	$frameRates = ApplyRestrictions( $currentCodec, "FrameRate", $frameRates);

	string $frameRatesToRemove[] = `optionMenuGrp -q -ill frw_UseQuickDraftFrameRate`;
	for ($item in $frameRatesToRemove)
		deleteUI $item;
	
	for( $i = 0; $i < size( $frameRates ); ++$i )
	{ 
		menuItem -label $frameRates[$i] -parent "frw_UseQuickDraftFrameRate|OptionMenu";
		if( $frameRates[$i] == $currentFrameRate )
		{
			optionMenuGrp -e -select ($i+1) frw_UseQuickDraftFrameRate;
		}
	}
	
	UpdateCustomDraftFormatOptionsEnabled();
}

global proc CustomDraftCodecChanged()
{
	global string $QuickDraftFormats[];
	global string $QuickDraftFormatFile[];
	global string $QuickDraftFrameRates[];
	
	string $currentFormat = `optionMenuGrp -q -value frw_UseQuickDraftFormat`;
	int $index = stringArrayFind( $currentFormat, 0, $QuickDraftFormats );
	if( $index >= 0)
	{
		$currentFormat = $QuickDraftFormatFile[ $index ];
	}
	else
	{
		$currentFormat = "";
	}
	string $currentCodec = `optionMenuGrp -q -value frw_UseQuickDraftCodecs`;
	
	string $currentFrameRate = `optionMenuGrp -q -value frw_UseQuickDraftFrameRate`;
	
	string $frameRates[] = $QuickDraftFrameRates;
	$frameRates = ApplyRestrictions( $currentFormat, "FrameRate", $frameRates);
	$frameRates = ApplyRestrictions( $currentCodec, "FrameRate", $frameRates);

	string $frameRatesToRemove[] = `optionMenuGrp -q -ill frw_UseQuickDraftFrameRate`;
	for ($item in $frameRatesToRemove)
		deleteUI $item;
		
	for( $i = 0; $i < size( $frameRates ); ++$i )
	{ 
		menuItem -label $frameRates[$i] -parent "frw_UseQuickDraftFrameRate|OptionMenu";
		if( $frameRates[$i] == $currentFrameRate )
		{
			optionMenuGrp -e -select ($i+1) frw_UseQuickDraftFrameRate;
		}
		
	}

	$draftEnable = `checkBox -q -value frw_submitDraftJob`;
	$quickDraftEnable = (`radioButtonGrp -q -select frw_UseQuickDraftRadio` == 1);
	$qualityEnable = CheckEnableQuality( $currentFormat, $currentCodec );
	intSliderGrp -e -enable ($draftEnable && $quickDraftEnable && $qualityEnable) frw_UseQuickDraftQuality;
	
	SavePersistentDeadlineOptions();
}


//=================================================================

//---------------------------------------------------------
// Maya Helper Functions
//---------------------------------------------------------

// Returns the current version of Maya.
global proc float MayaVersion()
{
	float $version = getApplicationVersionAsFloat();
	if( $version < 2014 || $version == 2016 )
	{
		// Before 2014, getApplicationVersionAsFloat would parse `about -v`, which wouldn't include the .5 at the end of the Maya 2011.5 or 2013.5 releases.
		// This was fixed in 2014 by parsing `about -apiVersion`, so that's what we're doing here.
		int $apiVersion = `about -apiVersion`;
		$version = float($apiVersion) / 100.0;
	}
	if( $version = 2018 )
	{
		$version = 2017.5;
	}
	print "versiyon\n\n";
	print $version;
	return $version;
}

// Returns the current version of Maya as an integer.
global proc int IntMayaVersion()
{
	float $version = MayaVersion();
	return floor ( $version );
}

// Returns the current renderer.
global proc string GetCurrentRenderer()
{
	string $renderer = currentRenderer();
	if( $renderer == "_3delight" )
		$renderer = "3delight";
	return $renderer;
}

// Returns if we're using an older version of vray
global proc string IsOldVray()
{
	// This function contains 3 parameters in the new version, so if this eval
	// returns an error (ie: 1), then we know it's an old version of Vray.
	return catchQuiet( eval( "vrayTransformFilename( \"\", \"\", \"\" )" ) );
}

// Returns the output prefix as is shown in the Render Globals, except that the frame
// number is replaced with '?' padding.
//global proc string GetOutputPrefix( int $replaceFrameNumber, int $newFrameNumber )
global proc string GetOutputPrefix( int $replaceFrameNumber, int $newFrameNumber, string $layerName, string $cameraName, string $renderElement )
{
	string $outputPrefix = "";
	string $paddingString = "";
	
	string $renderer = GetCurrentRenderer();
	
	string $renderableCameras[] = deadlineGetRenderableCameras( false );
	
	int $multipleRenderableCams = ( size ( $renderableCameras ) > 1 );
	
	
	if( $renderer == "vray" )
	{
		// Need to special case vray, because they like to do things differently.
		global string $g_vrayImgExt[];
		
		string $ext = "";
		if (`optionMenuGrp -exists vrayImageFormatMenu`)
			$ext = `optionMenuGrp -q -v vrayImageFormatMenu`;
		else
			$ext = `getAttr vraySettings.imageFormatStr`;
			if ($ext == "")
				$ext = "png";//for some reason this happens if you have not changed the format
				
		// VRay can append this to the end of the render settings display, but we don't want it in the file name.
		int $isMultichannelExr = false;
		string $multichannel = " (multichannel)";
		if( endsWith( $ext, $multichannel ) )
		{
			$ext = substring( $ext, 1, size( $ext ) - size( $multichannel ) );
			$isMultichannelExr = true;
		}
		string $versionString = `vray version`;
		int $version = 2;
		int $minorVersion = 0;
		if( $versionString != ""  )
		{
			string $buffer[];
		
			tokenize($versionString, ".", $buffer);
			$version = (int)$buffer[0];
			$minorVersion = (int)$buffer[1];
		}
		
		
		// We need to use eval because the definition of vrayTransformFilename is different for
		// different versions of vray, and this is the only way to get around the "incorrect
		// number of arguments" error.
		string $prefix = `getAttr vraySettings.fileNamePrefix`;
		
		int $separateFolders = `getAttr "vraySettings.relements_separateFolders"`;
		
		int $separateRGBA = 0;
		if( !catchQuiet( `getAttr "vraySettings.relements_separateRGBA"` ) )
		{
			 $separateRGBA = `getAttr "vraySettings.relements_separateRGBA"`;
		}
		
		/*
		if( IsOldVray() )
			$prefix = eval( "vrayTransformFilename( \"" + $prefix + "\", \"\" )" );
		else
			$prefix = eval( "vrayTransformFilename( \"" + $prefix + "\", \"\", \"\" )" );
		*/
		
		if( $prefix == "" )
		{
			$prefix = GetStrippedSceneFileName();
		}
		
		if( $renderElement != "" && $separateFolders )
		{
			string $tempPrefix = `dirname($prefix)`;
			if( $tempPrefix != "" )
			{
				$tempPrefix = $tempPrefix+ "/";
			}
			$prefix = $tempPrefix + $renderElement + "/" + basename($prefix,"");
		}
		else if( $renderElement == "" && $separateFolders && $separateRGBA  )
		{
			string $tempPrefix = `dirname($prefix)`;
			if( $tempPrefix != "" )
			{
				$tempPrefix = $tempPrefix+ "/";
			}
			$prefix = $tempPrefix + "rgba/" + basename($prefix,"");
		}
		
		if( $multipleRenderableCams && ( `match "<Camera>" $prefix`== "" ) && ( `match "<camera>" $prefix`== "" ) && ( `match "%c" $prefix`== "" ) )
		{
			$prefix = "<Camera>/" + $prefix;
		}
		
		if( IsRenderLayersOn() && ( `match "<Layer>" $prefix`== "" ) && ( `match "<layer>" $prefix`== "" ) && ( `match "%l" $prefix`== "" ) )
		{
			$prefix = "<Layer>/" + $prefix;
		}
		
		
		// Don't transform if the prefix is blank, so we can just default to the scene file name.
		if( $prefix != "" )
		{
			if( !catchQuiet( eval( "vrayTransformFilename( \"\", \"\", \"\", 0, 0 )" ) ) )
			{
				// Vray strips off all extensions in the scene name when replacing the <Scene> tag.
				string $sceneName = GetStrippedSceneFileName();
				
				if( $version < 3 || ( $version == 3 && $minorVersion == 0 ) )
				{
					$sceneName = `basenameEx $sceneName`;
				}
				$prefix = eval( "vrayTransformFilename( \"" + $prefix + "\", \"" + $cameraName + "\", \"" + $sceneName + "\", 0, 0 )" );
			}
			else if( !catchQuiet( eval( "vrayTransformFilename( \"\", \"\", \"\", 0 )" ) ) )
			{
				// Vray strips off all extensions in the scene name when replacing the <Scene> tag.
				string $sceneName = GetStrippedSceneFileName();
				if( $version < 3 || ( $version == 3 && $minorVersion == 0 ) )
				{
					$sceneName = `basenameEx $sceneName`;
				}
				$prefix = eval( "vrayTransformFilename( \"" + $prefix + "\", \"" + $cameraName + "\", \"" + $sceneName + "\", 0 )" );
			}
			else if( !catchQuiet( eval( "vrayTransformFilename( \"\", \"\", \"\" )" ) ) )
				$prefix = eval( "vrayTransformFilename( \"" + $prefix + "\", \"\", \"\" )" );
			else if( !catchQuiet( eval( "vrayTransformFilename( \"\", \"\" )" ) ) )
				$prefix = eval( "vrayTransformFilename( \"" + $prefix + "\", \"\" )" );
			else
				print( "Could not evaluate output path using vrayTransformFilename, please contact Deadline support and include the version of vray you are using\n" );
		}
		
		//if( catchQuiet( eval( "vrayTransformFilename( \"" + $prefix + "\", \"\", \"\" )" ) ) )
		//{
		//	if( catchQuiet( eval( "vrayTransformFilename( \"" + $prefix + "\", \"\" )" ) ) )
		//		$prefix = `getAttr vraySettings.fileNamePrefix`;
		//}
		
		//if( $prefix == "" )
		//	$prefix = GetStrippedSceneFileName();
		
		if( $renderElement != "" && $isMultichannelExr == 0 )
		{			
			$prefix = $prefix + (`getAttr "vraySettings.fileNameRenderElementSeparator"`) + $renderElement;			
		}
		else if ( $renderElement == "" && $separateFolders && $separateRGBA && $isMultichannelExr == 0 )
		{
			$prefix = $prefix + (`getAttr "vraySettings.fileNameRenderElementSeparator"`) + "rgba";	
		}
		
		if( IsAnimatedOn() )
		{
			// Seems to be a bug where no matter what, VRay will use 4 digits for padding.
			// If ever fixed, try using the value from the vray settings.
			//int $padding = `getAttr vraySettings.fileNamePadding`;
			int $padding = 4;
			if($version >= 3)
				$padding = `getAttr vraySettings.fileNamePadding`;
			for( $i = 0; $i < $padding; $i ++ )
				$paddingString = $paddingString + "#";
			
			// When rendering to a non-raw format, vray places a period before the padding, even though it
			// doesn't show up in the render globals filename.
			if( $ext == "vrimg" || ($isMultichannelExr && $version < 3) )
				$outputPrefix = $prefix + $paddingString + "." + $ext;
			else
				$outputPrefix = $prefix + "." + $paddingString + "." + $ext;
		}
		else
		{
			// When rendering to a non-raw format, vray places a period before the padding, even though it
			// doesn't show up in the render globals filename.
			if( $ext == "vrimg" || ($isMultichannelExr && $version < 3) )
				$outputPrefix = $prefix + "." + $ext;
			else
				$outputPrefix = $prefix + "." + $ext;
		}
	}
	else
	{
		int $paddingFound = 0;
		
		// Get the first output prefix.
		string $prefixString = "";
		if( $renderer == "renderMan" || $renderer == "renderManRIS" )
		{
			//$prefixString = `rmanGetImageName 1`;
			if( $cameraName == "" )
			{
				string $pat = rmanGetImagenamePattern(1);
				string $ftext = rmanGetImageExt("");
				$prefixString= rman("assetref",
										"-cls", "Final",
										"-assetnmpat", $pat,
										"-ref", "$ASSETNAME",
										"-LAYER", $layerName,
										"-EXT", $ftext,
										"-DSPYID", "",
										"-DSPYCHAN", "");
			}
			else
			{
				string $cameraRelatives[] = `listRelatives -s $cameraName`;
			
				string $camera = $cameraRelatives[0];
				string $pat = rmanGetImagenamePattern(1);
				string $ftext = rmanGetImageExt("");
				$prefixString= rman("assetref",
										"-cls", "Final",
										"-assetnmpat", $pat,
										"-ref", "$ASSETNAME",
										"-LAYER", $layerName,
										"-CAMERA", $camera,
										"-EXT", $ftext,
										"-DSPYID", "",
										"-DSPYCHAN", "");
				}
			
			
		}
		else if($renderer == "MayaKrakatoa")
		{
			//string $prefixes[] = `renderSettings -fin`;
			string $prefixes[] = `renderSettings -fin -lyr $layerName -cam $cameraName`;
			$prefixString = $prefixes[0];
			
			int $forceEXROutput = `getAttr "MayaKrakatoaRenderSettings.forceEXROutput"`;
			if($forceEXROutput == 1)
			{
				string $tokens[];
				tokenize $prefixString "." $tokens;
				string $result = "";
				int $i;
				
				for($i = 0; $i<size($tokens)-1; $i++)
				{
					$result += $tokens[$i] + ".";
				}
				$prefixString = $result + "exr";
			}
		}
		else
		{
			string $currentPrefix = `getAttr defaultRenderGlobals.imageFilePrefix`;
			
			string $newPrefix = $currentPrefix;
			if( $newPrefix == "" )
			{
				$newPrefix = GetStrippedSceneFileName();
			}
			
			if( $renderer == "arnold" && `match "<RenderPass>" $newPrefix`== ""  )
			{
				$elements = getArnoldElementNames();
				
				if( $elements[0] != "" )
				{
					$newPrefix = "<RenderPass>/" + $newPrefix;
				}
			}
			
			if( $renderer == "mentalRay" && `match "<RenderPass>" $newPrefix`== ""  )
			{
				$elements = getMentalRayElementNames( $layerName );
				if( $elements[0] != "" )
				{
					$newPrefix = "<RenderPass>/" + $newPrefix;
				}
			}
			
			if( $multipleRenderableCams && ( `match "<Camera>" $newPrefix`== "" ) && ( `match "%c" $newPrefix`== "" ) )
			{
				$newPrefix = "<Camera>/" + $newPrefix;
			}
			
			if( IsRenderLayersOn() && ( `match "<RenderLayer>" $newPrefix`== "" ) && ( `match "<Layer>" $newPrefix`== "" ) && ( `match "%l" $newPrefix`== "" ) )
			{
				$newPrefix = "<RenderLayer>/" + $newPrefix;
			}
			setAttr "defaultRenderGlobals.imageFilePrefix" -type "string" $newPrefix;
			
			//string $prefixes[] = `renderSettings -fin`;
			string $prefixes[] = `renderSettings -fin -lyr $layerName -cam $cameraName -cts ("RenderPass=" + $renderElement )`;
			$prefixString = $prefixes[0];
			
			setAttr "defaultRenderGlobals.imageFilePrefix" -type "string" $currentPrefix;
		}
	
		// Go through each letter of the prefix and create a new prefix with each letter
		// separated by colons, ie: f:i:l:e:n:a:m:e:.:e:x:t:
		string $prefixWithColons = "";
		for( $i = 1; $i <= size( $prefixString ); $i++ )
			$prefixWithColons += substring( $prefixString, $i, $i ) + ":";
	
		// Now split up the new prefix into an array, which removes all the colons and
		// places one letter in each index. Then count backwards and replace the first
		// group of numbers with the padding characters.
		string $prefix[] = stringToStringArray( $prefixWithColons, ":" );
		
		if( IsAnimatedOn() )
		{
			for( $i = size( $prefix ); $i > 0; $i-- )
			{
				if( match( "[0-9]", $prefix[$i] ) != "" )
				{
					$prefix[$i] = "#";
					$paddingString = $paddingString + "#";
					$paddingFound = 1;
				}
				else if( $paddingFound )
				{
					if( $prefix[$i] == "-" )
					{
						$prefix[$i] = "#";
						$paddingString = $paddingString + "#";
					}
					break;
				}
			}
		}
	
		// Finally, convert the prefix array back to a string.
		$outputPrefix = stringArrayToString( $prefix, "" );
		
		if( $renderer == "maxwell" && $renderElement != "" )
		{
			string $prefixParts[] = stringToStringArray( $outputPrefix, "." );
			int $numParts = size( $prefixParts );
			int $mainPart = $numParts -2;
			if( IsAnimatedOn() )
				$mainPart -= 1;
			
			$prefixParts[ $mainPart ] = $prefixParts[ $mainPart ] + "_" + $renderElement;
			
			int $extNumber = 0;			
			if( $renderElement == "zbuffer"  )
			{
				$extNumber = `getAttr maxwellRenderOptions.depthChannelFormat`;
			}
			else if( $renderElement == "object"  )
			{
				$extNumber = `getAttr maxwellRenderOptions.objIDChannelFormat`;
			}
			else if( $renderElement == "material"  )
			{
				$extNumber = `getAttr maxwellRenderOptions.matIDChannelFormat`;
			}
			else if( $renderElement == "motion"  )
			{
				$extNumber = `getAttr maxwellRenderOptions.motionVectorChannelFormat`;
			}
			else if ( startsWith($renderElement, "customAlpha_") )
			{
				$extNumber = `getAttr maxwellRenderOptions.customAlphaChannelFormat`;
			}
			else
			{
				$extNumber = `getAttr( "maxwellRenderOptions." + $renderElement + "ChannelFormat")`;
			}
			$prefixParts[ $numParts -1 ] = getMaxwellChannelExtension($extNumber, true);
			$outputPrefix = stringArrayToString($prefixParts, ".");
		}
		else if( $renderer == "maxwell")
		{
			int $format = `getAttr defaultRenderGlobals.imageFormat`;
			
			$outputPrefix = `substring $outputPrefix 1 (size($outputPrefix)-3)`;
			$outputPrefix =  $outputPrefix + getMaxwellChannelExtension($format, false);
			
		}
	
	}
	
	if( IsAnimatedOn() && $replaceFrameNumber )
	{
		string $paddedFrame = "" + $newFrameNumber;
		while( size($paddedFrame) < size($paddingString) )
			$paddedFrame = "0" + $paddedFrame;
		$outputPrefix = substituteAllString( $outputPrefix, $paddingString, $paddedFrame );
	}
	
	return $outputPrefix;
}

global proc string CreateArgumentsFile( string $argumentList[] )
{
	string $tempDir = CallDeadlineCommand( "-GetCurrentUserHomeDirectory", false ) + "/temp";
	// Submit the job to Deadline
	string $submissionCommandFile = CheckSlashes( $tempDir + "/maya_submission.txt" );
	$fileId = `fopen $submissionCommandFile "w"`;
	for($argument in $argumentList)
	{
		fprint $fileId ( $argument + "\n" );
	}
	
	fclose $fileId;
	
	return $submissionCommandFile;
}

global proc string GetJigsawOutputPrefix(string $outputPrefix, int $region, string $renderer)
{
	string $path = dirname( $outputPrefix );
	if( $path != "" )
		$path = $path + "/";
	
	string $base = basename( $outputPrefix, "" );
	
	string $tile = "region_"+$region+"_";
	if( $renderer != "renderMan" && $renderer != "renderManRIS" )
	{
		$tile = "_" + $tile;
	}
	return $path+$tile+$base;
}

// Creates a tile prefix from the given prefix by placing the tile part at the
// beginning of the filename. It's placed at the beginning to try and avoid as
// many conflicts as possible with Maya's prefix shortcuts.
global proc string GetTileOutputPrefix( string $outputPrefix, int $x, int $y, int $xCount, int $yCount, string $renderer )
{
	string $path = dirname( $outputPrefix );
	if( $path != "" )
		$path = $path + "/";
	
	string $base = basename( $outputPrefix, "" );
	string $tile = "tile_" + $x + "x" + $y + "_" + $xCount + "x" + $yCount + "_";
	if( $renderer != "renderMan" && $renderer != "renderManRIS" )
	{
		$tile = "_" + $tile;
	}
	return $path + $tile + $base;
}

global proc string GetMayaOutputPrefix( string $currCamera, string $layer )
{
	
	string $prefix = "";
	string $renderer = GetCurrentRenderer();
	
	// Source a CustomOutputPrefix.mel file, if it exists.
	string $outputPrefixPath = CheckSlashes( GetMayaRepoPath() + "CustomOutputPrefix.mel" );	

	if( `file -q -exists $outputPrefixPath` )
	{
		print( "sourcing custom outputprefix file: " + $outputPrefixPath + "\n" );
		eval( "source \"" + $outputPrefixPath + "\";" );
		$prefix = GetCustomMayaOutputPrefix( $currCamera );
	}
	else
	{
		if( $renderer != "vray" )
			$prefix = `getAttr defaultRenderGlobals.imageFilePrefix`;
		else
			$prefix = `getAttr vraySettings.fileNamePrefix`;
	}
	
	if( $prefix == "" )
	{
		$prefix = GetStrippedSceneFileName();
	}	
	
	if( $renderer == "arnold" && `match "<RenderPass>" $prefix`== ""  )
	{
		$elements = getArnoldElementNames();
		
		if( $elements[0] != "" )
		{
			$prefix = "<RenderPass>/" + $prefix;
		}
	}
	
	if( $renderer == "mentalRay" && `match "<RenderPass>" $prefix`== ""  )
	{
		$elements = getMentalRayElementNames( $layer );
		if( $elements[0] != "" )
		{
			$prefix = "<RenderPass>/" + $prefix;
		}
	}
	
	string $renderableCameras[] = deadlineGetRenderableCameras( false );
	int $multipleRenderableCams = ( size ( $renderableCameras ) > 1 );
	//Redshift does not work with multiple renderable cameras so we need to node add <camera>
	if( $multipleRenderableCams )
	{
		// vray accepts <camera> as a token, whereas no one else does
		if( ( `match "<Camera>" $prefix`== "" ) && ( `match "%c" $prefix`== "" ) && $renderer != "redshift" && ( $renderer != "vray" || `match "<camera>" $prefix`== "" ) )
		{
			$prefix = "<Camera>/" + $prefix;
		}
	}
	
	if( IsRenderLayersOn() )
	{
		if( $renderer == "vray" && ( `match "<Layer>" $prefix`== "" ) && ( `match "<layer>" $prefix`== "" ) && ( `match "%l" $prefix`== "" ) )
		{
			$prefix = "<Layer>/" + $prefix;
		}
		else if($renderer != "vray" && ( `match "<RenderLayer>" $prefix`== "" ) && ( `match "<Layer>" $prefix`== "" ) && ( `match "%l" $prefix`== "" ) )
		{
			$prefix = "<RenderLayer>/" + $prefix;
		}
	}
	
	return $prefix;
}

// Gets the image directory for Maya.
global proc string GetImageDirectory()
{
	string $imageDir = "";
	
	// The -renderType flag is obsolete in 2013 and later.
	if( IntMayaVersion() <= 2012 )
	{
		// Relative path, get the project's image directory.
		string $fileRules[] = `workspace -q -renderType`;
		
		for( $i = 0; $i < size( $fileRules ); $i += 2 )
		{
			if( $fileRules[$i] == "images" )
			{
				$imageDir = $fileRules[$i+1];
				break;
			}
		}
	}
	else
	{
		// Relative path, get the project's image directory.
		$imageDir = `workspace -q -fileRuleEntry "images"`;
	}

	string $path = `workspace -q -fullName`;
	if( substring( $path, size( $path ), size( $path ) ) != "\\" && substring( $path, size( $path ), size( $path ) ) != "/" )
		$path = $path + "/";

	if( $imageDir == "" )
		return $path;

	if( substring( $imageDir, size( $imageDir ), size( $imageDir ) ) != "\\" && substring( $imageDir, size( $imageDir ), size( $imageDir ) ) != "/" )
		$imageDir = $imageDir + "/";
	
	// Check for an absolute path in the image directory.
	if( substring( $imageDir, 1, 1 ) == "/" || substring( $imageDir, 1, 1 ) == "\\" || substring( $imageDir, 2, 2 ) == ":" )
		$path = $imageDir;
	else
		$path = $path + $imageDir;
		
	return $path;
}


// Returns frame range and by step count.
global proc int[] GetFrameRange()
{
	int	$range[3] = { 0, 0, 1 };
	
	if( IsAnimatedOn() )
	{
		//string $renderer = GetCurrentRenderer();	
		//if( $renderer != "vray" )
		//{
			$range[0] = `getAttr defaultRenderGlobals.startFrame`;
			$range[1] = `getAttr defaultRenderGlobals.endFrame`;
			$range[2] = `getAttr defaultRenderGlobals.byFrameStep`;
		//}
		//else
		//{
		//	$range[0] = `getAttr vraySettings.startFrame`;
		//	$range[1] = `getAttr vraySettings.endFrame`;
		//	$range[2] = `getAttr vraySettings.frameStep`;
		//}
	}
	else
	{
		$range[0] = `currentTime -q`;
		$range[1] = `currentTime -q`;
		$range[2] = 1;
	}
	
	return $range;
}

// Returns global resolution.
global proc int[] GetGlobalsResolution()
{
	int	$res[2] = { 320, 240 };
	
	string $renderer = GetCurrentRenderer();
	if( $renderer != "vray" )
	{
		string $globals[] = `ls -renderGlobals`;
		if( size( $globals[0] ) > 0 )
		{
			string $connect[] = `listConnections ($globals[0] + ".resolution")`;
			if( size( $connect[0] ) > 0 )
			{
				$res[0] = `getAttr ( $connect[0] + ".width" )`;
				$res[1] = `getAttr ( $connect[0] + ".height" )`;
			}
		}
	}
	else
	{
		$res[0] = `getAttr vraySettings.width`;
		$res[1] = `getAttr vraySettings.height`;
	}
	
	return $res;
}

// Returns if animation is enabled.
global proc int IsAnimatedOn()
{
	string $renderer = GetCurrentRenderer();
	
	int $anim = false;
	/*
	if( $renderer == "vray" )
	{
		if( IsOldVray() )
			$anim = `getAttr vraySettings.animation`;
		else
			$anim = `getAttr defaultRenderGlobals.animation`;
	}
	else
	*/
		$anim = `getAttr defaultRenderGlobals.animation`;
	
	return $anim;
}

// Returns if motion blur is enabled.
global proc int GetMotionBlur()
{
	string $renderer = GetCurrentRenderer();
	
	int $mb = false;
	if( $renderer == "mentalRay" )
		$mb = `getAttr miDefaultOptions.motionBlur`;
	else if( $renderer == "mayaHardware" || $renderer == "mayaHardware2" )
		$mb = `getAttr hardwareRenderGlobals.enableMotionBlur`;
	else if( $renderer == "mayaVector" )
		$mb = false;
	else if( $renderer == "turtle" )
		$mb = `getAttr TurtleRenderOptions.motionBlur`;
	else if( $renderer == "renderMan" || $renderer == "renderManRIS" )
		$mb = `getAttr renderManGlobals.rman__torattr___motionBlur`;
	else if( $renderer == "finalRender" )
		$mb = `getAttr defaultFinalRenderSettings.motionBlur`;
	else if( $renderer == "vray" )
		$mb = `getAttr vraySettings.cam_mbOn`;
	else
		$mb = `getAttr defaultRenderGlobals.motionBlur`;
	
	return $mb;
}

// Returns if render layers is on.
global proc int IsRenderLayersOn()
{
	string $renderLayers[] = `ls -exactType "renderLayer"`;
	string $referenceLayers[] = `ls -rn -exactType "renderLayer"`;
	return ( ( size($renderLayers) - size($referenceLayers) ) > 1);
}

global proc string[] getRenderableRenderLayers( int $onlyReferenced )
{
	string $renderLayerList[] = `ls -exactType "renderLayer"`;	
	// Loop through the render layer if the checkbox is on
	string $renderableLayers[] = {};

	for( $layer in $renderLayerList )
	{
		// Only get output if the renderable attribute is on
		int $renderable = `getAttr( $layer + ".renderable" )`;
		
		if( $renderable )
		{
			int $isReferenceLayer = `referenceQuery -inr $layer`;
			
			if( $isReferenceLayer && $onlyReferenced )
			{
				stringArrayInsertAtIndex(0, $renderableLayers, $layer );
			} 
			else if( !$isReferenceLayer && !$onlyReferenced )
			{
				stringArrayInsertAtIndex(0, $renderableLayers, $layer );
			}
		}
	}
    
    return $renderableLayers;
}


global proc string[] deadlineGetRenderableCameras( int $ignoreDefaultCameras )
{
	string $cameraNames[] = `listTransforms -cameras`;
	string $renderableCameras[] = {};

	for( $cameraName in $cameraNames )
	{
		if( IsCameraRenderable( $cameraName ) )
		{
			string $relatives[] = `listRelatives -s $cameraName`;
			string $cameraShape = $relatives[0];
			// Only submit default cameras if the setting to ignore them is disabled.
			if( !$ignoreDefaultCameras || !IsDefaultCamera( $cameraShape ) )
			{
		
				stringArrayInsertAtIndex(0, $renderableCameras, $cameraName );
			}
		}
	}
	
	return $renderableCameras;
}

global proc int IsDefaultCamera( string $cameraName )
{
	if( $cameraName == "frontShape" || $cameraName == "perspShape" || $cameraName == "sideShape" || $cameraName == "topShape" )
		return true;
	else if( $cameraName == "front" || $cameraName == "persp" || $cameraName == "side" || $cameraName == "top" )
		return true;
	else
		return false;
}

global proc int IsCameraRenderable( string $cameraName )
{
	//print( "Checking if camera is renderable: " + $cameraName + "\n" );
	
	string $relatives[] = `listRelatives -s $cameraName`;
	string $cameraShape = $relatives[0];
	
	int $cameraRenderable = 0;
	
	// Getting the renderable attribute can throw an error if there are duplicate camera shape names.
	// The catch blocks are to prevent these erros so that the submission can continue.
	if( !catch(`attributeExists "renderable" $cameraShape`) )
		catch($cameraRenderable = `getAttr( $cameraShape + ".renderable" )`);
	
	return $cameraRenderable;
}

// Returns if the renderer supports region rendering.
global proc int SupportsRegionRendering( string $renderer )
{
	if( $renderer == "arnold" || $renderer == "mayaSoftware" ||  $renderer == "mentalRay" ||  $renderer == "renderMan" || $renderer == "renderManRIS" || $renderer == "finalRender" || $renderer == "turtle" || $renderer == "vray"  || $renderer == "ifmIrayPhotoreal" )
		return true;
	return false;
}

// Returns if the y-axis for region rendering is inverted for the given renderer.
global proc int IsRegionRenderingInverted( string $renderer )
{
	if( $renderer != "renderMan" && $renderer != "renderManRIS" && $renderer != "vray" && $renderer != "arnold" )
		return true;
	return false;
}

// Returns if the renderer supports the CPU option.
global proc int EnableCpuOption( string $renderer )
{
	if( IsRenderLayersOn() )
		return true;
	else
	{
		if( $renderer == "mayaSoftware" || $renderer == "mentalRay" || $renderer == "renderMan" || $renderer == "renderManRIS" || $renderer == "finalRender" || $renderer == "gelato" || $renderer == "maxwell" || $renderer == "vray" )
			return true;
	}
	
	return false;
}

// Returns the cpu count selected for the current render (if any).
global proc int GetCpuSetting( string $renderer )
{
	if( $renderer == "mayaSoftware" )
	{
		int $cpus = `getAttr defaultRenderGlobals.numCpusToUse`;
		if( $cpus > 0 )
			return $cpus;
	}
	else if( $renderer == "maxwell" )
	{
		int $cpus = `getAttr "maxwellRenderOptions.numThreads"`;
		if( $cpus > 0 )
			return $cpus;
	}
	else if( $renderer == "vray" )
	{
		int $cpus = `getAttr( "vraySettings.sys_max_threads" )`;
		if( $cpus > 0 )
			return $cpus;
	}
	
	return 0;
}

// Returns if the renderer supports half frame rendering.
global proc int ShowHalfFramesOption( string $renderer )
{
	if( !IsRenderLayersOn() )
	{
		if( $renderer == "renderman" || $renderer == "renderManRIS" || $renderer == "vray" )
			return false;
	}
	
	return true;
}

// Opens the mental ray export settings dialog.
global proc OpenExportSettings()
{
	fileOptions "ExportAll" "projectViewer ExportAll";
}

// Launches the Maya online help
global proc OnlineHelp()
{
	CallDeadlineCommand( "-startprocess http://www.thinkboxsoftware.com/support/", false );
}

//--------------------------------------------------------
// Utility Functions
// --------------------------------------------------------

// Waits for a fixed amount of time (in milliseconds)
global proc Wait( int $waitTime )
{
	$startTime = `timerX`;
	
	while (`timerX -startTime $startTime` * 1000 < $waitTime )
	{ /* Do nothing... weeeee! */ }
}

// Returns the filename with the path and extension stripped off.
global proc string StripPathAndExt( string $fullFileName )
{
	string $fileNameNoPath = match( "[^/\\]*$", $fullFileName );
	string $fileNameOnly = match( "[^\.]*", $fileNameNoPath );
	
	return $fileNameOnly;
}

global proc string GetStrippedSceneFileName()
{
	string $fileName =`file -q -sceneName`;
	$fileName = `basename $fileName ".mb"`;
	$fileName = `basename $fileName ".ma"`;
	
	return $fileName;
}

// Ensures that all slashes are consistent throughout the filename.
global proc string CheckSlashes( string $filename )
{
	//string $result = substituteAllString( $filename, "\\", "/" ); // switch from '\' to '/'
	//$result = substituteAllString( $result, "//", "/" ); // replace double '/' where paths may have been combined
	//if( startsWith( $result, "/" ) )
	//	$result = "/" + $result;
	//return $result;
	
	string $result = $filename;
	string $newResult;
	$newResult = `substitute "\\\\" $result "/"`;
	while( $newResult != $result )
	{
		$result = $newResult;
		$newResult = `substitute "\\\\" $result "/"`;
	}
	
	$result = $newResult;
	$newResult = `substitute "//" $result "/"`;
	while( $newResult != $result )
	{
		$result = $newResult;
		$newResult = `substitute "//" $result "/"`;
	}
	
	if( `about -ntOS` )
	{
		if( startsWith( $newResult, "/" ) )
			$newResult = "/" + $newResult;
	}
	
	return $newResult;
}

// Returns true if the path is on the c:, d:, or e:.
global proc int IsLocalDrive( string $path )
{
	if( size( $path ) > 0 )
	{
		if( ( substring( $path, 1, 1) == "C" || substring( $path, 1, 1) == "c" ) ||
			( substring( $path, 1, 1) == "D" || substring( $path, 1, 1) == "d" ) ||
			( substring( $path, 1, 1) == "E" || substring( $path, 1, 1) == "e" ) )
		{
			return true;
		}
	}

	return false;
}

// Calls deadlinecommand and returns the output from the command.
global proc string CallDeadlineCommand( string $command, int $showProgress )
{
	string $tempDir = `internalVar -userTmpDir`;
	string $result = "";
	
	if( $showProgress )
		waitCursor -state on;
	
	print( "running deadline command: " + $command + "\n" );
	
	//sets the progress bar to 33%... since we can't really adjust the bar while it's loading
	if( $showProgress && `progressBar -exists frw_progBar` )
		progressBar -edit -progress (`progressBar -query -maxValue frw_progBar` / 3) frw_progBar;
	
	string $deadlineBin = "";
	string $deadlineCommandString = "";
	string $prevPath = "";
	if( `about -macOS` )
	{
		$deadlineCommandString = "deadlinecommand";
		
		string $deadlineBinPath = "/Users/Shared/Thinkbox/DEADLINE_PATH";
		if( `filetest -f $deadlineBinPath` )
		{
			int $fileId = fopen( $deadlineBinPath, "r" );
			$deadlineBin = fread( $fileId, $result );
			fclose( $fileId );
			
			$deadlineBin = strip( $deadlineBin );
			$deadlineCommandString = "\"" + $deadlineBin + "/deadlinecommand\"" + " 2> /dev/null";
		}
		
		$deadlineCommandString = $deadlineCommandString + " " + $command;
	}
	else if( `about -nt` )
	{
		$deadlineBin = `getenv "DEADLINE_PATH"`;
		$deadlineCommandString = "call \"" + $deadlineBin + "\\deadlinecommand.exe\" " + $command + " 2> nul";
		
		//Need to set the PATH, cuz windows 8 seems to load DLLs from the PATH earlier that cwd....
		$prevPath = `getenv "PATH"`;
		string $newPath = $deadlineBin + ";" + $prevPath;
		putenv "PATH" $newPath;
	}
	else
	{
		$deadlineBin = `getenv "DEADLINE_PATH"`;
		$deadlineCommandString = "\"" + $deadlineBin + "/deadlinecommand\" " + $command + " 2> /dev/null";
	}
	
	string $currDir = `pwd`;
	chdir $deadlineBin;
	$result = system( $deadlineCommandString );
	chdir $currDir;
	
	if( `about -nt` )
	{
		//restore the old PATH
		putenv "PATH" $prevPath;
	}
	
	$result = substituteAllString( $result, "\r", "" );
	
	//sets the progress bar to max (since we finished)
	if( $showProgress && `progressBar -exists frw_progBar` )
		progressBar -edit -progress `progressBar -query -maxValue frw_progBar` frw_progBar;
	
	string $resultArray[];
	$resultArray = stringToStringArray( $result, "\n" );
	//if( size($resultArray) > 2 && startsWith( $resultArray[2], "UNC paths are not supported." ) )
	if( size($resultArray) > 2 && ( startsWith( $resultArray[0], "'\\\\" ) || startsWith( $resultArray[0], "'//" ) ) )
	{
		int $tempResultArraySize = size($resultArray) - 3;
		string $tempResultArray[];
		for( $i = 0; $i < $tempResultArraySize; $i++ )
			$tempResultArray[$i] = $resultArray[$i+3];
		$result = stringArrayToString( $tempResultArray, "\n" );
	}
	
	if( endsWith( $result, "\n" ) )
		$result = substring( $result, 1, size( $result ) - 1 );
	
	if( $showProgress )
		waitCursor -state off;
	
	return $result;
}

// Quickly finds the intersection of two string arrays
global proc string[] IntersectTwoStringArray(string $firstArr[], string $secondArr[] )
{
	string $getSelection = `stringArrayIntersector`;
	stringArrayIntersector -edit -intersect $firstArr $getSelection;
	stringArrayIntersector -edit -intersect $secondArr $getSelection;

	string $intersect[] = (`stringArrayIntersector -query $getSelection`); // This is all of the selected *Geometry*
	deleteUI $getSelection;

	return $intersect;
}

//---------------------------------------------------------
// Functions for saving submission dialog options.
//---------------------------------------------------------

// Adds a string attribute.
global proc AddStringAttribute( string $attrName )
{
	if( ! `attributeExists $attrName defaultRenderGlobals` )
		addAttr -shortName $attrName -longName $attrName -dt "string" defaultRenderGlobals;
}

// Adds a long attribute.
global proc AddLongAttribute( string $attrName )
{
	if( ! `attributeExists $attrName defaultRenderGlobals` )
		addAttr -shortName $attrName -longName $attrName -at long defaultRenderGlobals;
}

// Adds a long attribute.
global proc AddFloatAttribute( string $attrName )
{
	if( ! `attributeExists $attrName defaultRenderGlobals` )
		addAttr -shortName $attrName -longName $attrName -at "float" defaultRenderGlobals;
}

//Adds a string array attribute
global proc AddStrArrayAttribute( string $attrName )
{
	if( !`attributeExists $attrName defaultRenderGlobals` )
		addAttr -shortName $attrName -longName $attrName -dt stringArray defaultRenderGlobals;
}

// Saves the persistent deadline options in the scene.
global proc SavePersistentDeadlineOptions()
{
	global string $ProjectPathGrp;
	global string $ImageOutputPathGrp;
	global string $StartupScriptPathGrp;
	global string $CompositeNamePathGrp;
	global string $MentalRayFilenameGrp;
	global string $VRayFilenameGrp;
	global string $LimitGroupGrp;
	global string $DependenciesGrp;
	global string $MachineListGrp;
	global string $JobNameGrp;
	global string $QuickDraftFormatFile[];
	global string $ShotgunResultsBox;
	global string $SGInfoKeys[];
	global string $SGInfoValues[];
	global string $FTInfoKeys[];
	global string $FTInfoValues[];
	
	//====================================================================================================
	// NIM

	global string $NimInfoKeys[];
	global string $NimInfoValues[];

	// END NIM
	//====================================================================================================

	global int $TileRegionRenderType;
	global int $JigsawRegionRenderType;
	
	global int $BlankImageCompType;
	global int $PreviousImageCompType;
	global int $SelectedImageCompType;

	global int $redshiftGPUsPerTask;
	global string $redshiftGPUsSelectDevices;
	
	global int $irayGPUsPerTask;
	global string $irayGPUsSelectDevices;
	global int $irayUseCPUs;
	global float $irayCPULoad;
	
	
	int $regionType = `optionMenuGrp -q -select frw_regionRenderType`;
	int $compType = `optionMenuGrp -q -select frw_compositeType`;
	
	string $renderer = GetCurrentRenderer();
	int $renderLayersEnabled = IsRenderLayersOn();

	AddStringAttribute( "deadlineJobName" );
	setAttr defaultRenderGlobals.deadlineJobName -type "string" `textFieldGrp -q -text frw_JobName`;
	
	AddStringAttribute( "deadlineJobComment" );
	setAttr defaultRenderGlobals.deadlineJobComment -type "string" `textFieldGrp -q -text frw_JobComment`;
	
	AddStringAttribute( "deadlineDepartment" );
	setAttr defaultRenderGlobals.deadlineDepartment -type "string" `textFieldGrp -q -text frw_Department`;

	AddStringAttribute( "deadlineGroup" );
	setAttr defaultRenderGlobals.deadlineGroup -type "string" `optionMenuGrp -q -value frw_Group`;
	
	AddStringAttribute( "deadlineJobPool" );
	setAttr defaultRenderGlobals.deadlineJobPool -type "string" `optionMenuGrp -q -value frw_deadlinePool`;
	
	AddStringAttribute( "deadlineJobSecondaryPool" );
	setAttr defaultRenderGlobals.deadlineJobSecondaryPool -type "string" `optionMenuGrp -q -value frw_deadlineSecondaryPool`;
	
	//AddLongAttribute( "deadlineUseOnlyPool" );
	//setAttr defaultRenderGlobals.deadlineUseOnlyPool `checkBox -q -v frw_poolMachinesOnly`;
	
	AddLongAttribute( "deadlineJobPriority" );
	setAttr defaultRenderGlobals.deadlineJobPriority `intSliderGrp -q -v frw_JobPriority`;
	
	AddLongAttribute( "deadlineLimitCount" );
	setAttr defaultRenderGlobals.deadlineLimitCount `intSliderGrp -q -v frw_LimitCount`;
	
	AddLongAttribute( "deadlineConcurrentTasks" );
	setAttr defaultRenderGlobals.deadlineConcurrentTasks `intSliderGrp -q -v frw_ConcurrentTasks`;
	
	AddLongAttribute( "deadlineSlaveTimeout" );
	setAttr defaultRenderGlobals.deadlineSlaveTimeout `intSliderGrp -q -v frw_SlaveTimeout`;
	
	AddLongAttribute( "deadlineMinSlaveTimeout" );
	setAttr defaultRenderGlobals.deadlineMinSlaveTimeout `intSliderGrp -q -v frw_MinSlaveTimeout`;
	
	AddStringAttribute( "deadlineLimitGroups" );
	setAttr defaultRenderGlobals.deadlineLimitGroups -type "string" `textFieldGrp -q -text frw_limitGroups`;
	
	AddStringAttribute( "deadlineMachineList" );
	setAttr defaultRenderGlobals.deadlineMachineList -type "string" `textFieldGrp -q -text frw_machineList`;
	
	AddLongAttribute( "deadlineIsBlacklist" );
	setAttr defaultRenderGlobals.deadlineIsBlacklist `checkBox -q -v frw_isBlacklist`;
	
	AddLongAttribute( "deadlineSubmitAsSuspended" );
	setAttr defaultRenderGlobals.deadlineSubmitAsSuspended `checkBox -q -v frw_submitAsSuspended`;
	
	AddLongAttribute( "deadlineCloseOnSubmission" );
	setAttr defaultRenderGlobals.deadlineCloseOnSubmission `checkBox -q -v frw_closeOnSubmission`;
	
	//AddLongAttribute( "deadlineDeleteOnComplete" );
	//setAttr defaultRenderGlobals.deadlineDeleteOnComplete `checkBox -q -v frw_deleteOnComplete`;
	
	AddLongAttribute( "deadlineChunkSize" );
	setAttr defaultRenderGlobals.deadlineChunkSize `intSliderGrp -q -v frw_FrameGroup`;
	
	//AddStringAttribute( "deadlineOutputFilePath" );
	//setAttr defaultRenderGlobals.deadlineOutputFilePath -type "string" `textFieldButtonGrp -q -fiame $ImageOutputPathGrp`;
	
	AddLongAttribute( "deadlineSubmitMayaScene" );
	setAttr defaultRenderGlobals.deadlineSubmitMayaScene `checkBox -q -v frw_submitMayaScene`;
	
	//AddStringAttribute( "deadlineProjectPathOverride" );
	//setAttr defaultRenderGlobals.deadlineProjectPathOverride -type "string" `textFieldButtonGrp -q -text $ProjectPathGrp`;
	
	AddLongAttribute( "deadlineNumCPUs" );
	if( EnableCpuOption( $renderer ) )
		setAttr defaultRenderGlobals.deadlineNumCPUs `intSliderGrp -q -v frw_MaxCPUs`;
	
	AddLongAttribute( "deadlineSubmitEachRenderLayer" );
	if( $renderLayersEnabled )
		setAttr defaultRenderGlobals.deadlineSubmitEachRenderLayer `checkBox -q -v frw_submitEachRenderLayer`;
	
	AddLongAttribute( "deadlineOverrideLayerSettings" );
	if( $renderLayersEnabled )
		setAttr defaultRenderGlobals.deadlineOverrideLayerSettings `checkBox -q -v frw_overrideLayerSettings`;
	
	AddLongAttribute( "deadlineSubmitEachCamera" );
	setAttr defaultRenderGlobals.deadlineSubmitEachCamera `checkBox -q -v frw_submitEachCamera`;
	
	AddLongAttribute( "deadlineIgnoreDefaultCameras" );
	setAttr defaultRenderGlobals.deadlineIgnoreDefaultCameras `checkBox -q -v frw_ignoreDefaultCameras`;
	
	AddLongAttribute( "deadlineUseMayaBatchPlugin" );
	setAttr defaultRenderGlobals.deadlineUseMayaBatchPlugin `checkBox -q -v frw_useMayaBatchPlugin`;
	
	AddLongAttribute( "deadlineStrictErrorChecking" );
	setAttr defaultRenderGlobals.deadlineStrictErrorChecking `checkBox -q -v frw_strictErrorChecking`;
	
	AddLongAttribute( "deadlineLocalRendering" );
	setAttr defaultRenderGlobals.deadlineLocalRendering `checkBox -q -v frw_localRendering`;
	
	AddStringAttribute( "deadlineStartupScript" );
	setAttr defaultRenderGlobals.deadlineStartupScript -type "string" `textFieldGrp -q -text frw_startupScript`;
	
	AddStringAttribute( "deadlineMayaArgs" );
	setAttr defaultRenderGlobals.deadlineMayaArgs -type "string" `textFieldGrp -q -text frw_mayaArgs`;
	
	AddLongAttribute( "deadlineTilesInX" );
	setAttr defaultRenderGlobals.deadlineTilesInX `intSliderGrp -q -v frw_tilesInX`;
	
	AddLongAttribute( "deadlineTilesInY" );
	setAttr defaultRenderGlobals.deadlineTilesInY `intSliderGrp -q -v frw_tilesInY`;
	
	AddLongAttribute( "deadlineTileSingleJob" );
	setAttr defaultRenderGlobals.deadlineTileSingleJob `checkBox -q -v frw_submitTileSingleJob`;
	
	AddLongAttribute( "deadlineTileDependentJob" );
	setAttr defaultRenderGlobals.deadlineTileDependentJob `checkBox -q -v frw_submitTileDependentJob`;
	
	AddLongAttribute( "deadlineTileCleanupJob" );
	setAttr defaultRenderGlobals.deadlineTileCleanupJob `checkBox -q -v frw_submitTileCleanupJob`;
	
	AddLongAttribute( "deadlineTileErrorOnMissing" );
	setAttr defaultRenderGlobals.deadlineTileErrorOnMissing `checkBox -q -v frw_submitTileErrorOnMissing`;
	
	AddLongAttribute( "tileMissingBackground" );
	setAttr defaultRenderGlobals.tileMissingBackground `checkBox -q -v frw_submitTileErrorOnMissingBackground`;
	
	AddStringAttribute( "deadlineMentalRayFilename" );
	setAttr defaultRenderGlobals.deadlineMentalRayFilename -type "string" `textFieldButtonGrp -q -text $MentalRayFilenameGrp`;
	
	AddLongAttribute( "deadlineSubmitMentalRayJob" );
	setAttr defaultRenderGlobals.deadlineSubmitMentalRayJob `checkBox -q -v frw_submitMentalRayJob`;
	
	AddLongAttribute( "deadlineMentalRayThreads" );
	setAttr defaultRenderGlobals.deadlineMentalRayThreads `intSliderGrp -q -v frw_mentalRayThreads`;
	
	AddLongAttribute( "deadlineMentalRayOffset" );
	setAttr defaultRenderGlobals.deadlineMentalRayOffset `intSliderGrp -q -v frw_mentalRayOffset`;
	
	AddLongAttribute( "deadlineMentalRayLocalRendering" );
	setAttr defaultRenderGlobals.deadlineMentalRayLocalRendering `checkBox -q -v frw_mentalRayLocalRendering`;
	
	AddStringAttribute( "deadlineMentalRayArgs" );
	setAttr defaultRenderGlobals.deadlineMentalRayArgs -type "string" `textFieldGrp -q -text frw_mentalRayArgs`;
	
	AddStringAttribute( "deadlineVRayFilename" );
	setAttr defaultRenderGlobals.deadlineVRayFilename -type "string" `textFieldButtonGrp -q -text $VRayFilenameGrp`;
	
	AddLongAttribute( "deadlineSubmitVRayJob" );
	setAttr defaultRenderGlobals.deadlineSubmitVRayJob `checkBox -q -v frw_submitVRayJob`;
	
	AddLongAttribute( "deadlineVRayThreads" );
	setAttr defaultRenderGlobals.deadlineVRayThreads `intSliderGrp -q -v frw_vrayThreads`;
	
	AddLongAttribute( "deadlineSubmitVrimg2ExrJob" );
	setAttr defaultRenderGlobals.deadlineSubmitVrimg2ExrJob `checkBox -q -v frw_submitVrimg2ExrJob`;
	
	AddLongAttribute( "deadlineDeleteVrimgFiles" );
	setAttr defaultRenderGlobals.deadlineDeleteVrimgFiles `checkBox -q -v frw_deleteVrimgFiles`;
	
	AddLongAttribute( "deadlineExportRenderManThreads" );
	setAttr defaultRenderGlobals.deadlineExportRenderManThreads `intSliderGrp -q -v frw_exportRenderManThreads`;
	
	AddLongAttribute( "deadlineRenderRenderManWithRis" );
	setAttr defaultRenderGlobals.deadlineExportRenderManThreads `checkBox -q -v frw_renderRenderManWithRis`;
	
	AddLongAttribute( "deadlineSubmitRenderManJob" );
	setAttr defaultRenderGlobals.deadlineSubmitRenderManJob `checkBox -q -v frw_submitRenderManJob`;

	AddLongAttribute( "deadlineRenderManFrameDependent" );
	setAttr defaultRenderGlobals.deadlineRenderManFrameDependent `checkBox -q -v frw_renderManFrameDependent`;
	
	AddLongAttribute( "deadlineRenderManThreads" );
	setAttr defaultRenderGlobals.deadlineRenderManThreads `intSliderGrp -q -v frw_rendermanThreads`;
	
	AddStringAttribute( "deadlineRenderManArgs" );
	setAttr defaultRenderGlobals.deadlineRenderManArgs -type "string" `textFieldGrp -q -text frw_rendermanArgs`;
	
	AddLongAttribute( "deadlineSubmitArnoldJob" );
	setAttr defaultRenderGlobals.deadlineSubmitArnoldJob `checkBox -q -v frw_submitArnoldJob`;
	
	AddLongAttribute( "deadlineExportArnoldLocal" );
	setAttr defaultRenderGlobals.deadlineExportArnoldLocal `checkBox -q -v frw_exportArnoldLocal`;
	
	AddLongAttribute( "deadlineArnoldThreads" );
	setAttr defaultRenderGlobals.deadlineArnoldThreads `intSliderGrp -q -v frw_arnoldThreads`;
	
	AddStringAttribute( "deadlineArnoldArgs" );
	setAttr defaultRenderGlobals.deadlineArnoldArgs -type "string" `textFieldGrp -q -text frw_arnoldArgs`;

	AddLongAttribute( "deadlineSubmitMaxwellJob" );
	setAttr defaultRenderGlobals.deadlineSubmitMaxwellJob `checkBox -q -v frw_submitMaxwellJob`;
	
	AddLongAttribute( "deadlineExportMaxwellLocal" );
	setAttr defaultRenderGlobals.deadlineExportMaxwellLocal `checkBox -q -v frw_exportMaxwellLocal`;

	AddLongAttribute( "deadlineMaxwellThreads" );
	setAttr defaultRenderGlobals.deadlineMaxwellThreads `intSliderGrp -q -v frw_maxwellThreads`;
	
	AddStringAttribute( "deadlineMaxwellArgs" );
	setAttr defaultRenderGlobals.deadlineMaxwellArgs -type "string" `textFieldGrp -q -text frw_maxwellArgs`;	

	AddStringAttribute( "deadlineDraftTemplate" );
	setAttr defaultRenderGlobals.deadlineDraftTemplate -type "string" `textFieldButtonGrp -q -text frw_DraftTemplate`;
	
	AddStringAttribute( "deadlineDraftUser" );
	setAttr defaultRenderGlobals.deadlineDraftUser -type "string" `textFieldGrp -q -text frw_DraftUser`;
	
	AddStringAttribute( "deadlineDraftEntity" );
	setAttr defaultRenderGlobals.deadlineDraftEntity -type "string" `textFieldGrp -q -text frw_DraftEntity`;
	
	AddStringAttribute( "deadlineDraftVersion" );
	setAttr defaultRenderGlobals.deadlineDraftVersion -type "string" `textFieldGrp -q -text frw_DraftVersion`;
	
	AddStringAttribute( "deadlineDraftExtraArgs" );
	setAttr defaultRenderGlobals.deadlineDraftExtraArgs -type "string" `textFieldGrp -q -text frw_DraftExtraArgs`;
	
	AddLongAttribute( "deadlineUseDraft" );
	setAttr defaultRenderGlobals.deadlineUseDraft `checkBox -q -v frw_submitDraftJob`;

	AddLongAttribute( "deadlineUploadDraftToShotgun" );
	setAttr defaultRenderGlobals.deadlineUploadDraftToShotgun `checkBox -q -v frw_uploadDraftToShotgun`;

	// AddStringAttribute( "deadlineSGDisplayInfo" );
	// setAttr defaultRenderGlobals.deadlineSGDisplayInfo -type "string" `scrollField -q -text frw_projMgmtDetails`;
	// AddStringAttribute( "deadlineSGVersionName" );
	// setAttr defaultRenderGlobals.deadlineSGVersionName -type "string" `textFieldGrp -q -text frw_projMgmtVersion`;
	// AddStringAttribute( "deadlineSGDescription" );
	// setAttr defaultRenderGlobals.deadlineSGDescription -type "string" `textFieldGrp -q -text frw_projMgmtDescription`;

	AddLongAttribute( "deadlineDraftQuick" );
	setAttr defaultRenderGlobals.deadlineDraftQuick (`radioButtonGrp -q -select frw_UseQuickDraftRadio` == 1);

	AddStringAttribute( "deadlineQuickDraftFormat" );
	string $quickDraftFormat = "";
	int $quickDraftFormatIndex = `optionMenuGrp -q -select frw_UseQuickDraftFormat`;
	if( $quickDraftFormatIndex > 0 )
	{
		$quickDraftFormat = $QuickDraftFormatFile[$quickDraftFormatIndex - 1];
	}
	setAttr defaultRenderGlobals.deadlineQuickDraftFormat -type "string" $quickDraftFormat;

	AddStringAttribute( "deadlineQuickDraftCodec" );
	setAttr defaultRenderGlobals.deadlineQuickDraftCodec -type "string" `optionMenuGrp -q -value frw_UseQuickDraftCodecs`;
	
	AddStringAttribute( "deadlineQuickDraftResolution" );
	setAttr defaultRenderGlobals.deadlineQuickDraftResolution -type "string" `optionMenuGrp -q -value frw_UseQuickDraftResolution`;

	AddStringAttribute( "deadlineQuickDraftFrameRate" );
	setAttr defaultRenderGlobals.deadlineQuickDraftFrameRate -type "string" `optionMenuGrp -q -value frw_UseQuickDraftFrameRate`;
	
	AddLongAttribute( "deadlineQuickDraftQuality" );
	setAttr defaultRenderGlobals.deadlineQuickDraftQuality `intSliderGrp -q -value frw_UseQuickDraftQuality`;
	
	AddStringAttribute( "deadlineProjectManagement" );
	setAttr defaultRenderGlobals.deadlineProjectManagement -type "string" `optionMenuGrp -q -value frw_projectManagement`;
	
	AddStrArrayAttribute( "deadlineSGInfoKeys" );
	//this is a bit weird, but I haven't found a better way to do this, since it doesn't seem like you can just pass in the array itself...
	eval( "setAttr defaultRenderGlobals.deadlineSGInfoKeys -type stringArray `size $SGInfoKeys` \"" + `stringArrayToString $SGInfoKeys "\" \""` + "\"" );
	//setAttr defaultRenderGlobals.deadlineSGInfoKeys -type stringArray `size $SGInfoKeys` $SGInfoKeys; <------ DOESN'T WORK >:(
	AddStrArrayAttribute( "deadlineSGInfoValues" );
	//same as above...
	eval( "setAttr defaultRenderGlobals.deadlineSGInfoValues -type stringArray `size $SGInfoValues` \"" + `stringArrayToString $SGInfoValues "\" \""` + "\"" );
	//setAttr defaultRenderGlobals.deadlineSGInfoValues -type stringArray `size $SGInfoValues` $SGInfoValues; <------ Still doesn't work :(

	//Do the same for FTrack stuff
	AddStrArrayAttribute( "deadlineFTInfoKeys" );
	eval( "setAttr defaultRenderGlobals.deadlineFTInfoKeys -type stringArray `size $FTInfoKeys` \"" + `stringArrayToString $FTInfoKeys "\" \""` + "\"" );
	AddStrArrayAttribute( "deadlineFTInfoValues" );
	eval( "setAttr defaultRenderGlobals.deadlineFTInfoValues -type stringArray `size $FTInfoValues` \"" + `stringArrayToString $FTInfoValues "\" \""` + "\"" );
	
	//====================================================================================================
	// NIM

	AddLongAttribute( "deadlineUploadDraftToNim" );
	setAttr defaultRenderGlobals.deadlineUploadDraftToNim `checkBox -q -v frw_uploadDraftToShotgun`;
	
	AddStrArrayAttribute( "deadlineNimInfoKeys" );
	eval( "setAttr defaultRenderGlobals.deadlineNimInfoKeys -type stringArray `size $NimInfoKeys` \"" + `stringArrayToString $NimInfoKeys "\" \""` + "\"" );
	AddStrArrayAttribute( "deadlineNimInfoValues" );
	eval( "setAttr defaultRenderGlobals.deadlineNimInfoValues -type stringArray `size $NimInfoValues` \"" + `stringArrayToString $NimInfoValues "\" \""` + "\"" );
	
	// END NIM
	//====================================================================================================

	// Enable or disable some options based on current values.
	int $useMayaBatchPlugin = `checkBox -q -v frw_useMayaBatchPlugin`;
	textFieldGrp -edit -enable $useMayaBatchPlugin frw_startupScript;
	textFieldGrp -edit -enable (!$useMayaBatchPlugin) frw_mayaArgs;
	checkBox -edit -enable (!$useMayaBatchPlugin) frw_ignoreError211;
	
	if( $renderer == "mentalRay" )
	{
		AddLongAttribute( "deadlineMentalRayAutoMemoryLimit" );
		setAttr defaultRenderGlobals.deadlineMentalRayAutoMemoryLimit `checkBox -q -v frw_autoMemoryLimit`;
		
		AddLongAttribute( "deadlineMentalRayMemoryLimit" );
		setAttr defaultRenderGlobals.deadlineMentalRayMemoryLimit `intSliderGrp -q -v frw_memoryLimit`;

		int $autoMemoryLimit = `checkBox -q -v frw_autoMemoryLimit`;
		intSliderGrp -edit -enable (!$autoMemoryLimit) frw_memoryLimit;
	}

	if( $renderer == "redshift" )
	{
		AddLongAttribute( "deadlineRedshiftGPUsPerTask" );
		setAttr defaultRenderGlobals.deadlineRedshiftGPUsPerTask `intSliderGrp -q -v frw_redshiftGPUsPerTask`;

		string $redshiftGPUsSelectDevices = `textFieldGrp -q -text frw_redshiftGPUsSelectDevices`;
		intSliderGrp -edit -enable (strcmp($redshiftGPUsSelectDevices, "") == 0) frw_redshiftGPUsPerTask;

		AddStringAttribute( "deadlineRedshiftGPUsSelectDevices" );
		setAttr defaultRenderGlobals.deadlineRedshiftGPUsSelectDevices -type "string" `textFieldGrp -q -text frw_redshiftGPUsSelectDevices`;

		int $redshiftGPUsPerTask = `intSliderGrp -q -v frw_redshiftGPUsPerTask`;
		textFieldGrp -edit -enable ($redshiftGPUsPerTask == 0) frw_redshiftGPUsSelectDevices;
	}
	
	if( $renderer == "vray" )
	{
		AddLongAttribute( "deadlineVrayAutoMemoryEnabled" );
		setAttr defaultRenderGlobals.deadlineVrayAutoMemoryEnabled `checkBox -q -v frw_vrayAutoMemoryEnabled`;
		
		AddLongAttribute( "deadlineVrayAutoMemoryBuffer" );
		setAttr defaultRenderGlobals.deadlineVrayAutoMemoryBuffer `intSliderGrp -q -v frw_vrayAutoMemoryBuffer`;
		
		checkBox -edit -enable $useMayaBatchPlugin frw_vrayAutoMemoryEnabled;
		
		int $vrayAutoMemoryEnabled = `checkBox -q -v frw_vrayAutoMemoryEnabled`;
		intSliderGrp -edit -enable ($useMayaBatchPlugin && $vrayAutoMemoryEnabled) frw_vrayAutoMemoryBuffer;
	}
	
	if( $renderer == "ifmIrayPhotoreal" )
	{
		AddLongAttribute( "deadlineIRayGPUsPerTask" );
		setAttr defaultRenderGlobals.deadlineIRayGPUsPerTask `intSliderGrp -q -v frw_irayGPUsPerTask`;

		string $irayGPUsSelectDevices = `textFieldGrp -q -text frw_irayGPUsSelectDevices`;
		intSliderGrp -edit -enable (strcmp($irayGPUsSelectDevices, "") == 0) frw_irayGPUsPerTask;

		AddStringAttribute( "deadlineIRayGPUsSelectDevices" );
		setAttr defaultRenderGlobals.deadlineIRayGPUsSelectDevices -type "string" `textFieldGrp -q -text frw_irayGPUsSelectDevices`;

		int $irayGPUsPerTask = `intSliderGrp -q -v frw_irayGPUsPerTask`;
		textFieldGrp -edit -enable ($irayGPUsPerTask == 0) frw_irayGPUsSelectDevices;
		
		
		AddLongAttribute( "deadlineIRayUseCPUs" );
		setAttr defaultRenderGlobals.deadlineIRayUseCPUs `checkBox -q -v frw_irayUseCPUs`;

		int $iraySelectUseCPUs = `checkBox -q -v frw_irayUseCPUs`;

		AddFloatAttribute( "deadlineIRayCPULoad" );
		setAttr defaultRenderGlobals.deadlineIRayCPULoad  `floatSliderGrp -q -v frw_irayCPULoad`;

		floatSliderGrp -edit -enable $iraySelectUseCPUs frw_irayCPULoad;
		
	}
	
	int $regionRendering = `checkBox -q -v frw_regionRendering`;
	int $animationEnabled = IsAnimatedOn();
	if( $renderLayersEnabled )
	{
		int $submitEachRenderLayer = `checkBox -q -v frw_submitEachRenderLayer`;
		checkBox -edit -enable $submitEachRenderLayer frw_regionRendering;
		checkBox -edit -enable $submitEachRenderLayer frw_overrideLayerSettings;
		
		int $layerOverride = `checkBox -q -v frw_overrideLayerSettings`;
		
		if( $submitEachRenderLayer )
			textFieldGrp -edit -enable ($animationEnabled && $layerOverride) frw_FrameList;
		else
			textFieldGrp -edit -enable $animationEnabled frw_FrameList;
		
		if( !$submitEachRenderLayer && $regionRendering )
		{
		   $regionRendering = false;
		   checkBox -edit -v $regionRendering frw_regionRendering;
		}
	}
	else
		textFieldGrp -edit -enable $animationEnabled frw_FrameList;
	
	int $submitEachCamera = `checkBox -q -v frw_submitEachCamera`;
	checkBox -edit -enable $submitEachCamera frw_ignoreDefaultCameras;
	rowLayout -edit -visible ($regionType == $JigsawRegionRenderType) frw_jigsawRenderLayout;
	columnLayout -edit -visible ($regionType == $TileRegionRenderType) frw_tileRenderLayout;
	button -edit -enable $regionRendering frw_openJigsaw;
	text -edit -enable $regionRendering frw_jigsawLabel;
	intSliderGrp -edit -enable $regionRendering frw_tilesInX;
	intSliderGrp -edit -enable $regionRendering frw_tilesInY;
	
	checkBox -edit -enable $regionRendering frw_submitTileSingleJob;
	
	int $singleRegionRendering = `checkBox -q -v frw_submitTileSingleJob`;
	int $assemblyRendering = `checkBox -q -v frw_submitTileDependentJob`;
	
	//checkBox -edit -enable frw_submitTileSingleJob;
	intSliderGrp -edit -enable ($regionRendering && ($singleRegionRendering)) frw_tileSingleFrame;
	checkBox -edit -enable ($regionRendering && ($singleRegionRendering || $regionType == $JigsawRegionRenderType)) frw_submitTileDependentJob;
	checkBox -edit -enable ($regionRendering && $assemblyRendering && ( $singleRegionRendering ||$regionType == $JigsawRegionRenderType )) frw_submitTileErrorOnMissing;
	checkBox -edit -enable ($regionRendering && ($singleRegionRendering || $regionType == $JigsawRegionRenderType) && $assemblyRendering) frw_submitTileCleanupJob;
	//optionMenuGrp -edit -enable ($regionRendering && ($singleRegionRendering || $regionType == $JigsawRegionRenderType) && $assemblyRendering) frw_compositeType;
	optionMenuGrp -edit -enable ($regionRendering && ( $singleRegionRendering ||$regionType == $JigsawRegionRenderType ) && $assemblyRendering) frw_compositeType;
	checkBox -edit -enable ($regionRendering && $compType != $BlankImageCompType && ( $singleRegionRendering ||$regionType == $JigsawRegionRenderType ) && $assemblyRendering) frw_submitTileErrorOnMissingBackground;
	textFieldButtonGrp -edit -enable ($regionRendering && $compType != $BlankImageCompType && ( $singleRegionRendering ||$regionType == $JigsawRegionRenderType ) && $assemblyRendering) frw_submitTileCompositeOverName;
	
	checkBox -edit -enable $animationEnabled frw_renderPreviewJobFirst;
	int $previewEnabled = `checkBox -q -v frw_renderPreviewJobFirst`;
	checkBox -edit -enable ($previewEnabled && $animationEnabled) frw_dependent;
	intSliderGrp -edit -enable ($previewEnabled && $animationEnabled) frw_PreviewFrames;
	intSliderGrp -edit -enable ($previewEnabled && $animationEnabled) frw_PreviewPriority;
	
	string $taskOrder = `optionMenuGrp -q -value frw_taskOrder`;
		
	int $outOfOrderStepEnabled = (strcmp($taskOrder, "Every Nth, Then Forward") == 0) || (strcmp($taskOrder, "Every Nth - Block Fill") == 0) || (strcmp($taskOrder,"Every Nth - Half Raster Refine") == 0);
	intSliderGrp -edit -enable $outOfOrderStepEnabled frw_taskOrderStep;
	
	int $submitVrayJob = `checkBox -q -v frw_submitVRayJob`;
	checkBox -edit -enable $submitVrayJob  frw_submitVrimg2ExrJob;
	checkBox -edit -enable $submitVrayJob  frw_deleteVrimgFiles;
	
}

global proc UpdateRegionRenderType()
{
	global int $JigsawRegionRenderType;
	global int $TileRegionRenderType;
	
	int $jobType = `optionMenuGrp -q -select frw_regionRenderType`;
	
	rowLayout -edit -enable ($jobType == $JigsawRegionRenderType) frw_jigsawRenderLayout;
	columnLayout -edit -enable ($jobType == $TileRegionRenderType) frw_tileRenderLayout;
	SavePersistentDeadlineOptions();
}

global proc UpdateCompositeType()
{
	global int $PreviousImageCompType;
	global int $SelectedImageCompType;
	
	int $compType = `optionMenuGrp -q -select frw_compositeType`;
	
	rowLayout -edit -enable ($compType == $SelectedImageCompType) frw_compLayout;
	SavePersistentDeadlineOptions();
}

global proc UpdateJobType()
{
	global string $MayaRenderOptionsRollout;
	global string $MayaRenderOptionsArnoldRollout;
	global string $MayaRenderOptionsMentalRayRollout;
	global string $MayaRenderOptionsRedshiftRollout;
	global string $MayaRenderOptionsIRayRollout;
	global string $MayaRenderOptionsVRayRollout;
	global string $MayaRenderOptionsTileRollout;
	global string $MentalRayExportRollout;
	global string $MentalRayExportRenderJobRollout;
	global string $VrayExportRollout;
	global string $VrayExportRenderJobRollout;
	global string $VrayExportVrimgJobRollout;
	global string $RendermanExportRollout;
	global string $RendermanExportRenderJobRollout;
	global string $ArnoldExportRollout;
	global string $ArnoldExportRenderJobRollout;
	global string $MaxwellExportRollout;
	global string $MaxwellExportRenderJobRollout;

	global string $BifrostSimulationJobRollout;
	global string $AlembicExportJobRollout;
	global string $AlembicAdvancedOptionsJobRollout;
	global string $MayaScriptJobRollout;
	global string $FluidCachingJobRollout;
	global string $GeometryCachingJobRollout;
	
	global int $MayaRenderJobType;
	global int $MentalRayExportJobType;
	global int $VRayExportJobType;
	global int $RendermanExportJobType;
	global int $ArnoldExportJobType;
	global int $MaxwellExportJobType;

	global int $BifrostSimulationJobType;
	global int $AlembicExportJobType;
	global int $MayaScriptJobType;
	global int $FluidCachingJobType;
	global int $GeometryCachingJobType;
	
	int $jobType = `optionMenuGrp -q -select frw_mayaJobType`;
	string $renderer = GetCurrentRenderer();
	
	frameLayout -edit -visible ($jobType == $MayaRenderJobType) $MayaRenderOptionsRollout;
	frameLayout -edit -visible ($jobType == $MayaRenderJobType && $renderer == "arnold") $MayaRenderOptionsArnoldRollout;
	frameLayout -edit -visible ($jobType == $MayaRenderJobType && $renderer == "mentalRay") $MayaRenderOptionsMentalRayRollout;
	frameLayout -edit -visible ($jobType == $MayaRenderJobType && $renderer == "redshift" ) $MayaRenderOptionsRedshiftRollout;
	frameLayout -edit -visible ($jobType == $MayaRenderJobType && $renderer == "vray") $MayaRenderOptionsVRayRollout;
	frameLayout -edit -visible ($jobType == $MayaRenderJobType && $renderer == "ifmIrayPhotoreal") $MayaRenderOptionsIRayRollout;
	frameLayout -edit -visible ($jobType == $MayaRenderJobType || $jobType == $ArnoldExportJobType ) $MayaRenderOptionsTileRollout;
	
	frameLayout -edit -visible ($jobType == $MentalRayExportJobType ) $MentalRayExportRollout;
	frameLayout -edit -visible ($jobType == $MentalRayExportJobType ) $MentalRayExportRenderJobRollout;
	
	frameLayout -edit -visible ($jobType == $VRayExportJobType ) $VrayExportRollout;
	frameLayout -edit -visible ($jobType == $VRayExportJobType ) $VrayExportRenderJobRollout;
	frameLayout -edit -visible ($jobType == $VRayExportJobType ) $VrayExportVrimgJobRollout;
	
	frameLayout -edit -visible ($jobType == $RendermanExportJobType ) $RendermanExportRollout;
	frameLayout -edit -visible ($jobType == $RendermanExportJobType ) $RendermanExportRenderJobRollout;
	
	frameLayout -edit -visible ($jobType == $ArnoldExportJobType ) $ArnoldExportRollout;
	frameLayout -edit -visible ($jobType == $ArnoldExportJobType ) $ArnoldExportRenderJobRollout;
	
	frameLayout -edit -visible ($jobType == $MaxwellExportJobType ) $MaxwellExportRollout;
	frameLayout -edit -visible ($jobType == $MaxwellExportJobType ) $MaxwellExportRenderJobRollout;

	frameLayout -edit -visible ($jobType == $BifrostSimulationJobType) $BifrostSimulationJobRollout;

	frameLayout -edit -visible ($jobType == $AlembicExportJobType) $AlembicExportJobRollout;
	frameLayout -edit -visible ($jobType == $AlembicExportJobType) $AlembicAdvancedOptionsJobRollout;

	frameLayout -edit -visible ($jobType == $MayaScriptJobType) $MayaScriptJobRollout;

	frameLayout -edit -visible ($jobType == $FluidCachingJobType) $FluidCachingJobRollout;

	frameLayout -edit -visible ($jobType == $GeometryCachingJobType) $GeometryCachingJobRollout;
}

//---------------------------------------------------------
// Functions for job submission.
//---------------------------------------------------------

proc int[] removeDuplicateIntegers(int $array[])
{
	int $index = 0;
	int $newarray[];
	for( $i = 0 ; $i < size($array) ; $i++ )
	{
		$entry = true;
		for( $j = 0 ; $j < $i ; $j++ )
		{
			if( $array[$i] == $array[$j] ) //duplicate
			{
				$entry = false;
			}
		}
		if( $entry == true )
		{
			$newarray[$index] = $array[$i];
			$index++;
		}
	}
	return $newarray;
}

proc int[] GetFramesArray(string $frameString)
{
	string $frameArray[];
	// Removing all whitespace from the framestring so that everything is in a predictable ordering.
	$frameString = substituteAllString($frameString, " ", "");
	
	//splitting the frame string into groups separated by commas
	int $numTokens = `tokenize $frameString "," $frameArray`;
	int $frames[] = {};
	for( $i = 0; $i<$numTokens; $i++ )
	{
		//Example  $FramesArray[$i] being "-6--4x2"
		//Pull the frame step from the grouping
		int $step = 1;
		string $stepArray[];
		tokenize $frameArray[$i] "x" $stepArray;
		//Example  $stepArray = { "-6--4", "2" }
		if( `size($stepArray)` > 1 )
		{   
			$step = int($stepArray[1]);
		}
		//Example  $step = 2
		
		//Split the remaining info on -'s this will allow us to handle ranges yet will remove any negatives so we have to handle those
		string $startStopArray[];
		tokenize $stepArray[0] "-" $startStopArray;
		//Example  $startStopArray = { "6", "4" }
		int $start = $startStopArray[0];
		//Example  $start = 6
		//if the first value is negative set it to negative
		if( startsWith( $stepArray[0], "-") )
		{
			$start = $start * -1;
		}
		//Example  $start = -6
		int $stop = $start;
		//Example  $stop = -6
		//If it is a range get the value and then test if it is negative
		if( `size($startStopArray)` > 1 )
		{
			$stop = $startStopArray[1];
			//Example  $stop = 4
			string $startPart = $start+"-";
			//Example  $startPart = "-6-"
			string $stopPart = substring( $stepArray[0], size( $startPart ) + 1, size( $stepArray[0] ) );
			//Example  $stopPart = "-4"
			if( startsWith( $stopPart, "-") )
			{
				$stop = $stop * -1;
			}
			//Example  $stop = -4
			
		}
		
		for($f = $start; $f<=$stop;$f+=$step)
		{
			$frames[size($frames)] = $f;
		}
	}
	
	return removeDuplicateIntegers($frames);	
}

proc int[] ApplyOutOfOrder(int $frames[])
{
	string $taskOrder = `optionMenuGrp -q -value frw_taskOrder`;
	int $taskStep = `intSliderGrp -q -v frw_taskOrderStep`;
	
	if( strcmp($taskOrder, "Every Nth, Then Forward") == 0 )
	{
		int $tempFramesBefore[] = {};
		int $tempFramesAfter[] = {};
		int $frameCount = size($frames);
		for ($i = 0; $i < $frameCount; $i++)
		{
			if($i % $taskStep == 0)
				$tempFramesBefore[size($tempFramesBefore)] = $frames[$i];
			else
				$tempFramesAfter[size($tempFramesAfter)] = $frames[$i];
		}
		
		for ($i = 0; $i < size($tempFramesAfter); $i++)
		{
			$tempFramesBefore[size($tempFramesBefore)] = $tempFramesAfter[$i];
		}
		
		$frames = $tempFramesBefore;
	}
	else if(strcmp($taskOrder, "Every Nth - Block Fill" ) == 0)
	{
		int $newFrames[] = {};
		int $frameCount = size($frames); 
		int $blockSize = $frameCount/$taskStep;

		for($i=0; $i < $blockSize; $i++)
		{
			for($j=0; $j < $taskStep; $j++)
			{
				int $index = ($j * $blockSize) + $i;
				$newFrames[size($newFrames)] = $frames[$index];
			}
		}
		
		if(size($frames) > size($newFrames))
		{
			// Check that no elements have been missed
			for($i=0; $i < size($frames); $i++)
			{
				int $found = 0;
				for($j = 0; $j < size($newFrames); $j++)
				{
					if($newFrames[$j] == $frames[$i])
						$found = 1;
					
				}
				if($found == 0)
					$newFrames[size($newFrames)] = $frames[$i];
			}
		}
		
		$frames = $newFrames;
	}
	else if(strcmp($taskOrder, "Every Nth - Half Raster Refine" ) == 0)
	{
		int $newFrames[] = {};
		int $frameCount = size($frames);
		int $step = $taskStep;
		
		while($step > 1)
		{
			for($i=0; $i < size($frames); $i+=$step)
			{
				int $found = 0;
				for($j = 0; $j < size($newFrames); $j++)
				{
					if($newFrames[$j] == $frames[$i])
					{
						$found = 1;
					}
				}
				
				if($found == 0)
				{
					$newFrames[size($newFrames)] = $frames[$i];
				}
				
			}
			$step = $step / 2;
		}
		if(size($frames) > size($newFrames))
		{
			// Check that no elements have been missed
			for($i=0; $i < size($frames); $i++)
			{
				int $found = 0;
				for($j = 0; $j < size($newFrames); $j++)
				{
					if($newFrames[$j] == $frames[$i])
						$found = 1;
					
				}
				if($found == 0)
					$newFrames[size($newFrames)] = $frames[$i];
			}
		}
		
		$frames = $newFrames;
	}
	else if(strcmp($taskOrder, "Last To First (Reverse)" ) == 0)
	{
		int $newFrames[] = {};
		for($i=(size($frames)-1); $i >= 0; $i--)
		{
			$newFrames[size($newFrames)] = $frames[$i];
		}
		
		$frames = $newFrames;
	}
	else if(strcmp($taskOrder, "First And Last Frames First" ) == 0)
	{
		int $newFrames[] = {};
		if(size($frames) > 1)
		{
			$newFrames[size($newFrames)] = $frames[0];
			$newFrames[size($newFrames)] = $frames[(size($frames) - 1)];
			
			for($i=1; $i < (size($frames) - 1); $i++)
			{
				$newFrames[size($newFrames)] = $frames[$i];
			}
			
			$frames = $newFrames;
		}
	}
	else if(strcmp($taskOrder, "From Both Ends" ) == 0)
	{
		int $newFrames[] = {};
		if(size($frames) > 1)
		{
			int $halfSize = size($frames) / 2;
			int $back = size($frames) - 1;
			
			for($front = 0; $front < $halfSize; $front++)
			{
				
				$newFrames[size($newFrames)] = $frames[$front];
				if(!($front >= $back))
					$newFrames[size($newFrames)] = $frames[$back];
				
				$back--;
			}
			
			if(size($frames) > size($newFrames))
			{
				// Check that no elements have been missed
				for($i=0; $i < size($frames); $i++)
				{
					int $found = 0;
					for($j = 0; $j < size($newFrames); $j++)
					{
						if($newFrames[$j] == $frames[$i])
							$found = 1;
						
					}
					if($found == 0)
						$newFrames[size($newFrames)] = $frames[$i];
				}
			}
			
			$frames = $newFrames;
		}
	}
	else if(strcmp($taskOrder, "From Center" ) == 0)
	{
		int $newFrames[] = {};
		if(size($frames) > 1)
		{
			int $halfSize = size($frames) / 2;
			int $back = $halfSize+1;
			while($back >= size($frames))
				$back -= 1;
			
			for($front = ($halfSize-1); $front >= 0 ; $front--)
			{
				
				$newFrames[size($newFrames)] = $frames[$front];
				if(!($front >= $back))
					$newFrames[size($newFrames)] = $frames[$back];
				
				$back++;
			}
			
			if(size($frames) > size($newFrames))
			{
				// Check that no elements have been missed
				for($i=0; $i < size($frames); $i++)
				{
					int $found = 0;
					for($j = 0; $j < size($newFrames); $j++)
					{
						if($newFrames[$j] == $frames[$i])
							$found = 1;
						
					}
					if($found == 0)
						$newFrames[size($newFrames)] = $frames[$i];
				}
			}
			
			$frames = $newFrames;
		}
	}
	else if(strcmp($taskOrder, "From Both Ends And From Center" ) == 0)
	{
		int $newFrames[] = {};
		if(size($frames) > 1)
		{
			int $theSize = size($frames);
			int $halfSize = $theSize / 2;
			
			int $front = 0;
			int $back = $theSize - 1;
			int $middleDec = $halfSize - 1;
			int $middleInc = $halfSize;
				
			while($front < $halfSize && $middleDec > $front && $back > $halfSize && $middleInc < $back)
			{
				$newFrames[size($newFrames)] = $frames[$front];
				$newFrames[size($newFrames)] = $frames[$back];
				$newFrames[size($newFrames)] = $frames[$middleDec];
				$newFrames[size($newFrames)] = $frames[$middleInc];
				
				$front++;
				$middleInc++;
				$middleDec--;
				$back--;
			}
			
			if(size($frames) > size($newFrames))
			{
				// Check that no elements have been missed
				for($i=0; $i < size($frames); $i++)
				{
					int $found = 0;
					for($j = 0; $j < size($newFrames); $j++)
					{
						if($newFrames[$j] == $frames[$i])
							$found = 1;
						
					}
					if($found == 0)
						$newFrames[size($newFrames)] = $frames[$i];
				}
			}
			
			$frames = $newFrames;
		}
	}
	else if(strcmp($taskOrder, "Random" ) == 0)
	{
		int $newFrames[] = {};
		int $usedIndices[] = {};
		int $theSize = size($frames);
		
		int $attempts = 0;
		
		for($i=0; $i < $theSize; $i++)
		{
			$usedIndices[size($usedIndices)] = 0;
		}
		
		while(size($newFrames) < size($frames) && $attempts < 30000)
		{
			int $randIndex = rand(0, $theSize);
			
			if($randIndex < $theSize)
			{
				if($usedIndices[$randIndex] == 0)
				{
					$usedIndices[$randIndex] = 1;
					$newFrames[size($newFrames)] = $frames[$randIndex];
				}
			}
			
			$attempts++;
			
		}
		
		print("Attempts = "+$attempts+"\n");
		if($attempts < 30000)
			$frames = $newFrames;
		
	}
	
	return $frames;
}

proc string FromArrayToCommaSeparatedString(int $array[])
{
	string $result = "";
	
	for($i = 0; $i < (size($array) - 1); $i++)
	{
		$result = $result + $array[$i] +",";
	}
	$result = $result + $array[size($array)-1];
	
	return $result;
}

// Creates the submission files and submits the job to Deadline.
proc string WriteJobFilesAndSubmit( string $renderer, int $showDialog, int $regionRendering, int $jobType, string $cameraOverride )
{
	global string $DeadlineSubmitterWindow;
	global string $StartupScriptPathGrp;
	global int $MayaRenderJobType;
	global int $MentalRayExportJobType;
	global int $VRayExportJobType;
	global int $RendermanExportJobType;
	global int $ArnoldExportJobType;
	global int $MaxwellExportJobType;

	global int $BifrostSimulationJobType;
	global int $AlembicExportJobType;
	global int $MayaScriptJobType;
	global int $FluidCachingJobType;
	global int $GeometryCachingJobType;
	
	global int $TileRegionRenderType;
	global int $JigsawRegionRenderType;
	
	global string $QuickDraftFormats[];
	global string $QuickDraftFormatFile[];
	global string $QuickDraftFormatMovie[];
	global string $QuickDraftResolutionsDisplay[];
	global string $QuickDraftResolutions[];
	
	int $regionType = `optionMenuGrp -q -select frw_regionRenderType`;
	
	// Get the deadline temp directory.
	string $tempDir = CallDeadlineCommand( "-GetCurrentUserHomeDirectory", false ) + "/temp";
	
	string $priorityQuery = CallDeadlineCommand( "-getmaximumpriority", false );
	int $maximumPriority = (int) $priorityQuery;
	if( $maximumPriority == 0 )
		$maximumPriority = 100;
	
	// Get the output file path and prefix.
	string $outputFilePath = CheckSlashes( `textFieldGrp -q -text frw_outputFilePath` );
	
	string $mentalRayFilename = CheckSlashes( `textFieldGrp -q -text frw_mentalRayFilePath` );
	string $vrayFilename = CheckSlashes( `textFieldGrp -q -text frw_vrayFilePath` );
	
	// Get some initial settings.
	string $jobName = `textFieldGrp -q -text frw_JobName`;
	string $frameList = `textFieldGrp -q -text frw_FrameList`;
	
	$overrideLayerSettings = `checkBox -q -value frw_overrideLayerSettings`;
	
	// Append the render layer name to the job name if the submit each render layer check is on.
	string $currentRenderLayer = "";
	int $submitEachRenderLayer = false;
	if( IsRenderLayersOn() )
	{
		$submitEachRenderLayer = `checkBox -q -value frw_submitEachRenderLayer`;
		
		if( $jobType == $MayaRenderJobType && $submitEachRenderLayer )
		{
			$currentRenderLayer = `editRenderLayerGlobals -query -currentRenderLayer`;
			
			if($overrideLayerSettings)
			{
				$jobField = "frw_JobName_" + $currentRenderLayer;
				$jobName = `textFieldGrp -q -text $jobField`;
			}
			else
				$jobName += " - " + $currentRenderLayer;
			
			int $range[] = GetFrameRange();
			int $fromFrame = $range[0];
			int $toFrame = $range[1];
			int $byFrame = $range[2];
			
			$frameList = $fromFrame + "-" + $toFrame;
			if( $byFrame > 1 )
				$frameList = $frameList + "x" + $byFrame;
		}
	}
	
	// Get region rendering settings.
	string $regionLeft = 0;
	string $regionTop = 0; 
	string $regionRight = 0; 
	string $regionBottom = 0;
	int $currX = 0;
	int $currY = 0;
	int $currTile = 0;
	
	int $tilesInX = `intSliderGrp -q -v frw_tilesInX`;
	int $tilesInY = `intSliderGrp -q -v frw_tilesInY`;
	
	int $singleRegionJob = `checkBox -q -v frw_submitTileSingleJob`;
	int $singleRegionFrame = `intSliderGrp -q -v frw_tileSingleFrame`;
	int $singleRegionTiles = 0;
	string $singleRegionLeft = "";
	string $singleRegionTop = "";
	string $singleRegionRight = "";
	string $singleRegionBottom = "";
	
	// Append tile information to job name if doing a region render.
	if( $jobType == $MayaRenderJobType && $regionRendering )
	{
		if( !$singleRegionJob )
		{
			if( `attributeExists deadlineRegionLeft defaultRenderGlobals` ) $regionLeft = `getAttr defaultRenderGlobals.deadlineRegionLeft`;
			if( `attributeExists deadlineRegionTop defaultRenderGlobals` ) $regionTop = `getAttr defaultRenderGlobals.deadlineRegionTop`;
			if( `attributeExists deadlineRegionRight defaultRenderGlobals` ) $regionRight = `getAttr defaultRenderGlobals.deadlineRegionRight`;
			if( `attributeExists deadlineRegionBottom defaultRenderGlobals` ) $regionBottom = `getAttr defaultRenderGlobals.deadlineRegionBottom`;
			if( `attributeExists deadlineCurrTile defaultRenderGlobals` ) $currTile = `getAttr defaultRenderGlobals.deadlineCurrTile`;
			if( `attributeExists deadlineCurrX defaultRenderGlobals` ) $currX = `getAttr defaultRenderGlobals.deadlineCurrX`;
			if( `attributeExists deadlineCurrY defaultRenderGlobals` ) $currY = `getAttr defaultRenderGlobals.deadlineCurrY`;
			
			if($regionType == $TileRegionRenderType)
				$jobName += " (Tile " + $currTile + " : " + $currX + "x" + $currY + " of " + $tilesInX + "x" + $tilesInY + ")";
			else
				$jobName += " (Region " + $currTile + ")";
		}
		else
		{
			if( `attributeExists deadlineRegionSingleTiles defaultRenderGlobals` ) $singleRegionTiles = `getAttr defaultRenderGlobals.deadlineRegionSingleTiles`;
			if( `attributeExists deadlineRegionSingleLeft defaultRenderGlobals` ) $singleRegionLeft = `getAttr defaultRenderGlobals.deadlineRegionSingleLeft`;
			if( `attributeExists deadlineRegionSingleTop defaultRenderGlobals` ) $singleRegionTop = `getAttr defaultRenderGlobals.deadlineRegionSingleTop`;
			if( `attributeExists deadlineRegionSingleRight defaultRenderGlobals` ) $singleRegionRight = `getAttr defaultRenderGlobals.deadlineRegionSingleRight`;
			if( `attributeExists deadlineRegionSingleBottom defaultRenderGlobals` ) $singleRegionBottom = `getAttr defaultRenderGlobals.deadlineRegionSingleBottom`;
			
			$jobName += " (Frame " + $singleRegionFrame + " - " + $singleRegionTiles + " Tiles)";
		}
	}
	
	// Figure out the camera to use (if specified).
	string $camera = "";
	if( $cameraOverride != "" )
		$camera = $cameraOverride;
	else
	{
		string $selectedCamera = `optionMenuGrp -q -value frw_camera`;
		string $cameraNames[] = `listTransforms -cameras`;
		for( $cameraName in $cameraNames )
		{
			if( $cameraName == $selectedCamera )
			{
				$camera = $selectedCamera;
				break;
			}
		}
	}
	
	//Check if we need to create a preview job and submit that first
	
	int $previewEnabled = `checkBox -q -value frw_renderPreviewJobFirst`;
	int $previewPriority = `intSliderGrp -q -v frw_PreviewPriority`;
	int $previewFrames = `intSliderGrp -q -v frw_PreviewFrames`;
	int $previewDependent = `checkBox -q -value frw_dependent`;
	int $frameOffset = `intSliderGrp -q -v frw_frameNumberOffset`;
	int $frameRange[] = GetFramesArray($frameList);
	int $numFrames = 0;
	int $gap = 0;
	int $previewFrameRange[];
	int $newFrameRange[];
	string $submitResults = "";
	
	if( $regionRendering )
	{
		if (!($regionRendering && $submitEachRenderLayer && !$singleRegionJob))
			$previewEnabled = 0;
	}
	
	if ($previewEnabled == 1)
	{
		//We need to make a preview job. The preview job needs to be a dependency of the rest of frames if that is enabled
		
		//Some checks to make things are cool
		$numFrames = size($frameRange);
		if ($numFrames > $previewFrames)
		{
			$gap = $numFrames/$previewFrames;
			
			//Build the new frame lists
			for( $i = 0; $i < $numFrames; $i++ )
			{
				if( $i % $previewFrames == 0)
				{
					$previewFrameRange[size($previewFrameRange)]=$frameRange[$i];
				}
				else
				{
					$newFrameRange[size($newFrameRange)]=$frameRange[$i];
				}
			}
			$frameRange=$newFrameRange;
		}
		else
		{
			print("Preview frame is larger or equal to the number of frames in the Job, does not make any sense to create a preview Job.");
			$previewEnabled = 0;
		}
	}
	$frameRange = ApplyOutOfOrder($frameRange);
	$previewFrameRange = ApplyOutOfOrder($previewFrameRange);
	for($jobNumber = 0; $jobNumber <= $previewEnabled; $jobNumber++)
	{
	
		string $namePostFix = "";
		//Check if the Job Name needs a special postfix
		if($previewEnabled == 1)
		{
			if($jobNumber == 0)
				$namePostFix = " [PREVIEW FRAMES]";
			else
				$namePostFix = " [REST OF FRAMES]";
		}
		
		string $jobDependencies = `textFieldGrp -q -text frw_dependencies`;
		//If this is the rest of frames job, check if we need to add the previous job as a dependency
		if($previewEnabled == 1 && $previewDependent == 1 && $jobNumber == 1)
		{
		
			string $jobId = "";
			string $resultArray[];
			$resultArray = stringToStringArray( $submitResults, "\n" );
			for( $n = 0; $n < size($resultArray); $n++ )
			{
				if( startsWith( $resultArray[$n], "JobID=" ) )
				{
					$jobId = substituteAllString( $resultArray[$n], "JobID=", "" );
					break;
				}
			}
		
			if( size($jobDependencies) == 0)
				$jobDependencies = $jobId+"";
			else
				$jobDependencies = $jobDependencies+","+$jobId;
		}
		
		//Calculate the Priority
		int $jobPriority = `intSliderGrp -q -v frw_JobPriority`;
		
		if ($previewEnabled == 1 && $jobNumber == 0)
		{
			$jobPriority = $jobPriority + $previewPriority;
			
			if($maximumPriority < $jobPriority)
				$jobPriority = $maximumPriority;
			
		}
		
		int $hasREs = 0;
		string $REs[] = {};
		string $removableREs[] = {};
		int $isMultichannelExr = false;
		string $multichannel = " (multichannel)";
		string $ext = "";
		
		string $elements[] = {""};
		
		if( $renderer == "vray" )
		{
			$elements = getVRayElementNames();
		}
		else if ( $renderer == "arnold" ) 
		{
			$elements = getArnoldElementNames();
		}
		else if ( $renderer == "maxwell" ) 
		{
			$elements = getMaxwellElementNames();
		}
		else if ( $renderer == "redshift" )
		{
			$elements = getRedshiftElements();
		}
		
		// Create the job info file.
		string $submitFilename = CheckSlashes( $tempDir + "/maya_deadline_info.job" );
		$fileId = `fopen $submitFilename "w"`;
		if( $fileId == 0 )
			print( "Error in Deadline Submission Script: could not create " + $submitFilename + "\n" );
		
		int $useMayaBatchPlugin = `checkBox -q -v frw_useMayaBatchPlugin`;
		if( $useMayaBatchPlugin )
			fprint $fileId ( "Plugin=MayaBatch\n" );
		else
			fprint $fileId ( "Plugin=MayaCmd\n" );
		
		if( $camera != "" )
			$jobName = $jobName + " - " + $camera;

		// Add job name suffix for special Maya jobs.
		if( $jobType == $BifrostSimulationJobType )
		{
			$jobName += " [Bifrost Job]";
		}
		else if( $jobType == $AlembicExportJobType )
		{
			$jobName += " [Alembic Export Job]";
		}
		else if( $jobType == $MayaScriptJobType )
		{
			$jobName += " [Script Job]";
		}
		else if( $jobType == $FluidCachingJobType )
		{
			$jobName += " [Fluid Caching Job]";
		}
		else if( $jobType == $GeometryCachingJobType )
		{
			$jobName += " [Geometry Caching Job]";
		}
		
		fprint $fileId ( "Name=" + $jobName + $namePostFix + "\n" );
		int $submitEachCamera = `checkBox -q -v frw_submitEachCamera`;
		if($submitEachRenderLayer || $submitEachCamera)
			fprint $fileId ( "BatchName=" + `textFieldGrp -q -text frw_JobName` + "\n" );
		fprint $fileId ( "Comment=" + `textFieldGrp -q -text frw_JobComment` + "\n" );
		fprint $fileId ( "Pool=" + `optionMenuGrp -q -value frw_deadlinePool` + "\n" );
		fprint $fileId ( "SecondaryPool=" + `optionMenuGrp -q -value frw_deadlineSecondaryPool` + "\n" );
		fprint $fileId ( "MachineLimit=" + `intSliderGrp -q -v frw_LimitCount` + "\n" );
		fprint $fileId ( "Priority=" + $jobPriority + "\n" );
		fprint $fileId ( "OnJobComplete=" + `optionMenuGrp -q -value frw_onComplete` + "\n" );
		fprint $fileId ( "TaskTimeoutMinutes=" + `intSliderGrp -q -v frw_SlaveTimeout` + "\n" );
		fprint $fileId ( "MinRenderTimeMinutes=" + `intSliderGrp -q -v frw_MinSlaveTimeout` + "\n" );
		fprint $fileId ( "ConcurrentTasks=" + `intSliderGrp -q -v frw_ConcurrentTasks` + "\n" );
		fprint $fileId ( "Department=" + `textFieldGrp -q -text frw_Department` + "\n" );
		fprint $fileId ( "Group=" + `optionMenuGrp -q -value frw_Group` + "\n" );
		fprint $fileId ( "LimitGroups=" + `textFieldGrp -q -text frw_limitGroups` + "\n" );
		fprint $fileId ( "JobDependencies=" + $jobDependencies + "\n" );
		
		if( `checkBox -q -value frw_isBlacklist` )
			fprint $fileId ( "Blacklist=" + `textFieldGrp -q -text frw_machineList` + "\n" );
		else
			fprint $fileId ( "Whitelist=" + `textFieldGrp -q -text frw_machineList` + "\n" );
		
		if( `checkBox -q -value frw_submitAsSuspended` )
			fprint $fileId ( "InitialStatus=Suspended\n" );
		
		if( $jobType == $MayaRenderJobType )
		{
			int $counter = 0;
			
			// Store the currently selected render layer
			string $currentRenderLayer = `editRenderLayerGlobals -query -currentRenderLayer`;
			string $renderLayerList[] = {""};
			if( IsRenderLayersOn() )
			{
				if( $submitEachRenderLayer )
				{
					$renderLayerList = {$currentRenderLayer};
				}
				else
				{
					
					$renderLayerList = getRenderableRenderLayers(false);
				}
			}
			
			// Loop through the render layer if the checkbox is on
			for( $i = 0; $i < size( $renderLayerList ); $i++ )
			{
				int $isRenderable = 0;
				if( $renderLayerList[$i] == "")
				{
					$isRenderable = 1;
				}
				else
				{
					if( !catch(`editRenderLayerGlobals -currentRenderLayer $renderLayerList[$i]`) )
					{
						$isRenderable = 1;
					}
				}
				
				if( $isRenderable )
				{
					if( $renderer == "mentalRay" )
					{
						$elements = getMentalRayElementNames( $renderLayerList[$i] );
					}
					
					string $tempOutputFilePath = $outputFilePath;
					
					string $renderableCameras[] = {};
					if( $camera != "" )
					{
						stringArrayInsertAtIndex(0, $renderableCameras, $camera );
					}
					else
					{
						$renderableCameras  = deadlineGetRenderableCameras( false );
					}
					
					if( size($renderableCameras) == 0 )
					{
						stringArrayInsertAtIndex(0, $renderableCameras, "" );
					}
					//Redshift has it's own functions that get the output filenames
					//There are separate functions for the main pass and for AOV's
					//If multiple AOV's have the same output filename then they are merged into one file
					//As such we only want to include the files once.
					if ( $renderer == "redshift" )
					{
						string $usedOutputPaths[];
						
						//The options node might not have been created yet and if it has not been created then redshiftGetAovImageName will throw an error
						redshiftGetRedshiftOptionsNode( 1 );
						
						string $paddingString = "#";
						if( `getAttr "defaultRenderGlobals.animation"` )
						{
							int $paddingSize = `getAttr "defaultRenderGlobals.extensionPadding"`;
							while( size($paddingString) < $paddingSize )
								$paddingString = "#" + $paddingString;
						}
							
						for ($element in $elements)
						{
							string $outputFilename = "";
							if( $element == "" )
							{
								$outputFilename = redshiftGetImageFormatString( 0, $renderableCameras[0] );
							}
							else
							{
								$outputFilename = redshiftGetAovImageName( $element, 0, $renderableCameras[0] );
							}
							
							if( `getAttr "defaultRenderGlobals.animation"` )
							{
								$outputFilename = `substitute "#+" $outputFilename $paddingString `;
							}
							
							if( !stringArrayContains($outputFilename,$usedOutputPaths)  )
							{
								fprint $fileId ( "OutputFilename" + $counter + "=" + $outputFilename + "\n" );
								$counter += 1;
								stringArrayInsertAtIndex(0, $usedOutputPaths, $outputFilename);
							}
						}
						
					}
					else
					{
						for( $cameraName in $renderableCameras )
						{
							
							for($element in $elements)
							{
								string $outputPrefix = "";
								$outputPrefix = CheckSlashes( GetOutputPrefix( 0, 0, $renderLayerList[$i], $cameraName, $element ) );
								$outputPrefix = swapDeepExr( $outputPrefix );
								
								if( $jobType == $MayaRenderJobType && $regionRendering )
								{
									if( !$singleRegionJob )
									{
										if($regionType ==$TileRegionRenderType)
											$outputPrefix = GetTileOutputPrefix( $outputPrefix, $currX, $currY, $tilesInX, $tilesInY, $renderer );
										else
											$outputPrefix = GetJigsawOutputPrefix( $outputPrefix, $currTile, $renderer );
											
										fprint $fileId ( "OutputFilename" + $counter + "=" + CheckSlashes( $tempOutputFilePath + "/" + $outputPrefix ) + "\n" );
									}
									else
									{
										$outputPrefix = GetOutputPrefix( 1, $singleRegionFrame, $renderLayerList[$i], $cameraName, $element );
										$outputPrefix = swapDeepExr( $outputPrefix );
										
										if($regionType == $TileRegionRenderType)
										{
											int $tileNum = 0;
											for( $y = 1; $y <= $tilesInY; $y++ )
											{
												for( $x = 1; $x <= $tilesInX; $x++ )
												{
													string $tempFilePrefix = GetTileOutputPrefix( $outputPrefix, $x, $y, $tilesInX, $tilesInY, $renderer );
													fprint $fileId ( "OutputFilename" + $counter + "Tile"+$tileNum+"=" + CheckSlashes( $tempOutputFilePath + "/" + $tempFilePrefix ) + "\n" );
													$tileNum++;
												}
											}
										}
										else
										{
											for( $tileNum = 0; $tileNum < $singleRegionTiles; $tileNum++ )
											{
												
												string $tempFilePrefix = GetJigsawOutputPrefix( $outputPrefix, $tileNum, $renderer );
												fprint $fileId ( "OutputFilename" + $counter + "Tile"+$tileNum+"=" + CheckSlashes( $tempOutputFilePath + "/" + $tempFilePrefix ) + "\n" );
											}
										}
									}
								}
								else
								{
									fprint $fileId ( "OutputFilename" + $counter + "=" + CheckSlashes( $tempOutputFilePath + "/" + $outputPrefix ) + "\n" );
								}
								$counter += 1;
							}
						}
					}
				}
			}
			// Reselect the current render layer
			editRenderLayerGlobals -currentRenderLayer $currentRenderLayer;
			
		}
		else if( $jobType == $MentalRayExportJobType )
		{
			fprint $fileId ( "OutputDirectory0=" + dirname( $mentalRayFilename ) + "\n" );
		}
		else if( $jobType == $VRayExportJobType )
		{
			fprint $fileId ( "OutputDirectory0=" + dirname( $vrayFilename ) + "\n" );
		}
		else if( $jobType == $RendermanExportJobType )
		{
			fprint $fileId ( "OutputDirectory0=" + CheckSlashes( `textFieldGrp -q -text frw_projectPath` + "/renderman/" + GetStrippedSceneFileName() ) + "\n" );
		}
		else if( $jobType == $ArnoldExportJobType || $jobType == $MaxwellExportJobType )
		{
			string $assExportFolder = `workspace -fre "ASS"`;
			if( $assExportFolder == "" )
				$assExportFolder = "data";
			
			fprint $fileId ( "OutputDirectory0=" + CheckSlashes( `textFieldGrp -q -text frw_projectPath` + "/" + $assExportFolder ) + "\n" );
		}
		
		$frameList = FromArrayToCommaSeparatedString($frameRange);
		if($jobNumber == 0 && $previewEnabled == 1)
			$frameList = FromArrayToCommaSeparatedString($previewFrameRange);

		if( $jobType == $MayaRenderJobType && $regionRendering && $singleRegionJob )
		{
			//fprint $fileId ( "Frames=0-" + ($singleRegionTiles-1) + "\n" );
			//fprint $fileId ( "ChunkSize=1\n" );
			fprint $fileId ( "TileJob=True\n" );
			fprint $fileId ( "TileJobFrame=" + $singleRegionFrame + "\n" );
			
			if( $regionType == $TileRegionRenderType)
			{
				fprint $fileId ( "TileJobTilesInX=" + $tilesInX + "\n" );
				fprint $fileId ( "TileJobTilesInY=" + $tilesInY + "\n" );
			}
			else
			{
				fprint $fileId ( "TileJobTilesInX=" + $singleRegionTiles + "\n" );
				fprint $fileId ( "TileJobTilesInY=1\n" );
			}
				
		}
		else
		{	   
			//TODO, what do I do with this nonsense when submitting a preview job
			if( $jobType == $MayaRenderJobType && $submitEachRenderLayer )
			{
				if($overrideLayerSettings)
				{
					$currentRenderLayer = `editRenderLayerGlobals -query -currentRenderLayer`;
					
					$field = "frw_FrameList_" + $currentRenderLayer;
					fprint $fileId ( "Frames=" + `textFieldGrp -q -text $field` + "\n" );
					
					$field = "frw_FrameGroup_" + $currentRenderLayer;
					fprint $fileId ( "ChunkSize=" + `intSliderGrp -q -v $field` + "\n" );
				}
				else
				{
					fprint $fileId ( "Frames=" + $frameList + "\n" );
					fprint $fileId ( "ChunkSize=" + `intSliderGrp -q -v frw_FrameGroup` + "\n" );
				}
			}
			else
			{
				if( ( $jobType == $ArnoldExportJobType && $regionRendering && $singleRegionJob ) )
					fprint $fileId ( "Frames=" + $singleRegionFrame + "\n" );
				else
					fprint $fileId ( "Frames=" + $frameList + "\n" );
				
				// Regular renders and Arnold exports can be split across machines, but other exports (AFAIK) must be done on a single machine.
				if( $jobType == $MayaRenderJobType || $jobType == $ArnoldExportJobType || $jobType == $MaxwellExportJobType || $jobType == $RendermanExportJobType )
					fprint $fileId ( "ChunkSize=" + `intSliderGrp -q -v frw_FrameGroup` + "\n" );
				else
					fprint $fileId ( "ChunkSize=100000\n" );
			}
		}
		
		if( $jobType == $MayaRenderJobType && $regionRendering && $useMayaBatchPlugin && $renderer == "vray" )
			fprint $fileId ( "ForceReloadPlugin=True\n" );
		
		$kvpIndex = 0;
		$groupBatch = false;
		int $submitDependentRegionJob = `checkBox -q -v frw_submitTileDependentJob`;
		if( $regionRendering && $submitDependentRegionJob)
			$groupBatch = true;
		int $submitDependentVRrayJob = `checkBox -q -v frw_submitVRayJob`;
		if($jobType == $VRayExportJobType && $submitDependentVRrayJob)
			$groupBatch = true;
		int $submitDependentArnold = `checkBox -q -v frw_submitArnoldJob`;
		if($jobType == $ArnoldExportJobType && $submitDependentArnold)
			$groupBatch = true;
		int $submitDependentMaxwell = `checkBox -q -v frw_submitMaxwellJob`;
		if( $jobType == $MaxwellExportJobType && $submitDependentMaxwell )
			$groupBatch = true;
		int $submitDepRenderMan = `checkBox -q -v frw_submitRenderManJob`;
		if($jobType == $RendermanExportJobType && $submitDepRenderMan)
			$groupBatch = true;
		int $submitDepMentalRay = `checkBox -q -v frw_submitMentalRayJob`;
		if($jobType == $MentalRayExportJobType && $submitDepMentalRay)
			$groupBatch = true;	
		
		//============================================
		//  SHOTGUN / FTRACK / NIM
		if( `checkBox -q -v frw_projMgmtCreateVersion` )
		{
			$selectedIntegration = `optionMenuGrp -q -value frw_projectManagement`;

			if($selectedIntegration == "Shotgun")
			{
				global string $SGInfoKeys[];
				global string $SGInfoValues[];
				
				for( $i = 0; $i < size( $SGInfoKeys ); $i++ )
				{
					if ( $SGInfoKeys[ $i ] == "TaskName" )
						fprint $fileId ( "ExtraInfo0=" +  $SGInfoValues[ $i ] + "\n" );
					else if ( $SGInfoKeys[ $i ] == "ProjectName" )
						fprint $fileId ( "ExtraInfo1=" +  $SGInfoValues[ $i ] + "\n" );
					else if ( $SGInfoKeys[ $i ] == "EntityName" )
						fprint $fileId ( "ExtraInfo2=" +  $SGInfoValues[ $i ] + "\n" );
					else if ( $SGInfoKeys[ $i ] == "UserName" )
						fprint $fileId ( "ExtraInfo5=" +  $SGInfoValues[ $i ] + "\n" );
					else if ( $SGInfoKeys[ $i ] != "DraftTemplate" ) //DON'T put in the Draft template -- if we're doing Draft, let Draft put that stuff in
					{	
						fprint $fileId ( "ExtraInfoKeyValue" + $kvpIndex + "=" + $SGInfoKeys[ $i ] + "=" + $SGInfoValues[ $i ] + "\n" );
						$kvpIndex++;
					}
				}

				if( `checkBox -q -value frw_projMgmtCreateMovie` && `checkBox -q -enable frw_projMgmtCreateMovie` )
				{
					fprint $fileId ("ExtraInfoKeyValue" + $kvpIndex + "=Draft_CreateSGMovie=True\n");
					$kvpIndex++;

					$groupBatch = true;
				}

				if( `checkBox -q -value frw_projMgmtCreateFilmstrip` && `checkBox -q -enable frw_projMgmtCreateFilmstrip` )
				{
					fprint $fileId ("ExtraInfoKeyValue" + $kvpIndex + "=Draft_CreateSGFilmstrip=True\n");
					$kvpIndex++;

					$groupBatch = true;
				}
				
				fprint $fileId ( "ExtraInfo3=" + `textFieldGrp -q -text frw_projMgmtVersion` + "\n" );
				fprint $fileId ( "ExtraInfo4=" + `textFieldGrp -q -text frw_projMgmtDescription` + "\n" );
			}
			else if ( $selectedIntegration == "FTrack" )
			{
				global string $FTInfoKeys[];
				global string $FTInfoValues[];

				for( $i = 0; $i < size( $FTInfoKeys ); $i++ )
				{
					if ( $FTInfoKeys[ $i ] == "FT_TaskName" )
						fprint $fileId ( "ExtraInfo0=" +  $FTInfoValues[ $i ] + "\n" );
					else if ( $FTInfoKeys[ $i ] == "FT_ProjectName" )
						fprint $fileId ( "ExtraInfo1=" +  $FTInfoValues[ $i ] + "\n" );
					else if ( $FTInfoKeys[ $i ] == "FT_AssetName" )
						fprint $fileId ( "ExtraInfo2=" +  $FTInfoValues[ $i ] + "\n" );
					else if ( $FTInfoKeys[ $i ] == "FT_Username" )
						fprint $fileId ( "ExtraInfo5=" +  $FTInfoValues[ $i ] + "\n" );
					
					fprint $fileId ( "ExtraInfoKeyValue" + $kvpIndex + "=" + $FTInfoKeys[ $i ] + "=" + $FTInfoValues[ $i ] + "\n" );
					$kvpIndex++;
				}
				
				if( `checkBox -q -value frw_projMgmtCreateMovie` && `checkBox -q -enable frw_projMgmtCreateMovie` )
				{
					fprint $fileId ("ExtraInfoKeyValue" + $kvpIndex + "=Draft_CreateFTMovie=True\n");
					$kvpIndex++;

					$groupBatch = true;
				}
				
				fprint $fileId ( "ExtraInfo4=" + `textFieldGrp -q -text frw_projMgmtDescription` + "\n" );
			}
			else if ( $selectedIntegration == "NIM" )
			{
				global string $NimInfoKeys[];
				global string $NimInfoValues[];

				for( $i = 0; $i < size( $NimInfoKeys ); $i++ )
				{
					if ( $NimInfoKeys[ $i ] == "nim_renderName" )
						fprint $fileId ( "ExtraInfo0=" +  $NimInfoValues[ $i ] + "\n" );
					else if ( $NimInfoKeys[ $i ] == "nim_jobName" )
						fprint $fileId ( "ExtraInfo1=" +  $NimInfoValues[ $i ] + "\n" );
					else if ( $NimInfoKeys[ $i ] == "nim_showName" )
						fprint $fileId ( "ExtraInfo2=" +  $NimInfoValues[ $i ] + "\n" );
					else if ( $NimInfoKeys[ $i ] == "nim_shotName" )
						fprint $fileId ( "ExtraInfo3=" +  $NimInfoValues[ $i ] + "\n" );
					else if ( $NimInfoKeys[ $i ] == "nim_user" )
						fprint $fileId ( "ExtraInfo5=" +  $NimInfoValues[ $i ] + "\n" );
					
					fprint $fileId ( "ExtraInfoKeyValue" + $kvpIndex + "=" + $NimInfoKeys[ $i ] + "=" + $NimInfoValues[ $i ] + "\n" );
					$kvpIndex++;
				}
				
				if( `checkBox -q -value frw_projMgmtCreateMovie` && `checkBox -q -enable frw_projMgmtCreateMovie` )
				{
					fprint $fileId ("ExtraInfoKeyValue" + $kvpIndex + "=Draft_CreateNimMovie=True\n");
					$kvpIndex++;

					$groupBatch = true;
				}
				
				fprint $fileId ( "ExtraInfo4=" + `textFieldGrp -q -text frw_projMgmtDescription` + "\n" );
				
			}
		}
		//============================================
		
		if( `checkBox -q -v frw_submitDraftJob` )
		{	
			if( `radioButtonGrp -q -select frw_UseQuickDraftRadio` == 1 )
			{
				fprint $fileId ("ExtraInfoKeyValue" + $kvpIndex + "=SubmitQuickDraft=True\n");
				$kvpIndex++;
				
				string $currentFormat = `optionMenuGrp -q -value frw_UseQuickDraftFormat`;
				int $index = stringArrayFind( $currentFormat, 0, $QuickDraftFormats );
				if( $index >= 0)
				{
					$currentFormat = $QuickDraftFormatFile[ $index ];
				}
				else
				{
					print( "Error in Deadline Submission Script: could not find Quick Draft format \"" + $currentFormat + "\"\n" );
					$currentFormat = "";
				}

				fprint $fileId ("ExtraInfoKeyValue" + $kvpIndex + "=DraftExtension=" + $currentFormat + "\n");
				$kvpIndex++;

				string $currentType = "";
				if( $index >= 0 )
				{
					$currentType = $QuickDraftFormatMovie[$index];
				}
				fprint $fileId ("ExtraInfoKeyValue" + $kvpIndex + "=DraftType=" + $currentType + "\n");
				$kvpIndex++;

				string $currentResolutionLabel = `optionMenuGrp -q -value frw_UseQuickDraftResolution`;
				$index = stringArrayFind( $currentResolutionLabel, 0, $QuickDraftResolutionsDisplay );
				string $currentResolution;
				if( $index >= 0 )
				{
					$currentResolution = $QuickDraftResolutions[$index];
				}
				else
				{
					print( "Error in Deadline Submission Script: could not find Quick Draft resolution \"" + $currentResolutionLabel + "\"\n" );
					$currentResolution = "";
				}
				fprint $fileId ("ExtraInfoKeyValue" + $kvpIndex + "=DraftResolution=" + $currentResolution + "\n");
				$kvpIndex++;
				string $currentCodec = `optionMenuGrp -q -value frw_UseQuickDraftCodecs`;
				fprint $fileId ("ExtraInfoKeyValue" + $kvpIndex + "=DraftCodec=" + $currentCodec + "\n");
				$kvpIndex++;
				int $currentQuality = `intSliderGrp -q -value frw_UseQuickDraftQuality`;
				fprint $fileId ("ExtraInfoKeyValue" + $kvpIndex + "=DraftQuality=" + $currentQuality + "\n");
				$kvpIndex++;
				string $currentFramerate = `optionMenuGrp -q -value frw_UseQuickDraftFrameRate`;
				fprint $fileId ("ExtraInfoKeyValue" + $kvpIndex + "=DraftFrameRate=" + $currentFramerate + "\n");
				$kvpIndex++;
			}
			else
			{
				fprint $fileId ("ExtraInfoKeyValue" + $kvpIndex + "=DraftTemplate=" + `textFieldButtonGrp -q -text frw_DraftTemplate` + "\n");
				$kvpIndex++;
				fprint $fileId ("ExtraInfoKeyValue" + $kvpIndex + "=DraftUsername=" + `textFieldGrp -q -text frw_DraftUser` + "\n");
				$kvpIndex++;
				fprint $fileId ("ExtraInfoKeyValue" + $kvpIndex + "=DraftEntity=" + `textFieldGrp -q -text frw_DraftEntity` + "\n");
				$kvpIndex++;
				fprint $fileId ("ExtraInfoKeyValue" + $kvpIndex + "=DraftVersion=" + `textFieldGrp -q -text frw_DraftVersion` + "\n");
				$kvpIndex++;
				
				int $res[] = GetGlobalsResolution();
				fprint $fileId ("ExtraInfoKeyValue" + $kvpIndex + "=DraftFrameWidth=" + $res[0] + "\n");
				$kvpIndex++;
				fprint $fileId ("ExtraInfoKeyValue" + $kvpIndex + "=DraftFrameHeight=" + $res[1] + "\n");
				$kvpIndex++;
				
				fprint $fileId ("ExtraInfoKeyValue" + $kvpIndex + "=DraftExtraArgs=" + `textFieldGrp -q -text frw_DraftExtraArgs` + "\n");
				$kvpIndex++;
			}			
			
			string $selectedIntegration = `optionMenuGrp -q -value frw_projectManagement`;
			string $uploadKey = "DraftUploadToShotgun";
			if( $selectedIntegration == "FTrack" )
				$uploadKey = "FT_DraftUploadMovie";
			else if( $selectedIntegration == "NIM" )
				$uploadKey = "DraftUploadToNim";
			
			if( `checkBox -q -value frw_uploadDraftToShotgun` && `checkBox -q -enable frw_uploadDraftToShotgun` )
				fprint $fileId ("ExtraInfoKeyValue" + $kvpIndex + "=" + $uploadKey + "=True\n");
			else
				fprint $fileId ("ExtraInfoKeyValue" + $kvpIndex + "=" + $uploadKey + "=False\n");
			
			$kvpIndex++;
			$groupBatch = true;
		}

		if ( $groupBatch )
		{
			string $batchName = `textFieldGrp -q -text frw_JobName`;
			//This will group the jobs created later in the same batch
			fprint $fileId ( "BatchName=" + $batchName + "\n" );
		}
		
		fclose $fileId;
		
		// Create the plugin info file.
		string $jobFilename = CheckSlashes( $tempDir + "/maya_deadline_job.job" );
		$fileId = `fopen $jobFilename "w"`;
		if( $fileId == 0 )
			print( "Error in Deadline Submission Script: could not create " + $jobFilename + "\n" );
		
		// If animation is enabled.
		fprint $fileId ( "Animation=" + IsAnimatedOn() + "\n" );
		
		if( $jobType == $MentalRayExportJobType )
		{
			fprint $fileId ( "Renderer=mentalRayExport\n" );
			fprint $fileId ( "UsingRenderLayers=false\n" );
			
			global string $gExportFilterCheckBoxes[];
			global string $gExportPathesCheckBoxes[];
			
			fprint $fileId ( "MentalRayExportfile=" + $mentalRayFilename + "\n" );
			fprint $fileId ( "MentalRayExportBinary=" + ((`radioButton -query -select MayatomrExport_Binary`) ? 1 : 0) + "\n" );
			fprint $fileId ( "MentalRayExportTabStop=" + ($tabstop = `intField -query -value MayatomrExport_TabSize`) + "\n" );
			
			int $perframe = 0;
			int $padframe = 0;
			if(`checkBoxGrp -query -value1 MayatomrExport_FilePerFrame`)
			{
				$perframe = `optionMenuGrp -q -select MayatomrExport_FrameExtension`;
				$padframe = `intFieldGrp -q -value1 MayatomrExport_FramePadding`;
				if ($padframe > 9)
					$padframe = 9;
			}
			
			fprint $fileId ( "MentalRayExportPerFrame=" + $perframe + "\n" );
			fprint $fileId ( "MentalRayExportPadFrame=" + $padframe + "\n" );
			fprint $fileId ( "MentalRayExportPerLayer=" + `checkBoxGrp -query -value1 MayatomrExport_FilePerLayer` + "\n" );
			
			$pathnames = "";
			if(`checkBoxGrp -query -value1 MayatomrExport_Pathes`)
			{
				for( $cnt=0; $cnt < size( $gExportPathesCheckBoxes ); $cnt++ )
					$pathnames += `optionMenuGrp -query -sl $gExportPathesCheckBoxes[$cnt]`;
			}
			else
				$pathnames = "n";
			
			fprint $fileId ( "MentalRayExportPathNames=" + $pathnames + "\n" );
			
			$fragment = (`optionMenuGrp -q -select MayatomrExport_Fragment`-1);
			fprint $fileId ( "MentalRayExportFragment=" + $fragment + "\n" );
			fprint $fileId ( "MentalRayExportFragmentMaterials=" + ((`checkBoxGrp -q -v1 MayatomrExport_FragmentMaterials`) ? 1 : 0) + "\n" );
			fprint $fileId ( "MentalRayExportFragmentShaders=" + ((`checkBoxGrp -q -v1 MayatomrExport_FragmentIncomingShdrs`) ? 1 : 0) + "\n" );
			fprint $fileId ( "MentalRayExportFragmentChildDag=" + ((`checkBoxGrp -q -v1 MayatomrExport_FragmentChildDag`) ? 1 : 0) + "\n" );
			fprint $fileId ( "MentalRayExportPassContributionMaps=" + ((`checkBoxGrp -q -v1 MayatomrExport_PassContributionMaps`) ? 1 : 0) + "\n" );
			fprint $fileId ( "MentalRayExportPassUserData=" + ((`checkBoxGrp -q -v1 MayatomrExport_PassUserData`) ? 1 : 0) + "\n" );
			
			$filter = "";
			if(`checkBoxGrp -query -value1 MayatomrExport_Filters`)
			{
				for($cnt=0; $cnt<size($gExportFilterCheckBoxes); $cnt++)
					$filter += (`checkBoxGrp -query -value1 $gExportFilterCheckBoxes[$cnt]`) ? "0" : "1";
			}
			
			fprint $fileId ( "MentalRayExportFilterString=" + $filter + "\n" );
		}
		else if( $jobType == $VRayExportJobType )
		{
			fprint $fileId ( "Renderer=vrayExport\n" );
			fprint $fileId ( "VRayExportFile=" + $vrayFilename + "\n" );
		}
		else if( $jobType == $RendermanExportJobType )
		{
			fprint $fileId ( "Renderer=rendermanExport\n" );
			fprint $fileId ( "MaxProcessors=" + `intSliderGrp -q -v frw_exportRenderManThreads` + "\n" );
			fprint $fileId ( "RenderWithRis=" + `checkBox -q -v frw_renderRenderManWithRis` + "\n" );
		}
		else if( $jobType == $ArnoldExportJobType )
		{
			fprint $fileId ( "Renderer=arnoldExport\n" );
		}
		else if( $jobType == $MaxwellExportJobType )
		{
			fprint $fileId ( "Renderer=maxwellExport\n" );
			
			string $outputScript = `textFieldButtonGrp -q -text frw_maxwellScriptName`;
			if($cameraOverride != "")
			{
				string $base = basenameEx( $outputScript );
				string $folder = substituteAllString($outputScript,basename($outputScript,""),"");
				string $ext = fileExtension( $outputScript );
				
				$outputScript = $folder+$base+"_"+$cameraOverride+"."+$ext;
			}
			
			fprint $fileId ( "MaxwellMXSFile=" + $outputScript + "\n" );
		}
		else if( $jobType == $BifrostSimulationJobType )
		{

			fprint $fileId ( "BifrostJob=True\n" );

			string $cacheOutDir = CheckSlashes( `textFieldGrp -q -text frw_bifrostCacheDir` );
			fprint $fileId( "OutputFilePath=" + $cacheOutDir + "\n" );

			if(IntMayaVersion() > 2015)
			{
				string $formatIndex = (string)((`optionMenuGrp -q -select frw_biFrostCompressionFormat`)-1); // Change index from 1-3 to 0-2
				fprint $fileId( "BifrostCompressionFormat=" + $formatIndex + "\n" );
			}
		}
		else if( $jobType == $AlembicExportJobType )
		{
			string $alembicAttrs[] = { "frw_verboseCheck", "frw_noNormalsCheck", "frw_renderableOnlyCheck",
									   "frw_stripNamespacesCheck", "frw_uvWriteCheck", "frw_writeColorSetsCheck", 
									   "frw_writeFaceSetsCheck", "frw_wholeFrameGeoCheck", "frw_worldSpaceCheck", 
									    "frw_writeVisibilityCheck", "frw_filterEulerRotationsCheck", "frw_writeCreasesCheck" };

			string $alembicOutFile = CheckSlashes(`textFieldGrp -q -text frw_alembicExportFile` );

			fprint $fileId ( "AlembicJob=True\n" );
			fprint $fileId( "OutputFile=" + basename( $alembicOutFile, "" ) + "\n" );
			
			for($i = 0; $i<size($alembicAttrs); $i++)
			{
				if(`checkBox -q -v $alembicAttrs[$i]`)
				{
					string $checkedItem = substituteAllString(`checkBox -q -label $alembicAttrs[$i]`, " ", "" );
					fprint $fileId( $checkedItem + "=True\n" );
				}
			}
			// if index == 1, use HDF, else use Ogawa
			if( `optionMenuGrp -q -sl frw_alembicFormat` == 1 )
			{
				fprint $fileId( "AlembicFormatOption=HDF\n" );
			}
			else
			{
				fprint $fileId( "AlembicFormatOption=Ogawa\n" );	
			}

			fprint $fileId( "OutputFilePath="+ CheckSlashes( dirname( $alembicOutFile ) ) + "\n" );

			// AlembicExportSelection
			string $alembicSelection = "All";
			string $items[] = `ls -sl`;

			if( `radioButtonGrp -q -select frw_AlembicExportSelection` == 2 && size( stringArrayRemove( $items, `ls` ) ) )
			{
				$alembicSelection = "";
				for($item in $items)
				{
					$alembicSelection += ( $item + "," );
				}
				$alembicSelection = `substring $alembicSelection 1 (size($alembicSelection)-1)`; // Chop off the last comma
			}
			fprint $fileId( "AlembicSelection=" + $alembicSelection + "\n" );
		}
		else if( $jobType == $MayaScriptJobType )
		{
			fprint $fileId ( "ScriptJob=True\n" );

			string $fullfile = `textFieldGrp -q -text frw_mayaScriptJob`;
			string $result = basename( $fullfile, "" );
			fprint $fileId ( "ScriptFilename=" + $result +"\n");
		}
		// Fluid and Geometry caching is very similar. This would be easy to form into generalized nCaching (along with nCaching, nParticles, nCloth, nHair) in the future
		else if( $jobType == $FluidCachingJobType )
		{
			// This will be handled in a similar fashion to Geometry caching
			string $fluidCacheOutDir = `textFieldButtonGrp -q -text frw_FluidCacheOutputDir`;
			string $fileDists[] = { "True", "False" };

			fprint $fileId ( "FluidCacheJob=True\n" );

			fprint $fileId ( "FluidCacheFileName=" + `textFieldGrp -q -text frw_FluidCacheFileName` + "\n" );
			fprint $fileId ( "OutputFilePath=" + $fluidCacheOutDir  + "\n" );
			fprint $fileId ( "CacheFormat=" + `optionMenuGrp -q -value frw_FluidCacheFormat` + "\n" );
			fprint $fileId ( "OneFilePerFluid=" + `checkBox -q -value frw_FluidCacheSplitCheck` + "\n" );
			fprint $fileId ( "OneFilePerFrame=" + $fileDists[int(`radioButtonGrp -q -select frw_FluidCacheFileDistRadio`)-1] + "\n" );

			string $selection = "All";
			string $fluids[] = `listTransforms "-type fluidShape"`;
			string $sels[] = `ls -sl`;

			string $selectedFluids[] = IntersectTwoStringArray($fluids, $sels);

			if( size( stringArrayRemove( $selectedFluids, $fluids ) ) ) // There is a difference between the selected fluids and all fluids in the scene. Therefore we have not selected everything
			{
				$selection = "";
				for($item in $selectedFluids)
				{
					$selection += $item + ",";
				}
				$selection = `substring $selection 1 (size($selection)-1)`; // Chop off the last comma
			}

			fprint $fileId ( "SelectedFluids=" + $selection + "\n" );

		}
		else if( $jobType == $GeometryCachingJobType )
		{
			string $GeometricCacheOutDir = `textFieldGrp -q -text frw_GeometricCacheOutputDir`;
			string $fileDists[] = { "True", "False" };
			string $dblOrFlt[] = { "Double", "Float" };
			string $storePts[] = { "Local", "World" };

			fprint $fileId ( "GeometryCacheJob=True\n" );
			fprint $fileId ( "OutputFilePath=" + $GeometricCacheOutDir  + "\n" );					
			fprint $fileId ( "OneFilePerFrame=" + $fileDists[int(`radioButtonGrp -q -select frw_GeometricCacheFileDistRadio`)-1] + "\n" );
			fprint $fileId ( "SavePointsAs=" + $dblOrFlt[int(`radioButtonGrp -q -select frw_GeometricCacheDblOrFltRadio`)-1] + "\n" );
			fprint $fileId ( "SavePointsIn=" + $storePts[int(`radioButtonGrp -q -select frw_GeometricCacheLocOrWldRadio`)-1] + "\n" );
			fprint $fileId ( "OneFilePerGeometry=" + `checkBox -q -value frw_GeometricCacheSplitCheck` + "\n" );
			fprint $fileId ( "CacheFormat=" + `optionMenuGrp -q -value frw_GeoCacheFormat` + "\n" );
			fprint $fileId ( "GeoCacheFileName=" + `textFieldGrp -q -text frw_GeoCacheFileName` + "\n" );

			string $selection = "All"; // default is all Geometry selected
			string $geos[] = `listTransforms -geometry`;
			string $sels[] = `ls -sl`;

			string $selectedGeos[] = IntersectTwoStringArray($geos, $sels); // This is all of the selected Geometry
			
			if( size( stringArrayRemove( $selectedGeos, $geos ) ) ) // There is a difference between the selected Geometry and all the Geometry. Therefore we have not selected everything
			{
				// reassign the string and set up the actual selection
				$selection = "";
				for($item in $selectedGeos)
				{
					$selection += $item + ",";
				}
				$selection = `substring $selection 1 (size($selection)-1)`; // Chop off the last comma
			}
			
			fprint $fileId ( "SelectedGeometry=" + $selection + "\n" );
		}
		else
		{
			fprint $fileId ( "Renderer=" + $renderer + "\n" );
			fprint $fileId ( "UsingRenderLayers=" + IsRenderLayersOn() + "\n" );
			fprint $fileId ( "RenderLayer=" + $currentRenderLayer + "\n" );
			
			int $renderHalfFrames = ShowHalfFramesOption( $renderer ) ? `checkBox -q -value frw_renderHalfFrames` : 0;
			fprint $fileId ( "RenderHalfFrames=" + $renderHalfFrames + "\n" );
			
			fprint $fileId ( "FrameNumberOffset=" + $frameOffset + "\n" );
			
			int $localRendering = `checkBox -q -value frw_localRendering`;
			fprint $fileId ( "LocalRendering=" + $localRendering + "\n" );
			
			int $strictErrorChecking = `checkBox -q -value frw_strictErrorChecking`;
			fprint $fileId ( "StrictErrorChecking=" + $strictErrorChecking + "\n" );
			
			if( $regionRendering )
			{
				fprint $fileId ( "RegionRendering=True\n" );
				if( !$singleRegionJob )
				{
					fprint $fileId ( "RegionLeft=" + $regionLeft + "\n" );
					fprint $fileId ( "RegionTop=" + $regionTop + "\n" );
					fprint $fileId ( "RegionRight=" + $regionRight + "\n" );
					fprint $fileId ( "RegionBottom=" + $regionBottom + "\n" );
				}
				else
				{
					
					//fprint $fileId ( "RegionSingleJob=True\n" );
					//fprint $fileId ( "RegionSingleFrame=" + $singleRegionFrame + "\n" );
					fprint $fileId ( $singleRegionLeft + "\n" );
					fprint $fileId ( $singleRegionTop + "\n" );
					fprint $fileId ( $singleRegionRight + "\n" );
					fprint $fileId ( $singleRegionBottom + "\n" );
					
					if($regionType == $JigsawRegionRenderType)
					{
						for( $tileNum = 0; $tileNum < $singleRegionTiles; $tileNum++ )
						{
							string $outputFilePrefix = GetMayaOutputPrefix( $camera, $currentRenderLayer );
							$outputFilePrefix = GetJigsawOutputPrefix($outputFilePrefix, $tileNum, $renderer);
							
							fprint $fileId ("RegionPrefix" + $tileNum + "=" + $outputFilePrefix + "\n");
							
						}
					}
					else
					{
						int $tileNum = 0;
						for( $y = 1; $y <= $tilesInY; $y++ )
						{
							for( $x = 1; $x <= $tilesInX; $x++ )
							{
								string $outputFilePrefix = GetMayaOutputPrefix( $camera, $currentRenderLayer );
								$outputFilePrefix = GetTileOutputPrefix( $outputFilePrefix, $x, $y, $tilesInX, $tilesInY, $renderer );
								
								// Renderman strips the leading '_' from output file names, so we need to add an additional one.
								//if( $renderer == "renderMan" || $renderer == "renderManRIS" )
								//	$outputFilePrefix = "_" + $outputFilePrefix;
								
								fprint $fileId ("RegionPrefix" + $tileNum + "=" + $outputFilePrefix + "\n");
								$tileNum++;
							}
						}
					}
				}
			}
			
			if( EnableCpuOption( $renderer ) )
				fprint $fileId ( "MaxProcessors=" + `intSliderGrp -q -v frw_MaxCPUs` + "\n" );
			
			if( $renderer == "mayaSoftware" )
			{
				// render globals qualification
				string $rendQual[] = `listConnections defaultRenderGlobals.qual`;
				
				// get antialising quality level and turn it into a string
				string $strAntialiasing = "highest";
				int $intAntialiasing = `getAttr ($rendQual[0] + ".edgeAntiAliasing")`;
				if ( $intAntialiasing == 1 ) $strAntialiasing = "high";
				if ( $intAntialiasing == 2 ) $strAntialiasing = "medium";
				if ( $intAntialiasing == 3 ) $strAntialiasing = "low";
				
				fprint $fileId ( "AntiAliasing=" + $strAntialiasing + "\n" );
			}
			
			// Krakatoa options currently only supported by the MayaBatch plugin.
			if( $useMayaBatchPlugin && $renderer == "MayaKrakatoa")
			{
				string $boolVal = "";
				float $krakatoaFinalPassDensity = `getAttr "MayaKrakatoaRenderSettings.finalPassDensity"`;
				fprint $fileId ( "KrakatoaFinalPassDensity="+ $krakatoaFinalPassDensity + "\n" );
				
				int $krakatoaFinalPassDensityExponent = `getAttr "MayaKrakatoaRenderSettings.finalPassDensityExponent"`;
				fprint $fileId ( "KrakatoaFinalPassDensityExponent=" + $krakatoaFinalPassDensityExponent + "\n" );
				
				int $krakatoaUseLightingPassDensity = `getAttr "MayaKrakatoaRenderSettings.useLightingPassDensity"`;
				
				
				if($krakatoaUseLightingPassDensity == 1) { $boolVal = "True"; }
				else { $boolVal = "False"; }
				fprint $fileId ( "KrakatoaUseLightingPassDensity=" + $boolVal+ "\n" );
				
				float $krakatoaLightingDensity = `getAttr "MayaKrakatoaRenderSettings.lightingPassDensity"`;
				fprint $fileId ( "KrakatoaLightingPassDensity="+ $krakatoaLightingDensity + "\n" );
				
				int $krakatoaLightingDensityExponent = `getAttr "MayaKrakatoaRenderSettings.lightingPassDensityExponent"`;
				fprint $fileId ( "KrakatoaLightingPassDensityExponent=" + $krakatoaLightingDensityExponent + "\n" );
				
				int $krakatoaUseEmissionStrength = `getAttr "MayaKrakatoaRenderSettings.useEmissionStrength"`;
				if($krakatoaUseEmissionStrength == 1) { $boolVal = "True"; }
				else { $boolVal = "False"; }
				fprint $fileId ( "KrakatoaUseEmissionStrength=" + $boolVal + "\n" );
				
				float $krakatoaEmissionStrength = `getAttr "MayaKrakatoaRenderSettings.emissionStrength"`;
				fprint $fileId ( "KrakatoaEmissionStrength="+ $krakatoaEmissionStrength + "\n" );

				int $krakatoaEmissionStrengthExponent = `getAttr "MayaKrakatoaRenderSettings.emissionStrengthExponent"`;
				fprint $fileId ( "KrakatoaEmissionStrengthExponent=" + $krakatoaEmissionStrengthExponent + "\n" );
				
				int $krakatoaUseEmission = `getAttr "MayaKrakatoaRenderSettings.useEmission"`;
				if($krakatoaUseEmission == 1) { $boolVal = "True"; }
				else { $boolVal = "False"; }
				fprint $fileId ( "KrakatoaUseEmission=" + $boolVal + "\n" );
				
				int $krakatoaUseAbsorption = `getAttr "MayaKrakatoaRenderSettings.useAbsorption"`;
				if($krakatoaUseAbsorption == 1) { $boolVal = "True"; }
				else { $boolVal = "False"; }
				fprint $fileId ( "KrakatoaUseAbsorption=" + $boolVal + "\n" );
				
				int $krakatoaEnableMotionBlur = `getAttr "MayaKrakatoaRenderSettings.enableMotionBlur"`;
				if($krakatoaEnableMotionBlur == 1) { $boolVal = "True"; }
				else { $boolVal = "False"; }
				fprint $fileId ( "KrakatoaEnableMotionBlur=" + $boolVal + "\n" );
				
				int $krakatoaMotionBlurParticleSegments = `getAttr "MayaKrakatoaRenderSettings.motionBlurParticleSegments"`;
				fprint $fileId ( "KrakatoaMotionBlurParticleSegments=" + $krakatoaMotionBlurParticleSegments+ "\n" );
				
				int $krakatoaJitteredMotionBlur = `getAttr "MayaKrakatoaRenderSettings.jitteredMotionBlur"`;
				if($krakatoaJitteredMotionBlur == 1) { $boolVal = "True"; }
				else { $boolVal = "False"; }
				fprint $fileId ( "KrakatoaJitteredMotionBlur=" + $boolVal + "\n" );
				
				float $krakatoaShutterAngle = `getAttr "MayaKrakatoaRenderSettings.shutterAngle"`;
				fprint $fileId ( "KrakatoaShutterAngle="+ $krakatoaShutterAngle + "\n" );
				
				int $krakatoaEnableDOF = `getAttr "MayaKrakatoaRenderSettings.enableDOF"`;
				if($krakatoaEnableDOF == 1) { $boolVal = "True"; }
				else { $boolVal = "False"; }
				fprint $fileId ( "KrakatoaEnableDOF=" + $boolVal + "\n" );
				
				float $krakatoaSampleRateDOF = `getAttr "MayaKrakatoaRenderSettings.sampleRateDOF"`;
				fprint $fileId ( "KrakatoaSampleRateDOF="+ $krakatoaSampleRateDOF + "\n" );
				
				int $krakatoaEnableMatteObjects = `getAttr "MayaKrakatoaRenderSettings.enableMatteObjects"`;
				if($krakatoaEnableMatteObjects == 1) { $boolVal = "True"; }
				else { $boolVal = "False"; }
				fprint $fileId ( "KrakatoaEnableMatteObjects=" + $boolVal + "\n" );
				
				int $krakatoaEnableOverrideBG = `getAttr "MayaKrakatoaRenderSettings.overrideBG"`;
				if($krakatoaEnableOverrideBG == 1) { $boolVal = "True"; }
				else { $boolVal = "False"; }
				fprint $fileId ( "KrakatoaEnableOverrideBG=" + $boolVal + "\n" );
				
				//float $krakatoaBGOverride[] = `getAttr "MayaKrakatoaRenderSettings.backgroundColor"`;
				//fprint $fileId ( "KrakatoaBGOverride=" + $krakatoaBGOverride[0]+ " "+ $krakatoaBGOverride[1] + " " + $krakatoaBGOverride[2] + "\n" );
				
				int $krakatoaEnableOverrideColor = `getAttr "MayaKrakatoaRenderSettings.overrideColor"`;
				if($krakatoaEnableOverrideColor == 1) { $boolVal = "True"; }
				else { $boolVal = "False"; }
				fprint $fileId ( "KrakatoaEnableOverrideColor=" + $boolVal + "\n" );
				
				//float $krakatoaColorOverride[] = `getAttr "MayaKrakatoaRenderSettings.colorChannelOverride"`;
				//fprint $fileId ( "KrakatoaColorOverride=" + $krakatoaColorOverride[0]+ " "+ $krakatoaColorOverride[1] + " " + $krakatoaColorOverride[2] + "\n" );
				
				int $krakatoaEnableOverrideEmission = `getAttr "MayaKrakatoaRenderSettings.overrideEmission"`;
				if($krakatoaEnableOverrideEmission == 1) { $boolVal = "True"; }
				else { $boolVal = "False"; }
				fprint $fileId ( "KrakatoaEnableOverrideEmission=" + $boolVal + "\n" );
				
				//float $krakatoaEmissionOverride[] = `getAttr "MayaKrakatoaRenderSettings.emissionChannelOverride"`;
				//fprint $fileId ( "KrakatoaEmissionOverride=" + $krakatoaEmissionOverride[0]+ " "+ $krakatoaEmissionOverride[1] + " " + $krakatoaEmissionOverride[2] + "\n" );
				
				int $krakatoaEnableOverrideAbsorption = `getAttr "MayaKrakatoaRenderSettings.overrideAbsorption"`;
				if($krakatoaEnableOverrideAbsorption == 1) { $boolVal = "True"; }
				else { $boolVal = "False"; }
				fprint $fileId ( "KrakatoaEnableOverrideAbsorption=" + $boolVal+ "\n" );
				
				//float $krakatoaAbsorptionOverride[] = `getAttr "MayaKrakatoaRenderSettings.absorptionChannelOverride"`;
				//fprint $fileId ( "krakatoaAbsorptionOverride=" + $krakatoaAbsorptionOverride[0]+ " "+ $krakatoaAbsorptionOverride[1] + " " + $krakatoaAbsorptionOverride[2] + "\n" );
				
				string $krakatoaRenderingMethod = `getAttr -asString "MayaKrakatoaRenderSettings.renderingMethod"`;
				fprint $fileId ( "KrakatoaRenderingMethod="+ $krakatoaRenderingMethod + "\n" );
				
				if ($krakatoaRenderingMethod =="Voxels")
				{
					float $krakatoaVoxelSize = `getAttr "MayaKrakatoaRenderSettings.voxelSize"`;
					fprint $fileId ( "KrakatoaVoxelSize="+ $krakatoaVoxelSize + "\n" );
					
					float $krakatoaVoxelFilterRadius = `getAttr "MayaKrakatoaRenderSettings.voxelFilterRadius"`;
					fprint $fileId ( "KrakatoaVoxelFilterRadius="+ $krakatoaVoxelFilterRadius + "\n" );
				}
				
				int $krakatoaForceEXROutput = `getAttr "MayaKrakatoaRenderSettings.forceEXROutput"`;
				if($krakatoaForceEXROutput == 1) { $boolVal = "True"; }
				else { $boolVal = "False"; }
				fprint $fileId ( "KrakatoaForceEXROutput=" + $boolVal + "\n" );
				
			}
			
			if( $renderer == "arnold" )
			{
				string $arnoldVerbose = `optionMenuGrp -q -value frw_arnoldVerbose`;
				fprint $fileId ( "ArnoldVerbose=" + $arnoldVerbose + "\n" );
			}
				
			if( $renderer == "mentalRay" )
			{
				string $mentalRayVerbose = `optionMenuGrp -q -value frw_mentalRayVerbose`;
				fprint $fileId ( "MentalRayVerbose=" + $mentalRayVerbose + "\n" );
				
				int $autoMemoryLimit = `checkBox -q -value frw_autoMemoryLimit`;
				fprint $fileId ( "AutoMemoryLimit=" + $autoMemoryLimit + "\n" );
				
				int $memoryLimit = `intSliderGrp -q -v frw_memoryLimit`;
				fprint $fileId ( "MemoryLimit=" + $memoryLimit + "\n" );
			}

			if( $renderer == "redshift" )
			{
				int $redshiftGPUsPerTask = `intSliderGrp -q -v frw_redshiftGPUsPerTask`;
				fprint $fileId ( "RedshiftGPUsPerTask=" + $redshiftGPUsPerTask + "\n" );

				string $redshiftGPUsSelectDevices = `textFieldGrp -q -text frw_redshiftGPUsSelectDevices`;
				fprint $fileId ( "RedshiftGPUsSelectDevices=" + `textFieldGrp -q -text frw_redshiftGPUsSelectDevices` + "\n" );
				
				int $redshiftVerbose = `optionMenuGrp -q -sl frw_redshiftVerbose`;
				fprint $fileId ( "RedshiftVerbose=" + ( $redshiftVerbose -1 ) + "\n" );
			}
			
			if( $renderer == "ifmIrayPhotoreal" )
			{
				string $boolVal = "";
				
				int $irayGPUsPerTask = `intSliderGrp -q -v frw_irayGPUsPerTask`;
				fprint $fileId ( "IRayGPUsPerTask=" + $irayGPUsPerTask + "\n" );

				string $irayGPUsSelectDevices = `textFieldGrp -q -text frw_irayGPUsSelectDevices`;
				fprint $fileId ( "IRayGPUsSelectDevices=" + `textFieldGrp -q -text frw_irayGPUsSelectDevices` + "\n" );
				
				int $irayUseCPUs = `checkBox -q -v frw_irayUseCPUs`;
				
				if($irayUseCPUs == 1) { $boolVal = "True"; }
				else { $boolVal = "False"; }
				
				fprint $fileId ( "IRayUseCPUs=" + $boolVal + "\n" );
				
				float $irayCPULoad = `floatSliderGrp -q -v frw_irayCPULoad`;
				fprint $fileId ( "IRayCPULoad=" + $irayCPULoad + "\n" );
				
				int $irayMaxSamples = `getAttr ifmGlobalsIrayPhotoreal.irayMaxSamples`;
				fprint $fileId ( "IRayMaxSamples=" + $irayMaxSamples + "\n" );
			}

			if( $renderer == "vray" )
			{
				if( $useMayaBatchPlugin )
				{
					int $vrayAutoMemoryEnabled = `checkBox -q -value frw_vrayAutoMemoryEnabled`;
					fprint $fileId ( "VRayAutoMemoryEnabled=" + $vrayAutoMemoryEnabled + "\n" );
					
					int $vrayAutoMemoryBuffer = `intSliderGrp -q -v frw_vrayAutoMemoryBuffer`;
					fprint $fileId ( "VRayAutoMemoryBuffer=" + $vrayAutoMemoryBuffer + "\n" );
				}
			}
			
			if( $renderer == "maxwell" )
			{
				fprint $fileId ( "MaxwellRenderTime=" + `getAttr "maxwellRenderOptions.renderTime"` + "\n" );
				fprint $fileId ( "MaxwellSamplingLevel=" + `getAttr "maxwellRenderOptions.samplingLevel"` + "\n" );
				fprint $fileId ( "MaxwellResumeRender=false\n" );
			}
			
			if( $renderer == "OctaneRender" )
			{
				fprint $fileId ( "OctaneMaxSamples=" + `getAttr "octaneSettings.MaxSamples"` + "\n" );
			}
		}

		//fprint $fileId ( "Version=" + IntMayaVersion() + "\n" );
		fprint $fileId ( "Version=" + MayaVersion() + "\n" );

		if( MayaVersion() >= 2016.5 )
		{
			fprint $fileId ( "UseLegacyRenderLayers=" + !mayaHasRenderSetup() + "\n" );
		}
		
		string $mayaBuild = `optionMenuGrp -q -value frw_mayaBuild`;
		fprint $fileId ( "Build=" + $mayaBuild + "\n" );
		
		fprint $fileId ( "ProjectPath=" + CheckSlashes( `textFieldGrp -q -text frw_projectPath` ) + "\n" );
		if( !$useMayaBatchPlugin )
			fprint $fileId ( "CommandLineOptions=" + `textFieldGrp -q -text frw_mayaArgs` + "\n" );
		else
			fprint $fileId ( "StartupScript=" + `textFieldButtonGrp -q -text $StartupScriptPathGrp` + "\n" );
		
		int $res[] = GetGlobalsResolution();
		fprint $fileId ( "ImageWidth=" + $res[0] + "\n" );
		fprint $fileId ( "ImageHeight=" + $res[1] + "\n" );
		//if( $renderer != "vray" )
		//	fprint $fileId ( "AspectRatio=" + `getAttr "defaultResolution.deviceAspectRatio"` + "\n" );
		
		// Skip existing is only supported in 2014 and later, and by specific renderers.
		if( IntMayaVersion() >= 2014 && ( $renderer == "ifmirayphotoreal" || $renderer == "mentalRay" || $renderer == "mayaSoftware" || $renderer == "mayaHardware" || $renderer == "mayaHardware2" || $renderer == "mayaVector") )
		{
			int $skipExistingFrames = `getAttr defaultRenderGlobals.skipExistingFrames`;
			fprint $fileId ( "SkipExistingFrames=" + $skipExistingFrames + "\n" );
		}
		
		string $baseOutputFilePath = CheckSlashes( `textFieldGrp -q -text frw_outputFilePath` );
		fprint $fileId ( "OutputFilePath=" + $baseOutputFilePath + "\n" );
		if( IsRenderLayersOn() && !$submitEachRenderLayer )
			fprint $fileId ( "OutputFilePrefix=\n" );
		else if( $jobType == $MaxwellExportJobType )
			fprint $fileId ( "OutputFilePrefix=\n" );
		else
		{
			string $mayaOutputFilePrefix = GetMayaOutputPrefix( $camera, $currentRenderLayer );			
			if( $jobType == $MayaRenderJobType && $regionRendering )
			{
				
				int $regionType = `optionMenuGrp -q -select frw_regionRenderType`;  
				if($regionType == $TileRegionRenderType)
					$mayaOutputFilePrefix = GetTileOutputPrefix( $mayaOutputFilePrefix, $currX, $currY, $tilesInX, $tilesInY, $renderer );
				else
					$mayaOutputFilePrefix = GetJigsawOutputPrefix( $mayaOutputFilePrefix, $currTile, $renderer );
				
			}
			
			fprint $fileId ( "OutputFilePrefix=" + $mayaOutputFilePrefix + "\n" );	
		}
		
		//fprint $fileId ( "MotionBlur=" + GetMotionBlur() + "\n" );
			
		// If the user has specified a camera, make it the default
		fprint $fileId ( "Camera=" + $camera + "\n" );
		
		// Now list all the camera options
		fprint $fileId ("Camera0=\n");
		string $cameraNames[] = `listTransforms -cameras`;
		for( $n = 1 ; $n <= size($cameraNames); $n++ )
			fprint $fileId ( "Camera" + $n + "=" + $cameraNames[ $n - 1 ] + "\n" );
		
		string $sceneFilePath = CheckSlashes( `file -q -sceneName` );
		int $submitMayaSceneFile = `checkBox -q -value frw_submitMayaScene`;
		if( !$submitMayaSceneFile )
			fprint $fileId ( "SceneFile=" + $sceneFilePath + "\n" );
		
		int $ignoreError211 = `checkBox -q -value frw_ignoreError211`;
		fprint $fileId ( "IgnoreError211=" + $ignoreError211 + "\n" );
		
		fclose $fileId;
		
		
		string $argList[];
		$argList[0] = $submitFilename;
		$argList[1] = $jobFilename;
		if( $submitMayaSceneFile )
		{
			$argList[size($argList)] = $sceneFilePath;
		}
		if( $jobType == $MayaScriptJobType)
		{	
			string $result = `textFieldGrp -q -tx frw_mayaScriptJob`;
			$argList[size($argList)] = $result;
		}
		
		// Submit the job to Deadline
		string $submissionCommandFile = CreateArgumentsFile( $argList );
		$submitResults = CallDeadlineCommand( "\"" + $submissionCommandFile + "\"", true );
	}
	
	// Get the job id to return
	string $jobId = "";
	string $resultArray[];
	$resultArray = stringToStringArray( $submitResults, "\n" );
	for( $n = 0; $n < size($resultArray); $n++ )
	{
		if( startsWith( $resultArray[$n], "JobID=" ) )
		{
			$jobId = substituteAllString( $resultArray[$n], "JobID=", "" );
			break;
		}
	}
	
	// Specify which renderer is being used.
	if( $jobType == $MentalRayExportJobType )
		$submitResults = $submitResults + "\n\nUsing renderer: mentalRayExport\n";
	else if( $jobType == $VRayExportJobType )
		$submitResults = $submitResults + "\n\nUsing renderer: vrayExport\n";
	else if( $jobType == $RendermanExportJobType )
		$submitResults = $submitResults + "\n\nUsing renderer: rendermanExport\n";
	else if( $jobType == $ArnoldExportJobType )
		$submitResults = $submitResults + "\n\nUsing renderer: arnoldExport\n";
	else if( $jobType == $MaxwellExportJobType )
		$submitResults = $submitResults + "\n\nUsing renderer: maxwellExport\n";  
	else if( $jobType == $BifrostSimulationJobType )
		$submitResults = $submitResults + "\n\nCreating bifrost simulation\n";
	else if( $jobType == $AlembicExportJobType )
		$submitResults = $submitResults + "\n\nExporting to Alembic format\n";
	else if( $jobType == $MayaScriptJobType )
		$submitResults = $submitResults + "\n\nRunning Maya Script Job\n";
	else if( $jobType == $GeometryCachingJobType )
		$submitResults = $submitResults + "\n\nRunning Geometry cache job\n";
	else if( $jobType == $FluidCachingJobType )
		$submitResults = $submitResults + "\n\nRunning Fluid cache job\n";
	else
		$submitResults = $submitResults + "\n\nUsing renderer: " + $renderer + "\n";
	
	// Show results
	if( $showDialog )
		confirmDialog -title "Submission Results" -parent $DeadlineSubmitterWindow -message $submitResults -button "Ok";
	else
		print( "\n\nSubmission Results For Job " + $jobName + ":\n---------------------------------------------------------------------------\n" + $submitResults + "\n" );
	
	return $jobId;
}

proc int SetupDependentJigsawAnimationAssemblerJob(string $renderer, string $jobIds[], string $currentRenderLayer, string $currCamera)
{
	global int $PreviousImageCompType;
	global int $SelectedImageCompType;
	
	int $jobCount = 0;
	
	string $elements[] = {""};
	int $isMultichannelExr = false;
	string $multichannel = " (multichannel)";
	string $ext = "";
	
	
	
	int $submitEachRenderLayer = IsRenderLayersOn() ? `checkBox -q -value frw_submitEachRenderLayer` : false;
	int $overrideLayerSettings = `checkBox -q -value frw_overrideLayerSettings`;
	string $frameList = `textFieldGrp -q -text frw_FrameList`;
	if( $submitEachRenderLayer )
	{		
		if($overrideLayerSettings)
		{
			$field = "frw_FrameList_" + $currentRenderLayer;
			$frameList = `textFieldGrp -q -text $field`;
		}
		else
		{
			int $range[] = GetFrameRange();
			int $fromFrame = $range[0];
			int $toFrame = $range[1];
			int $byFrame = $range[2];
			
			$frameList = $fromFrame + "-" + $toFrame;
			if( $byFrame > 1 )
				$frameList = $frameList + "x" + $byFrame;
		}
	}
	
	int $frameRange[] = GetFramesArray($frameList);
	
	string $regionString = `getAttr defaultRenderGlobals.deadlineRegionLeft`;
	string $regionLeftValues[] = stringToStringArray($regionString,";");
	$regionString = `getAttr defaultRenderGlobals.deadlineRegionRight`;
	string $regionRightValues[] = stringToStringArray($regionString,";");
	$regionString = `getAttr defaultRenderGlobals.deadlineRegionTop`;
	string $regionTopValues[] = stringToStringArray($regionString,";");
	$regionString = `getAttr defaultRenderGlobals.deadlineRegionBottom`;
	string $regionBottomValues[] = stringToStringArray($regionString,";");
	
	if( $renderer == "vray" )
	{
		$elements = getVRayElementNames();
	}
	else if( $renderer == "arnold" )
	{
		$elements = getArnoldElementNames();
	}
	else if( $renderer == "mentalRay" )
	{
		$elements = getMentalRayElementNames( $currentRenderLayer );
	}
		
	string $outputFilePath = CheckSlashes( `textFieldGrp -q -text frw_outputFilePath` );
	
	string $tempDir = CallDeadlineCommand( "-GetCurrentUserHomeDirectory", false ) + "/temp";
	string $configFilenames[];
	string $submitFilename = "";
	string $jobFilename = "";
	string $configFilename = "";
	
	int $res[] = GetGlobalsResolution();
	int $width = $res[0];
	int $height = $res[1];;
	if( $renderer == "vray" )
		$height = $height - 0; // vray is very picky about the height. Not width for some reason.
		
	int $currTile = 0;
	
	string $jobIdString = stringArrayToString ($jobIds,",");
	
	for($element in $elements)
	{
		$configFilenames = {};
		
		string $jobName = `textFieldGrp -q -text frw_JobName`;
		if( $currentRenderLayer != "" )
			$jobName += " - " + $currentRenderLayer;
		if( $currCamera != "" )
			$jobName += " - " + $currCamera;
		
		if($element != "")
			$jobName = $jobName + " - "+$element+" (Animation - Tile Assembly Job)";
		else
			$jobName = $jobName + " - (Animation - Tile Assembly Job)";
		
		$submitFilename = CheckSlashes( $tempDir + "/draft_tile_deadline_info.job" );
		$fileId = `fopen $submitFilename "w"`;
		if( $fileId == 0 )
			print( "Error in Deadline Submission Script: could not create " + $submitFilename + "\n" );

		fprint $fileId ( "Plugin=DraftTileAssembler\n" );
		fprint $fileId ( "Name=" + $jobName + "\n" );
		fprint $fileId ( "BatchName=" + `textFieldGrp -q -text frw_JobName` + "\n" );
		fprint $fileId ( "Comment=" + `textFieldGrp -q -text frw_JobComment` + "\n" );
		fprint $fileId ( "Pool=" + `optionMenuGrp -q -value frw_deadlinePool` + "\n" );
		fprint $fileId ( "SecondaryPool=" + `optionMenuGrp -q -value frw_deadlineSecondaryPool` + "\n" );
		fprint $fileId ( "Priority=" + `intSliderGrp -q -v frw_JobPriority` + "\n" );
		fprint $fileId ( "OnJobComplete=" + `optionMenuGrp -q -value frw_onComplete` + "\n" );
		fprint $fileId ( "Department=" + `textFieldGrp -q -text frw_Department` + "\n" );
		fprint $fileId ( "Group=" + `optionMenuGrp -q -value frw_Group` + "\n" );
		
		fprint $fileId ( "IsFrameDependent=True\n" );
		
		int $curFile = 0;
		for( $frameNumber in $frameRange )
		{
			string $outputPrefix = GetOutputPrefix( 1, $frameNumber, $currentRenderLayer, $currCamera, $element );
			$outputPrefix = swapDeepExr( $outputPrefix );
			string $outputFilename = CheckSlashes( $outputFilePath  + "/" + $outputPrefix );
			
			fprint $fileId ( "OutputFilename"+$curFile+"=" +$outputFilename + "\n" );
			$curFile++;
		}
		
		fprint $fileId ( "JobDependencies=" + $jobIdString + "\n" );
		fprint $fileId ( "Frames="+$frameList+"\n" );

		fprint $fileId ( "ChunkSize=1\n" );
		
		if( `checkBox -q -value frw_isBlacklist` )
			fprint $fileId ( "Blacklist=" + `textFieldGrp -q -text frw_machineList` + "\n" );
		else
			fprint $fileId ( "Whitelist=" + `textFieldGrp -q -text frw_machineList` + "\n" );

		fclose $fileId;
		
		$jobFilename = CheckSlashes( $tempDir + "/draft_tile_deadline_job.job" );
		$fileId = `fopen $jobFilename "w"`;
		if( $fileId == 0 )
			print( "Error in Deadline Submission Script: could not create " + $jobFilename + "\n" );
		int $errorOnMissing = `checkBox -q -v frw_submitTileErrorOnMissing`;
		int $tileMissingBackground = `checkBox -q -v frw_submitTileErrorOnMissingBackground`;
		string $missing = $errorOnMissing ? "true" : "false";
		string $missingBackground = $tileMissingBackground ? "true" : "false";
		fprint $fileId ( "ErrorOnMissing=" +$missing+ "\n" );
		fprint $fileId ( "ErrorOnMissingBackground="+$missingBackground+"\n" );
		fprint $fileId ( "CleanupTiles=" + `checkBox -q -v frw_submitTileCleanupJob` + "\n" );
		fprint $fileId ( "MultipleConfigFiles=true\n" );
		fclose $fileId;
		
		int $frameCount = 0;
		
		for($frameNumber in $frameRange)
		{
			string $outputPrefix = GetOutputPrefix( 1, $frameNumber, $currentRenderLayer, $currCamera, $element );
			string $outputFilename = CheckSlashes( $outputFilePath  + "/" + $outputPrefix );
			string $base = basenameEx( $outputPrefix );		

			string $dateString = `date -format "YYYY_MM_DD_hh_mm_ss"`;
			string $configDirectory = dirname( $outputFilename );
			
			if( $element == "" || $renderer == "vray" )
				$configFilename = CheckSlashes( $configDirectory  + "/"+$base+"_config_"+$dateString+".txt" );
			else
				$configFilename = CheckSlashes( $configDirectory  + "/"+$base+"_"+$element+"_config_"+$dateString+".txt" );
			sysFile -makeDir $configDirectory;
			
			$fileId = `fopen $configFilename "w"`;
			if( $fileId == 0 )
				print( "Error in Deadline Submission Script: could not create " + $configFilename + "\n" );
			
			fprint $fileId ( "\n" );
			fprint $fileId ( "ImageFileName=" + $outputFilename + "\n" );
			fprint $fileId ( "ImageWidth=" +$width+ "\n" );
			fprint $fileId ( "ImageHeight=" + $height + "\n" );
			
			string  $imfType = getImfImageType();
			if( $renderer == "mentalRay" || $renderer == "vray" || $renderer == "ifmIrayPhotoreal" || ( ( $renderer == "arnold" || $renderer == "renderMan" || $renderer == "renderManRIS"  ) && ( $imfType == "exr" || $imfType == "deepexr" ) ) )
			{
				fprint $fileId ( "TilesCropped=False\n" );
			}
			else
			{
				fprint $fileId ( "TilesCropped=True\n" );
			}
			
			int $currTile = 0;
			for($i = 0;$i<size($regionLeftValues);$i++)
			{
				string $tileRegionLeft = $regionLeftValues[$i];
				string $tileRegionLeftArray[] = stringToStringArray($tileRegionLeft, ",");
				string $tileRegionRight = $regionRightValues[$i];
				string $tileRegionRightArray[] = stringToStringArray($tileRegionRight, ",");
				string $tileRegionTop = $regionTopValues[$i];
				string $tileRegionTopArray[] = stringToStringArray($tileRegionTop, ",");
				string $tileRegionBottom = $regionBottomValues[$i];
				string $tileRegionBottomArray[] = stringToStringArray($tileRegionBottom, ",");

				if($tileRegionLeftArray[$frameCount] != "-1")
				{
					string $inputPrefix = GetJigsawOutputPrefix( $outputPrefix, $i, $renderer);
					string $inputImageFilename = CheckSlashes( $outputFilePath  + "/" + $inputPrefix );
					
					int $currWidth = int($tileRegionRightArray[$frameCount])-int($tileRegionLeftArray[$frameCount]);
					int $currHeight = int($tileRegionBottomArray[$frameCount])-int($tileRegionTopArray[$frameCount]);
					
					int $top = int($tileRegionTopArray[$frameCount]);
					if( $renderer == "vray" )
					{
						//$top = $height - int($tileRegionBottomArray[$frameCount]);
						$currWidth ++;
						$currHeight ++;
					}
					
					fprint $fileId ( "Tile"+$currTile+"FileName=" + $inputImageFilename + "\n");
					fprint $fileId ( "Tile"+$currTile+"X="+($tileRegionLeftArray[$frameCount])+"\n" );
					fprint $fileId ( "Tile"+$currTile+"Y="+($top)+"\n" );
					fprint $fileId ( "Tile"+$currTile+"Width="+($currWidth)+"\n" );
					fprint $fileId ( "Tile"+$currTile+"Height="+($currHeight)+"\n" );
					$currTile++;
				}
			}
			fprint $fileId ( "TileCount=" +$currTile+ "\n" );
			int $compType = `optionMenuGrp -q -select frw_compositeType`;
			string $oldImage;
			if($compType == $PreviousImageCompType)
			{
				$oldImage = $outputFilename;
				fprint $fileId ("BackgroundSource="+$oldImage+"\n");
			}
			else if($compType == $SelectedImageCompType)
			{
				$oldImage = `textFieldButtonGrp -q -text frw_submitTileCompositeOverName`;
				fprint $fileId ("BackgroundSource="+$oldImage+"\n");
			}
			fclose $fileId;
			stringArrayInsertAtIndex(`size($configFilenames)`, $configFilenames, $configFilename );
		}
				
		string $argList[];
		$argList[0] = $submitFilename;
		$argList[1] = $jobFilename;
		for($conFile in $configFilenames)
		{
			$argList[size($argList)] = $conFile;
		}
		
		// Submit the job to Deadline
		string $submissionCommandFile = CreateArgumentsFile( $argList );
		string $submitResults = CallDeadlineCommand( "\"" + $submissionCommandFile + "\"", true );
		// Show results
		print( "\n\nSubmission Results For Job " + $jobName + ":\n---------------------------------------------------------------------------\n" + $submitResults + "\n" );
		$jobCount++;
	}
	
	return $jobCount;
}

proc int SetupDependentJigsawAssemblerJob(string $renderer, string $jobIds[], int $frameNumber, int $regionValues[], string $currentRenderLayer, string $currCamera)
{
	global int $PreviousImageCompType;
	global int $SelectedImageCompType;
	
	string $elements[] = {""};
	
	int $isMultichannelExr = false;
	string $multichannel = " (multichannel)";
	string $ext = "";
	
	if( $renderer == "vray" )
	{
		$elements = getVRayElementNames();
	}
	else if( $renderer == "arnold" )
	{
		$elements = getArnoldElementNames();
	}
	else if( $renderer == "mentalRay" )
	{
		$elements = getMentalRayElementNames( $currentRenderLayer );
	}
		
	string $jobName = `textFieldGrp -q -text frw_JobName`;
	if( $currentRenderLayer != "" )
		$jobName += " - " + $currentRenderLayer;
	if( $currCamera != "" )
		$jobName += " - " + $currCamera;
	
	$jobName = $jobName + "(Frame " + $frameNumber + " - Tile Assembly Job)";
	
	string $outputFilePath = CheckSlashes( `textFieldGrp -q -text frw_outputFilePath` );
		
	string $tempDir = CallDeadlineCommand( "-GetCurrentUserHomeDirectory", false ) + "/temp";
	string $configFilenames[];
	string $submitFilename = "";
	string $jobFilename = "";
	string $configFilename = "";
	
	int $res[] = GetGlobalsResolution();
	int $width = $res[0];
	int $height = $res[1];;
	if( $renderer == "vray" )
		$height = $height - 0; // vray is very picky about the height. Not width for some reason.
		
	int $totalTiles = size($regionValues)/4;
	int $currTile = 0;
	$submitFilename = CheckSlashes( $tempDir + "/draft_tile_deadline_info.job" );
	$fileId = `fopen $submitFilename "w"`;
	if( $fileId == 0 )
		print( "Error in Deadline Submission Script: could not create " + $submitFilename + "\n" );

	fprint $fileId ( "Plugin=DraftTileAssembler\n" );
	fprint $fileId ( "Name=" + $jobName + "\n" );
	fprint $fileId ( "BatchName=" + `textFieldGrp -q -text frw_JobName` + "\n" );
	fprint $fileId ( "Comment=" + `textFieldGrp -q -text frw_JobComment` + "\n" );
	fprint $fileId ( "Pool=" + `optionMenuGrp -q -value frw_deadlinePool` + "\n" );
	fprint $fileId ( "SecondaryPool=" + `optionMenuGrp -q -value frw_deadlineSecondaryPool` + "\n" );
	fprint $fileId ( "Priority=" + `intSliderGrp -q -v frw_JobPriority` + "\n" );
	fprint $fileId ( "OnJobComplete=" + `optionMenuGrp -q -value frw_onComplete` + "\n" );
	fprint $fileId ( "Department=" + `textFieldGrp -q -text frw_Department` + "\n" );
	fprint $fileId ( "Group=" + `optionMenuGrp -q -value frw_Group` + "\n" );
	
	int $curFile = 0;
	for( $element in $elements  )
	{
		string $outputPrefix = GetOutputPrefix( 1, $frameNumber, $currentRenderLayer, $currCamera, $element );
		$outputPrefix = swapDeepExr( $outputPrefix );
		string $outputFilename = CheckSlashes( $outputFilePath  + "/" + $outputPrefix );
		fprint $fileId ( "OutputFilename"+$curFile+"=" + $outputFilename + "\n" );
		$curFile++;
	}
		
	string $jobIdString = stringArrayToString ($jobIds,",");
	fprint $fileId ( "JobDependencies=" + $jobIdString + "\n" );
	
	fprint $fileId ( "Frames=0-"+(`size($elements)` -1)+"\n" );
	
	fprint $fileId ( "ChunkSize=1\n" );
	
	if( `checkBox -q -value frw_isBlacklist` )
		fprint $fileId ( "Blacklist=" + `textFieldGrp -q -text frw_machineList` + "\n" );
	else
		fprint $fileId ( "Whitelist=" + `textFieldGrp -q -text frw_machineList` + "\n" );

	fclose $fileId;
	$jobFilename = CheckSlashes( $tempDir + "/draft_tile_deadline_job.job" );
	$fileId = `fopen $jobFilename "w"`;
	if( $fileId == 0 )
		print( "Error in Deadline Submission Script: could not create " + $jobFilename + "\n" );
	int $errorOnMissing = `checkBox -q -v frw_submitTileErrorOnMissing`;
	int $tileMissingBackground = `checkBox -q -v frw_submitTileErrorOnMissingBackground`;
	string $missing = $errorOnMissing ? "true" : "false";
	string $missingBackground = $tileMissingBackground ? "true" : "false";
	fprint $fileId ( "ErrorOnMissing=" +$missing+ "\n" );
	fprint $fileId ("ErrorOnMissingBackground="+$missingBackground+"\n");
	fprint $fileId ( "CleanupTiles=" + `checkBox -q -v frw_submitTileCleanupJob` + "\n" );
	
	if( size($elements) > 1 )
		fprint $fileId ( "MultipleConfigFiles=true\n" );
		
	fclose $fileId;
	for($element in $elements)
	{
		string $dateString = `date -format "YYYY_MM_DD_hh_mm_ss"`;			
		string $outputPrefix = GetOutputPrefix( 1, $frameNumber, $currentRenderLayer, $currCamera, $element );
		$outputPrefix = swapDeepExr( $outputPrefix );
		string $baseName =  basenameEx( $outputPrefix );
		
		string $outputFilename = CheckSlashes( $outputFilePath  + "/" + $outputPrefix );
		string $configDirectory = dirname( $outputFilename );
		
		if( $element == "" || $renderer == "vray" )
			$configFilename = CheckSlashes( $configDirectory  + "/"+$baseName+"_config_"+$dateString+".txt" );
		else
			$configFilename = CheckSlashes( $configDirectory  + "/" + $baseName + "_" + $element + "_config_"+$dateString+".txt" );
				
		sysFile -makeDir $configDirectory;
		$fileId = `fopen $configFilename "w"`;
		if( $fileId == 0 )
			print( "Error in Deadline Submission Script: could not create " + $configFilename + "\n" );
		
		int $currTile = 0;
		fprint $fileId ( "\n" );
		fprint $fileId ( "TileCount=" +$totalTiles+ "\n" );
		fprint $fileId ( "ImageFileName=" + $outputFilename + "\n" );
		fprint $fileId ( "ImageWidth=" +$width+ "\n" );
		fprint $fileId ( "ImageHeight=" + $height + "\n" );
		string  $imfType = getImfImageType();
		if( $renderer == "mentalRay" || $renderer == "vray" || $renderer == "ifmIrayPhotoreal" ||  ( $renderer == "arnold" && ( $imfType == "exr" || $imfType == "deepexr" ) ) )
		{
			fprint $fileId ( "TilesCropped=False\n" );
		}
		else
		{
			fprint $fileId ( "TilesCropped=True\n" );
		}
		for($i = 0; $i<size($regionValues)/4; $i++)
		{
			string $inputPrefix = GetJigsawOutputPrefix( $outputPrefix, $i, $renderer);
			string $inputImageFilename = CheckSlashes( $outputFilePath  + "/" + $inputPrefix );
						
			int $currWidth = $regionValues[$i*4+1]-$regionValues[$i*4];
			int $currHeight = $regionValues[$i*4+3]-$regionValues[$i*4+2];
			
			int $top = ($regionValues[$i*4+2]);
			if( $renderer == "vray" || $renderer == "ifmIrayPhotoreal" )
				$top = $height - ($regionValues[$i*4+3]);
			
			fprint $fileId ("Tile"+$currTile+"FileName=" + $inputImageFilename + "\n");
			fprint $fileId ( "Tile"+$currTile+"X="+($regionValues[$i*4])+"\n" );
			fprint $fileId ( "Tile"+$currTile+"Y="+($top)+"\n" );
			fprint $fileId ( "Tile"+$currTile+"Width="+($currWidth)+"\n" );
			fprint $fileId ( "Tile"+$currTile+"Height="+($currHeight)+"\n" );
			$currTile++;
		}
		
		int $compType = `optionMenuGrp -q -select frw_compositeType`;
		string $oldImage;
		if($compType == $PreviousImageCompType)
		{
			$oldImage = $outputFilename;
			fprint $fileId ("BackgroundSource="+$oldImage+"\n");
		}
		else if($compType == $SelectedImageCompType)
		{
			$oldImage = `textFieldButtonGrp -q -text frw_submitTileCompositeOverName`;
			fprint $fileId ("BackgroundSource="+$oldImage+"\n");
		}
		fclose $fileId;
		
		stringArrayInsertAtIndex(0, $configFilenames, $configFilename );
		
	}
	
	string $argList[];
	$argList[0] = $submitFilename;
	$argList[1] = $jobFilename;
	for($conFile in $configFilenames)
	{
		$argList[size($argList)] = $conFile;
	}
	
	// Submit the job to Deadline
	string $submissionCommandFile = CreateArgumentsFile( $argList );
	string $submitResults = CallDeadlineCommand( "\"" + $submissionCommandFile + "\"", true );
		
	// Show results
	print( "\n\nSubmission Results For Job " + $jobName + ":\n---------------------------------------------------------------------------\n" + $submitResults + "\n" );
	return 1;
}

global proc int[] removeDuplicateIntegers(int $array[])
{
	int $index = 0;
	int $newarray[];
	for( $i = 0 ; $i < size($array) ; $i++ )
	{
		$entry = true;
		for( $j = 0 ; $j < $i ; $j++ )
		{
			if( $array[$i] == $array[$j] ) //duplicate
				$entry = false;
		}
		if( $entry == true )
		{
			$newarray[$index] = $array[$i];
			$index++;
		}
	}
	return $newarray;
}

global proc string[] getVRayElementNames()
{
	string $elementNames[] = {""};
	
	int $isMultichannelExr = false;
	string $multichannel = " (multichannel)";
	string $ext = "";
	
	string $REs[] = `ls -type VRayRenderElement -type VRayRenderElementSet`;
	if (`optionMenuGrp -exists vrayImageFormatMenu`)
		$ext = `optionMenuGrp -q -v vrayImageFormatMenu`;
	else
		$ext = `getAttr vraySettings.imageFormatStr`;
		if ($ext == "")
			$ext = "png";//for some reason this happens if you have not changed the format
		
	if( endsWith( $ext, $multichannel ) )
	{
		$ext = substring( $ext, 1, size( $ext ) - size( $multichannel ) );
		$isMultichannelExr = true;
	}
	int $enableAll = `getAttr "vraySettings.relements_enableall"`;
	int $useReferenced = `getAttr "vraySettings.relements_usereferenced"`;
	
	if( !$isMultichannelExr && $enableAll )
	{
		for($RE in $REs)
		{
			int $enabled = `getAttr ($RE+".enabled")`;
			int $isReferenced = `referenceQuery -isNodeReferenced $RE`;

			if($isReferenced == 1 && $useReferenced == 0)
				continue;

			if($enabled == 1)
			{
				string $reType = `getAttr ($RE+".vrayClassType")`;
				
				string $REName = "";
				if( $reType == "ExtraTexElement" || $reType == "MaterialSelectElement" )
				{
					string $RENameFunction[]  = `listAttr -st "vray_explicit_name_*" $RE`;
					$REName = `getAttr ($RE+"."+$RENameFunction[0])`;
					if( $REName == "" )
					{
						$RENameFunction = `listAttr -st "vray_name_*" $RE`;
						
						$REName = `getAttr ($RE+"."+$RENameFunction[0])`;
						
						if( $reType == "ExtraTexElement" )
						{
							string $textures[] = `listConnections( $RE+ ".vray_texture_extratex")`;
							if( size($textures) > 0 )
							{
								if( $REName != "" )
								{
									$REName+= "_";
								}
								$REName+=  $textures[0];
							}
						}
						else if ( $reType == "MaterialSelectElement" )
						{
							string $materials[] = `listConnections( $RE+ ".vray_mtl_mtlselect")`;
							if( size($materials) > 0 )
							{
								if( $REName != "" )
								{
									$REName+= "_";
								}
								$REName+= $materials[0];
							}
						}
					}
				}
				else
				{
					string $RENameFunction[]  = `listAttr -st "vray_name_*" $RE`;
					if( `size($RENameFunction)` == 0 )
					{
						$RENameFunction = `listAttr -st "vray_filename_*" $RE`;
					}
					$REName = `getAttr ($RE+"."+$RENameFunction[0])`;
				}
				
				$REName = substituteAllString($REName, " ", "_" );
				stringArrayInsertAtIndex( 0, $elementNames, $REName );
			}
		}
	
		int $separateAlpha = `getAttr "vraySettings.separateAlpha"`;
		if( $separateAlpha == 1 )
		{
			stringArrayInsertAtIndex( 0, $elementNames, "Alpha" );
		}
	}
	
	return $elementNames;
}

global proc string[] getMaxwellElementNames()
{
	string $elementNames[] = {""};
	int $embedChannels = `getAttr maxwellRenderOptions.embedAlpha`;
	
	if( !$embedChannels )
	{
		if( `getAttr maxwellRenderOptions.alphaChannel` == 1 )
			stringArrayInsertAtIndex(0,$elementNames, "alpha" );
			
		if( `getAttr maxwellRenderOptions.deepChannel` == 1 )
			stringArrayInsertAtIndex(0,$elementNames, "deep" );
		
		if( `getAttr maxwellRenderOptions.depthChannel` == 1 )
			stringArrayInsertAtIndex(0,$elementNames, "zbuffer" );
		
		if( `getAttr maxwellRenderOptions.shadowChannel` == 1 )
			stringArrayInsertAtIndex(0,$elementNames, "shadow" );		
		
		if( `getAttr maxwellRenderOptions.objIDChannel` == 1 )
			stringArrayInsertAtIndex(0,$elementNames, "object" );
		
		if( `getAttr maxwellRenderOptions.matIDChannel` == 1 )
			stringArrayInsertAtIndex(0,$elementNames, "material" );
		
		if( `getAttr maxwellRenderOptions.motionVectorChannel` == 1 )
			stringArrayInsertAtIndex(0,$elementNames, "motion" );
		
		if( `getAttr maxwellRenderOptions.roughnessChannel` == 1 )
			stringArrayInsertAtIndex(0,$elementNames, "roughness" );
		
		if( `getAttr maxwellRenderOptions.fresnelChannel` == 1 )
			stringArrayInsertAtIndex(0,$elementNames, "fresnel" );
			
		if( `getAttr maxwellRenderOptions.normalsChannel` == 1 )
			stringArrayInsertAtIndex(0,$elementNames, "normals" );
			
		if( `getAttr maxwellRenderOptions.positionChannel` == 1 )
			stringArrayInsertAtIndex(0,$elementNames, "position" );
		
		if( `getAttr maxwellRenderOptions.uvChannel` == 1 )
			stringArrayInsertAtIndex(0,$elementNames, "uv" );
			
		if( `getAttr maxwellRenderOptions.customAlphaChannel` == 1 )
		{
			string $customChannelNameAttributes[] = `listAttr -st "*cn" -multi  maxwellRenderOptions.mxCustomAlphaChannels`;
			for( $nameAttr in $customChannelNameAttributes )
			{
				stringArrayInsertAtIndex(0,$elementNames, "customAlpha_"+`getAttr( "maxwellRenderOptions." + $nameAttr )` );
			}
		}
	}
	
	return $elementNames;
}

global proc string getMaxwellChannelExtension( int $index, int $isChannel )
{
	string $extension = "";
	if( ($index == 0 && $isChannel ) || ($index == 32 && !$isChannel ) )
	{
		$extension = "png";
	}
	else if( ($index == 1 && $isChannel ) || ($index == 8 && !$isChannel ) )
	{
		$extension = "jpg";
	}
	else if( ($index == 2 && $isChannel ) || ($index == 19 && !$isChannel ) )
	{
		$extension = "tga";
	}
	else if( ($index == 3 && $isChannel ) || ($index == 20 && !$isChannel ) )
	{
		$extension = "bmp";
	}
	else if( ($index == 4 && $isChannel ) || ($index == 3 && !$isChannel ) )
	{
		$extension = "tif";
	}
	else if( ($index == 5 && $isChannel ) || ($index == 31 && !$isChannel ) )
	{
		$extension = "exr";
	}
	else if( ($index == 6 && $isChannel ) || ($index == 35 && !$isChannel ) )
	{
		$extension = "hdr";
	}
	else if( ($index == 7 && $isChannel ) || ($index == 36 && !$isChannel ) )
	{
		$extension = "jp2";
	}
	return $extension;
}

global proc string swapDeepExr( string $inputPath)
{
	string $outputPath = $inputPath;
	if( endsWith( $outputPath, "deepexr" ) )
	{
		$outputPath = substring( $outputPath, 1, size( $outputPath ) - size( "deepexr" ) );
		$outputPath = $outputPath+"exr";
	}
	return $outputPath;
}

global proc string[] getArnoldElementNames()
{
	string $elementNames[] = {""};
	
	int $aovMode = `getAttr "defaultArnoldRenderOptions.aovMode"`;
	int $mergeAOV = `getAttr "defaultArnoldDriver.mergeAOVs"`;
	string $imfType = getImfImageType();
	if( $aovMode  )
	{
		if( !$mergeAOV )
		{
			$elementNames = {};
			string $AOVnames[] = `ls -type aiAOV`;
			for($aovName in $AOVnames)
			{
				int $enabled = `getAttr ($aovName+".enabled")`;
				if($enabled == 1)
				{
					stringArrayInsertAtIndex(0,$elementNames,`getAttr ($aovName+".name")`);
				}
			}
			stringArrayInsertAtIndex(0, $elementNames, "beauty" );
		}
	}
	
	return $elementNames;
}

global proc string[] getArnoldElements()
{
	string $elementNames[] = {""};
	
	int $aovMode = `getAttr "defaultArnoldRenderOptions.aovMode"`;
	int $mergeAOV = `getAttr "defaultArnoldDriver.mergeAOVs"`;
	string $imfType = getImfImageType();
	if( $aovMode  )
	{
		if( !$mergeAOV )
		{
			$elementNames = {};
			string $AOVnames[] = `ls -type aiAOV`;
			for($aovName in $AOVnames)
			{
				int $enabled = `getAttr ($aovName+".enabled")`;
				if($enabled == 1)
				{
					stringArrayInsertAtIndex(0,$elementNames,$aovName);
				}
			}
		}
	}
	
	return $elementNames;
}

global proc string[] getRedshiftElements()
{
	string $elementNames[] = {""};
	
	string $REs[] = `ls -type RedshiftAOV`;
	
	for($RE in $REs)
	{
		int $enabled = `getAttr ($RE+".enabled")`;
		if($enabled == 1)
		{
			stringArrayInsertAtIndex(0,$elementNames,$RE);
		}
	}
	
	return $elementNames;
}

global proc string[] getMentalRayElementNames( string $currentRenderLayer)
{
	string $elementNames[] = {""};
	//Format's in Maya are stored as integers.  For Mental ray EXR is stored as 51.
	int $exrFormat = 51;
	
	if( $currentRenderLayer != "" )
	{
		int $format = `getAttr defaultRenderGlobals.imageFormat`;
		string $prefix = `getAttr defaultRenderGlobals.imageFilePrefix`;
		
		//If the format is exr and there is not a renderPass token in the output prefix then the output is rendered as a single multichannel exr so we do not have to handle the elements separately.
		if ( $format != $exrFormat || `match "<RenderPass>" $prefix`!= "" )
		{
			string $renderLayers[] = {};
			$renderLayers = `ls -type renderLayer`;
			if( stringArrayContains($currentRenderLayer, $renderLayers) )
			{
				string $connectedPasses[] = `listConnections ($currentRenderLayer+".rps")`;
				if( size($connectedPasses) >0 )
				{
					$elementNames = {};
					stringArrayInsertAtIndex(0, $elementNames, "MasterBeauty" );
					for( $pass in $connectedPasses )
					{
						stringArrayInsertAtIndex(0,$elementNames,$pass );
					}
				}
			}
		}
	}
	
	return $elementNames;
}

proc int SetupDependentTileAssemblerJob( string $renderer, string $jobIds[], int $frameNumber, int $tilesInX, int $tilesInY, string $currentRenderLayer, string $currCamera )
{
	string $jobName = `textFieldGrp -q -text frw_JobName`;
	if( $currentRenderLayer != "" )
		$jobName += " - " + $currentRenderLayer;
	if( $currCamera != "" )
		$jobName += " - " + $currCamera;
	
	int $singleRegionJob = `checkBox -q -v frw_submitTileSingleJob`;
	if(!$singleRegionJob)
	{
		$jobName = $jobName + "(Tile Assembly Job)";
	}
	else
	{
		$jobName = $jobName + "(Frame " + $frameNumber + " - Tile Assembly Job)";
	}
	
	string $outputFilePath = CheckSlashes( `textFieldGrp -q -text frw_outputFilePath` );
	
	int $submitEachCamera = `checkBox -q -v frw_submitEachCamera`;
	
	string $tempDir = CallDeadlineCommand( "-GetCurrentUserHomeDirectory", false ) + "/temp";
	
	string $elements[] = {""};
		
	if( $renderer == "vray" )
	{
		$elements = getVRayElementNames();
	}
	else if( $renderer == "arnold" )
	{
		$elements = getArnoldElementNames();
	}
	else if( $renderer == "mentalRay" )
	{
		$elements = getMentalRayElementNames( $currentRenderLayer );
	}
	
	string $renderableCameras[] = deadlineGetRenderableCameras( false );
	
	string $submitFilename = "";
	string $jobFilename = "";
	string $configFilenames[];
	string $configFilename = "";
	
	int $draftMultiFrames[];
	
	int $res[] = GetGlobalsResolution();
	int $width = $res[0];
	int $height = $res[1];
	if( $renderer == "vray" )
		$height = $height - 0; // vray is very picky about the height. Not width for some reason.

	int $tilesInX = `intSliderGrp -q -v frw_tilesInX`;
	int $tilesInY = `intSliderGrp -q -v frw_tilesInY`; 

	int $deltaX = floor (1.0 * $width / $tilesInX );
	int $deltaY = floor (1.0 * $height / $tilesInY );

	int $totalTiles = $tilesInX * $tilesInY;
	int $currTile = 0;
	$submitFilename = CheckSlashes( $tempDir + "/draft_tile_deadline_info.job" );
	$fileId = `fopen $submitFilename "w"`;
	if( $fileId == 0 )
		print( "Error in Deadline Submission Script: could not create " + $submitFilename + "\n" );

	fprint $fileId ( "Plugin=DraftTileAssembler\n" );
	fprint $fileId ( "Name=" + $jobName + "\n" );
	fprint $fileId ( "BatchName=" + `textFieldGrp -q -text frw_JobName` + "\n" );
	fprint $fileId ( "Comment=" + `textFieldGrp -q -text frw_JobComment` + "\n" );
	fprint $fileId ( "Pool=" + `optionMenuGrp -q -value frw_deadlinePool` + "\n" );
	fprint $fileId ( "SecondaryPool=" + `optionMenuGrp -q -value frw_deadlineSecondaryPool` + "\n" );
	fprint $fileId ( "Priority=" + `intSliderGrp -q -v frw_JobPriority` + "\n" );
	fprint $fileId ( "OnJobComplete=" + `optionMenuGrp -q -value frw_onComplete` + "\n" );
	fprint $fileId ( "Department=" + `textFieldGrp -q -text frw_Department` + "\n" );
	fprint $fileId ( "Group=" + `optionMenuGrp -q -value frw_Group` + "\n" );
	
	int $curFile = 0;
	for( $element in $elements  )
	{
		string $outputPrefix = GetOutputPrefix( 1, $frameNumber, $currentRenderLayer, $currCamera, $element );
		string $outputFilename = CheckSlashes( $outputFilePath  + "/" + $outputPrefix );
		fprint $fileId ( "OutputFilename"+$curFile+"=" + $outputFilename + "\n" );
		$curFile++;
	}
	
	string $jobIdString = stringArrayToString ($jobIds,",");
	fprint $fileId ( "JobDependencies=" + $jobIdString + "\n" );
	
	if($singleRegionJob)
		fprint $fileId ( "Frames=0-"+(`size($elements)` -1)+"\n" );
	else
		fprint $fileId ("Frames=0-"+(size($draftMultiFrames)-1)+"\n");
		
	fprint $fileId ( "ChunkSize=1\n" );
	fprint $fileId ( "MachineLimit=1\n" );

	if( `checkBox -q -value frw_isBlacklist` )
		fprint $fileId ( "Blacklist=" + `textFieldGrp -q -text frw_machineList` + "\n" );
	else
		fprint $fileId ( "Whitelist=" + `textFieldGrp -q -text frw_machineList` + "\n" );

	fclose $fileId;
	$jobFilename = CheckSlashes( $tempDir + "/draft_tile_deadline_job.job" );
	$fileId = `fopen $jobFilename "w"`;
	if( $fileId == 0 )
		print( "Error in Deadline Submission Script: could not create " + $jobFilename + "\n" );
	int $errorOnMissing = `checkBox -q -v frw_submitTileErrorOnMissing`;
	string $missing = $errorOnMissing ? "true" : "false";
	fprint $fileId ( "ErrorOnMissing=" +$missing+ "\n" );
	fprint $fileId ( "CleanupTiles=" + `checkBox -q -v frw_submitTileCleanupJob` + "\n" );
	if ( size($elements) > 1 )
		fprint $fileId ( "MultipleConfigFiles=true\n" );
		
	fclose $fileId;
	
	for( $element in $elements)
	{
		string $dateString = `date -format "YYYY_MM_DD_hh_mm_ss"`;			
		string $outputPrefix = GetOutputPrefix( 1, $frameNumber, $currentRenderLayer, $currCamera, $element );
		$outputPrefix = swapDeepExr( $outputPrefix );
		string $baseName =  basenameEx( $outputPrefix );

		string $outputFilename = CheckSlashes( $outputFilePath  + "/" + $outputPrefix );
		string $configDirectory = dirname( $outputFilename );
		
		if( $element == "" || $renderer == "vray" )
			$configFilename = CheckSlashes( $configDirectory  + "/"+$baseName+"_config_"+$dateString+".txt" );
		else
			$configFilename = CheckSlashes( $configDirectory  + "/" + $baseName + "_" + $element + "_config_"+$dateString+".txt" );
		
		sysFile -makeDir $configDirectory;
		$fileId = `fopen $configFilename "w"`;
		if( $fileId == 0 )
			print( "Error in Deadline Submission Script: could not create " + $configFilename + "\n" );
		
		int $currTile = 0;
		fprint $fileId ( "\n" );
		fprint $fileId ( "TileCount=" +$totalTiles+ "\n" );
		fprint $fileId ( "ImageFileName=" + $outputFilename + "\n" );
		fprint $fileId ( "ImageWidth=" +$width+ "\n" );
		fprint $fileId ( "ImageHeight=" + $height + "\n" );
		
		string  $imfType = getImfImageType();
		if( $renderer == "mentalRay" || $renderer == "vray" || $renderer == "ifmIrayPhotoreal" || ( $renderer == "arnold" && ( $imfType == "exr" || $imfType == "deepexr" ) ) )
		{
			fprint $fileId ( "TilesCropped=False\n" );
		}
		else
		{
			fprint $fileId ( "TilesCropped=True\n" );
		}
		
		for( $y = 1; $y <= $tilesInY; $y++ )
		{
			for( $x = 1; $x <= $tilesInX; $x++ )
			{
				int $newY = $tilesInY - $y;
				if( $renderer == "vray" || $renderer == "ifmIrayPhotoreal" )
				{
					$newY = $y-1;
				}
				
				int $tempBottom;
				$tempBottom = ($deltaY * $newY);
				string $inputPrefix = GetTileOutputPrefix( $outputPrefix, $x, $y, $tilesInX, $tilesInY, $renderer );
				if($singleRegionJob )
				{
					string $inputImageFilename = CheckSlashes( $outputFilePath  + "/" + $inputPrefix );
					
					fprint $fileId ("Tile"+$currTile+"FileName="+$inputImageFilename+"\n");
					fprint $fileId ("Tile"+$currTile+"="+$inputImageFilename+"\n");
					
				}
				else
				{
					string $ext;
					$ext = `fileExtension $inputPrefix`;
						
					string $postFix = "."+$frameNumber+"."+$ext;
					
					string $base = basename( $inputPrefix, $postFix );
					fprint $fileId ("Tile"+$currTile+"Prefix="+$base+"\n");
				}
				
				fprint $fileId ( "Tile"+$currTile+"X="+($deltaX * ( $x - 1 ))+"\n" );
				fprint $fileId ( "Tile"+$currTile+"Y="+($tempBottom)+"\n" );
				fprint $fileId ( "Tile"+$currTile+"Width="+($deltaX)+"\n" );
				fprint $fileId ( "Tile"+$currTile+"Height="+($deltaY)+"\n" );
				$currTile++;
			}
		}
		fclose $fileId;
		
		stringArrayInsertAtIndex(0, $configFilenames, $configFilename );
	}
	
	// Submit the job to Deadline
	string $submissionCommand = "\"" + $submitFilename + "\" \"" + $jobFilename + "\"";
	
	for($conFile in $configFilenames)
	{
		$submissionCommand = $submissionCommand+" \""+$conFile+"\"";
	}
	
	string $argList[] ;
	$argList[0] = $submitFilename;
	$argList[1] = $jobFilename;

	for($conFile in $configFilenames)
	{
		$argList[size($argList)] = $conFile;
	}
	
	// Submit the job to Deadline
	string $submissionCommandFile = CreateArgumentsFile( $argList );
	string $submitResults = CallDeadlineCommand( "\"" + $submissionCommandFile + "\"", true );
	
	// Show results
	print( "\n\nSubmission Results For Job " + $jobName + ":\n---------------------------------------------------------------------------\n" + $submitResults + "\n" );
	return 1;
}

// Sets some region rendering settings before submitting the job to Deadline.
proc int SetupRegionRenderingJob( string $renderer, string $cameraOverride )
{
	global string $DeadlineSubmitterWindow;
	global int $MayaRenderJobType;
	global int $JigsawRegionRenderType;
	global int $TileRegionRenderType;
	
	int $submitCounter = 0;
	
	AddStringAttribute( "deadlineRegionLeft" );
	AddStringAttribute( "deadlineRegionTop" );
	AddStringAttribute( "deadlineRegionRight" );
	AddStringAttribute( "deadlineRegionBottom" );
	AddLongAttribute( "deadlineCurrX" );
	AddLongAttribute( "deadlineCurrY" );
	AddLongAttribute( "deadlineCurrTile" );
	
	AddStringAttribute( "deadlineRegionSingleLeft" );
	AddStringAttribute( "deadlineRegionSingleTop" );
	AddStringAttribute( "deadlineRegionSingleRight" );
	AddStringAttribute( "deadlineRegionSingleBottom" );
	AddLongAttribute( "deadlineRegionSingleTiles" );
	
	int $taskLimit = int(CallDeadlineCommand( "-getjobtasklimit", true ));
	int $res[] = GetGlobalsResolution();
	int $width = $res[0];
	int $height = $res[1];
	if( $renderer == "vray" )
		$height = $height - 0; // vray is very picky about the height. Not width for some reason.
	
	int $tilesInX = `intSliderGrp -q -v frw_tilesInX`;
	int $tilesInY = `intSliderGrp -q -v frw_tilesInY`; 
	
	int $deltaX = floor (1.0 * $width / $tilesInX );
	int $deltaY = floor (1.0 * $height / $tilesInY );
	
	int $totalTiles = $tilesInX * $tilesInY;
	int $currTile = 0;
	
	string $camera = "";
	if( $cameraOverride != "" )
		$camera = $cameraOverride;
	else
	{
		string $selectedCamera = `optionMenuGrp -q -value frw_camera`;
		string $cameraNames[] = `listTransforms -cameras`;
		for( $cameraName in $cameraNames )
		{
			if( $cameraName == $selectedCamera )
			{
				$camera = $selectedCamera;
				break;
			}
		}
	}
	
	int $singleRegionJob = `checkBox -q -v frw_submitTileSingleJob`;
	int $regionType = `optionMenuGrp -q -select frw_regionRenderType`;	
	int $regions[];
	int $assemblyRegions[];
	
	string $jobIdList[];
	if( !$singleRegionJob )
	{
		if($regionType == $TileRegionRenderType)
		{
			
			for( $y = 1; $y <= $tilesInY; $y++ )
			{
				for( $x = 1; $x <= $tilesInX; $x++ )
				{
					$currTile++;
					
					int $newY = $y;
					if( IsRegionRenderingInverted( $renderer ) )
						$newY = $tilesInY - $y + 1;
					
					setAttr defaultRenderGlobals.deadlineRegionLeft -type "string" ($deltaX * ( $x - 1 ));
					setAttr defaultRenderGlobals.deadlineRegionTop -type "string" ($deltaY * ( $newY - 1 ));
					
					int $tempRight;
					if( $x == $tilesInX )
						$tempRight = $width - 1;
					else
						$tempRight = ($deltaX * $x) - 1;
					
					if( $renderer == "mentalRay" || $renderer == "renderMan" || $renderer == "renderManRIS" )
						$tempRight++;
					
					setAttr defaultRenderGlobals.deadlineRegionRight -type "string" $tempRight;
					
					int $tempBottom;
					if( $newY == $tilesInY )
						$tempBottom = $height - 1;
					else
						$tempBottom = ($deltaY * $newY) - 1;
					
					if( $renderer == "mentalRay" || $renderer == "renderMan" || $renderer == "renderManRIS" )
						$tempBottom++;
						
					if( $renderer == "vray" )
						$tempBottom = $tempBottom + 1;
					
					setAttr defaultRenderGlobals.deadlineRegionBottom -type "string" $tempBottom;
					
					setAttr defaultRenderGlobals.deadlineCurrX $x;
					setAttr defaultRenderGlobals.deadlineCurrY $y;
					setAttr defaultRenderGlobals.deadlineCurrTile $currTile;
					
					string $jobId = WriteJobFilesAndSubmit( $renderer, 0, 1, $MayaRenderJobType, $camera );
					if($jobId != "")
					{
						stringArrayInsertAtIndex(size($jobIdList),$jobIdList, $jobId) ;
						$submitCounter++;
					}
				}
			}
		}
		else
		{
		
			if(catchQuiet(`python("jigsawThread.isAlive()")`))
			{
				confirmDialog -title "Jigsaw Rendering" -message "In order to submit Jigsaw renders the Jigsaw window must be open." -button "OK" -defaultButton "OK";
				return 0;
			}
			
			if(`python("jigsawThread.isAlive()")`)
			{
				python("jigsawThread.requestSave()");
				int $invert = IsRegionRenderingInverted( $renderer );
				$regions = `python("jigsawThread.getRegions(" + $invert + ")")`;
				$assemblyRegions = `python("jigsawThread.getRegions()")`;
			}
			else
			{
				confirmDialog -title "Jigsaw Rendering" -message "In order to submit Jigsaw renders the Jigsaw window must be open." -button "OK" -defaultButton "OK";
				return 0;
			}
			
			string $regionLeftValues[];
			string $regionRightValues[];
			string $regionTopValues[];
			string $regionBottomValues[];
			string $frameList = `textFieldGrp -q -text frw_FrameList`;
			int $frameRange[] = GetFramesArray($frameList);
			int $numRegions = size($regions)/4;
			
			int $renderHeight = `getAttr "defaultResolution.height"`;
			int $renderWidth = `getAttr "defaultResolution.width"`;
					  
			for($curRegion =0;$curRegion<$numRegions;$curRegion++)
			{
				int $top = ($regions[$curRegion*4+2]);
				int $right = ($regions[$curRegion*4+1]-1);
				if( $renderer == "mentalRay" || $renderer == "renderMan" || $renderer == "renderManRIS" || $renderer == "ifmIrayPhotoreal" )
					$right++;
			
				int $left = ($regions[$curRegion*4]);
				int $bottom = ($regions[$curRegion*4+3]-1);
				if( $renderer == "mentalRay" || $renderer == "renderMan" || $renderer == "renderManRIS" )
						$bottom++;
				
				if($renderer == "arnold")
				{
					if( $right == $renderWidth )
						$right -=1;
					
					if( $bottom == $renderHeight )
						$bottom -=1;
				}	
				
				if(`size($regionLeftValues)` == $curRegion)
				{	 
					stringArrayInsertAtIndex($curRegion, $regionLeftValues, ""+$left);
					stringArrayInsertAtIndex($curRegion, $regionTopValues, ""+ $top);
					stringArrayInsertAtIndex($curRegion, $regionRightValues, ""+ $right);
					stringArrayInsertAtIndex($curRegion, $regionBottomValues, ""+ $bottom);
				}
				else
				{
					$regionLeftValues[$curRegion] = $regionLeftValues[$curRegion] +","+ $left;
					$regionTopValues[$curRegion] = $regionTopValues[$curRegion] +","+ $top;
					$regionRightValues[$curRegion] = $regionRightValues[$curRegion] +","+ $right;
					$regionBottomValues[$curRegion] = $regionBottomValues[$curRegion] +","+ $bottom;
				}
			}	
			
			for( $i=0; $i<size($regionLeftValues);$i++)
			{   
				setAttr defaultRenderGlobals.deadlineRegionLeft -type "string" ($regionLeftValues[$i]);
				setAttr defaultRenderGlobals.deadlineRegionTop -type "string" ($regionTopValues[$i]);
				setAttr defaultRenderGlobals.deadlineRegionRight -type "string" ($regionRightValues[$i]);
				setAttr defaultRenderGlobals.deadlineRegionBottom -type "string" ($regionBottomValues[$i]);
								
				setAttr defaultRenderGlobals.deadlineCurrTile $currTile;
				string $jobId = WriteJobFilesAndSubmit( $renderer, 0, 1, $MayaRenderJobType, $camera );
				if($jobId != "")
				{
					stringArrayInsertAtIndex(size($jobIdList),$jobIdList, $jobId) ;
					$submitCounter++;
				}
				$currTile++;
			}
			string $assemblyRegionLeftValues[];
			string $assemblyRegionRightValues[];
			string $assemblyRegionTopValues[];
			string $assemblyRegionBottomValues[];
			
			for($curRegion =0;$curRegion<$numRegions;$curRegion++)
			{
				int $assemblyTop = ($assemblyRegions[$curRegion*4+2]);
				int $assemblyRight = ($assemblyRegions[$curRegion*4+1]);
				int $assemblyLeft = ($assemblyRegions[$curRegion*4]);
				int $assemblyBottom = ($assemblyRegions[$curRegion*4+3]);
				stringArrayInsertAtIndex($curRegion, $assemblyRegionLeftValues, ""+$assemblyLeft);
				stringArrayInsertAtIndex($curRegion, $assemblyRegionTopValues, ""+ $assemblyTop);
				stringArrayInsertAtIndex($curRegion, $assemblyRegionRightValues, ""+ $assemblyRight);
				stringArrayInsertAtIndex($curRegion, $assemblyRegionBottomValues, ""+ $assemblyBottom);
			}
			
			string $regionString = stringArrayToString($assemblyRegionLeftValues,";");
			setAttr defaultRenderGlobals.deadlineRegionLeft -type "string" $regionString;
			$regionString = stringArrayToString($assemblyRegionTopValues,";");
			setAttr defaultRenderGlobals.deadlineRegionTop -type "string" $regionString;
			$regionString = stringArrayToString($assemblyRegionRightValues,";");
			setAttr defaultRenderGlobals.deadlineRegionRight -type "string" $regionString;
			$regionString = stringArrayToString($assemblyRegionBottomValues,";");
			setAttr defaultRenderGlobals.deadlineRegionBottom -type "string" $regionString;
			
			int $submitDependentJob = `checkBox -q -v frw_submitTileDependentJob`;
			if( $submitDependentJob && $submitCounter > 0 )
			{
				int $submitEachRenderLayer = IsRenderLayersOn() ? `checkBox -q -value frw_submitEachRenderLayer` : false;
				if( IsRenderLayersOn() && !$submitEachRenderLayer )
				{
					// Store the currently selected render layer
					string $currentRenderLayer = `editRenderLayerGlobals -query -currentRenderLayer`;
					string $renderLayerList[] = getRenderableRenderLayers(false);
					
					// Loop through the render layer if the checkbox is on
					for( $layer in $renderLayerList )
					{
						// Select the render layer to make sure the render settings are updated
						if( !catch(`editRenderLayerGlobals -currentRenderLayer $layer`) )
						{							
							if( $camera != "" )
							{
								int $count = SetupDependentJigsawAnimationAssemblerJob( $renderer, $jobIdList, $layer, $camera );
								$submitCounter += $count;
							}
							else
							{
								string $cameraNames[] = deadlineGetRenderableCameras( false );
								for( $cameraName in $cameraNames )
								{
									int $count = SetupDependentJigsawAnimationAssemblerJob( $renderer, $jobIdList, $layer, $cameraName );
									$submitCounter += $count;
								}
							}
						}
					}
					
					// Reselect the current render layer
					editRenderLayerGlobals -currentRenderLayer $currentRenderLayer;
				}
				else
				{					
					string $currentRenderLayer = "";
					if( IsRenderLayersOn() && $submitEachRenderLayer )
						$currentRenderLayer = `editRenderLayerGlobals -query -currentRenderLayer`;
					
					if( $camera != "" )
					{
						int $count = SetupDependentJigsawAnimationAssemblerJob( $renderer, $jobIdList, $currentRenderLayer, $camera );
						$submitCounter += $count;
					}
					else
					{
						string $cameraNames[] = deadlineGetRenderableCameras( false );
						for( $cameraName in $cameraNames )
						{
							int $count = SetupDependentJigsawAnimationAssemblerJob( $renderer, $jobIdList, $currentRenderLayer, $cameraName );
							$submitCounter += $count;
						}
					}
				}
			}

		}
	}
	else
	{
		setAttr defaultRenderGlobals.deadlineRegionSingleLeft -type "string" "";
		setAttr defaultRenderGlobals.deadlineRegionSingleTop -type "string" "";
		setAttr defaultRenderGlobals.deadlineRegionSingleRight -type "string" "";
		setAttr defaultRenderGlobals.deadlineRegionSingleBottom -type "string" "";
		
		if($regionType == $TileRegionRenderType)
		{
			if($tilesInX * $tilesInY > $taskLimit)
			{
				confirmDialog -parent $DeadlineSubmitterWindow -title "Submission Results" -message ("Unable to submit job with " + ($tilesInX * $tilesInY) + " tasks.  Task Count exceeded Job Task Limit of "+$taskLimit) -button "Close";
				return 0;
			}
		
			for( $y = 1; $y <= $tilesInY; $y++ )
			{
				for( $x = 1; $x <= $tilesInX; $x++ )
				{
					int $newY = $y;
					if( IsRegionRenderingInverted( $renderer ) )
						$newY = $tilesInY - $y + 1;
					
					string $regionSingleLeft = `getAttr defaultRenderGlobals.deadlineRegionSingleLeft`;
					$regionSingleLeft += "RegionLeft" + $currTile + "=" + ($deltaX * ( $x - 1 )) + "\n";
					setAttr defaultRenderGlobals.deadlineRegionSingleLeft -type "string" $regionSingleLeft;
					
					string $regionSingleTop = `getAttr defaultRenderGlobals.deadlineRegionSingleTop`;
					$regionSingleTop += "RegionTop" + $currTile + "=" + ($deltaY * ( $newY - 1 )) + "\n";
					setAttr defaultRenderGlobals.deadlineRegionSingleTop -type "string" $regionSingleTop;
					
					int $tempRight;
					if( $x == $tilesInX )
						$tempRight = $width - 1;
					else
						$tempRight = ($deltaX * $x) - 1;
					
					if( $renderer == "mentalRay" || $renderer == "renderMan" || $renderer == "renderManRIS" || $renderer == "ifmIrayPhotoreal" )
						$tempRight++;
					
					string $regionSingleRight = `getAttr defaultRenderGlobals.deadlineRegionSingleRight`;
					$regionSingleRight += "RegionRight" + $currTile + "=" + $tempRight + "\n";
					setAttr defaultRenderGlobals.deadlineRegionSingleRight -type "string" $regionSingleRight;
					
					int $tempBottom;
					if( $newY == $tilesInY )
						$tempBottom = $height - 1;
					else
						$tempBottom = ($deltaY * $newY) - 1;
					
					if( $renderer == "mentalRay" || $renderer == "renderMan" || $renderer == "renderManRIS"|| $renderer == "ifmIrayPhotoreal" )
						$tempBottom++;
					
					string $regionSingleBottom = `getAttr defaultRenderGlobals.deadlineRegionSingleBottom`;
					$regionSingleBottom += "RegionBottom" + $currTile + "=" + $tempBottom + "\n";
					setAttr defaultRenderGlobals.deadlineRegionSingleBottom -type "string" $regionSingleBottom;
										
					$currTile++;
				}
			}
		}
		else
		{   
			if(catchQuiet(`python("jigsawThread.isAlive()")`))
			{
				confirmDialog -title "Jigsaw Rendering" -message "In order to submit Jigsaw renders the Jigsaw window must be open." -button "OK" -defaultButton "OK";
				return 0;
			}
			
			if(`python("jigsawThread.isAlive()")`)
			{
				python("jigsawThread.requestSave()");
				int $invert = IsRegionRenderingInverted( $renderer );
				$regions = `python("jigsawThread.getRegions(" + $invert + ")")`;
				$assemblyRegions = `python("jigsawThread.getRegions()")`;
			}
			else
			{
				confirmDialog -title "Jigsaw Rendering" -message "In order to submit Jigsaw renders the Jigsaw window must be open." -button "OK" -defaultButton "OK";
				return 0;
			}
			
			if(size($regions)/4 > $taskLimit)
			{
				confirmDialog -parent $DeadlineSubmitterWindow -title "Submission Results" -message ("Unable to submit job with " + (size($regions)/4) + " tasks.  Task Count exceeded Job Task Limit of "+$taskLimit) -button "Close";
				return 0;
			}
			
			int $renderHeight = `getAttr "defaultResolution.height"`;
			for( $i=0; $i<size($regions)/4;$i++)
			{
				int $tempRight = ($regions[$i*4+1]-1);
				if( $renderer == "mentalRay" || $renderer == "renderMan" || $renderer == "renderManRIS" || $renderer == "ifmIrayPhotoreal" )
					$tempRight++;
				
				int $tempBottom = ($regions[$i*4+3]-1);
				if( $renderer == "mentalRay" || $renderer == "renderMan" || $renderer == "renderManRIS" || $renderer == "ifmIrayPhotoreal" )
						$tempBottom++;
				
				string $regionSingleLeft = `getAttr defaultRenderGlobals.deadlineRegionSingleLeft`;
				$regionSingleLeft += "RegionLeft" + $currTile + "=" + ($regions[$i*4]) + "\n";
				setAttr defaultRenderGlobals.deadlineRegionSingleLeft -type "string" $regionSingleLeft;
				
				string $regionSingleRight = `getAttr defaultRenderGlobals.deadlineRegionSingleRight`;
				$regionSingleRight += "RegionRight" + $currTile + "=" + $tempRight + "\n";
				setAttr defaultRenderGlobals.deadlineRegionSingleRight -type "string" $regionSingleRight;
				
				string $regionSingleTop = `getAttr defaultRenderGlobals.deadlineRegionSingleTop`;
				$regionSingleTop += "RegionTop" + $currTile + "=" + ($regions[$i*4+2]) + "\n";
				setAttr defaultRenderGlobals.deadlineRegionSingleTop -type "string" $regionSingleTop;
				
				string $regionSingleBottom = `getAttr defaultRenderGlobals.deadlineRegionSingleBottom`;
				$regionSingleBottom += "RegionBottom" + $currTile + "=" + $tempBottom + "\n";
				setAttr defaultRenderGlobals.deadlineRegionSingleBottom -type "string" $regionSingleBottom;
				
				$currTile++;
			}
		}
		
		setAttr defaultRenderGlobals.deadlineRegionSingleTiles $currTile;
		
		string $jobId = WriteJobFilesAndSubmit( $renderer, 0, 1, $MayaRenderJobType, $camera );
		if( $jobId != "" )
		{
			stringArrayInsertAtIndex(size($jobIdList),$jobIdList, $jobId);
			$submitCounter++;
		}
		
		int $submitDependentJob = `checkBox -q -v frw_submitTileDependentJob`;
		if( $submitDependentJob && $submitCounter > 0 )
		{
			int $frameNumber = `intSliderGrp -q -v frw_tileSingleFrame`;
			
			int $submitEachRenderLayer = IsRenderLayersOn() ? `checkBox -q -value frw_submitEachRenderLayer` : false;
			if( IsRenderLayersOn() && !$submitEachRenderLayer )
			{
				// Store the currently selected render layer
				string $currentRenderLayer = `editRenderLayerGlobals -query -currentRenderLayer`;
				string $renderLayerList[] = getRenderableRenderLayers(false);
				
				// Loop through the render layer if the checkbox is on
				for( $layer in $renderLayerList )
				{
					// Select the render layer to make sure the render settings are updated
					if( !catch(`editRenderLayerGlobals -currentRenderLayer $layer`) )
					{
						if( $camera != "" )
						{
							if($regionType == $TileRegionRenderType)
							{
								int $count = SetupDependentTileAssemblerJob( $renderer, $jobIdList, $frameNumber, $tilesInX, $tilesInY, $layer, $camera );
								$submitCounter += $count;
							}
							else
							{
								
								int $count = SetupDependentJigsawAssemblerJob( $renderer, $jobIdList, $frameNumber, $assemblyRegions, $layer, $camera );
								$submitCounter += $count;
							}
						}
						else
						{
							
							string $cameraNames[] = deadlineGetRenderableCameras( false );
							for( $cameraName in $cameraNames )
							{
								string $outputPrefix = CheckSlashes( GetOutputPrefix( 1, $frameNumber, $layer, $cameraName, "" ) );
								
								if($regionType == $TileRegionRenderType)
								{
									int $count = SetupDependentTileAssemblerJob( $renderer, $jobIdList, $frameNumber, $tilesInX, $tilesInY, $layer, $cameraName );
									$submitCounter += $count;
								}
								else
								{
									int $count = SetupDependentJigsawAssemblerJob( $renderer, $jobIdList, $frameNumber, $assemblyRegions, $layer, $cameraName );
									$submitCounter += $count;
								}
							}
						}
					}
				}
				
				// Reselect the current render layer
				editRenderLayerGlobals -currentRenderLayer $currentRenderLayer;
			}
			else
			{				
				string $currentRenderLayer = "";
				if( IsRenderLayersOn() && $submitEachRenderLayer )
					$currentRenderLayer = `editRenderLayerGlobals -query -currentRenderLayer`;
				
				if( $camera != "" )
				{
					if($regionType == $TileRegionRenderType)
					{
						int $count = SetupDependentTileAssemblerJob( $renderer, $jobIdList, $frameNumber, $tilesInX, $tilesInY, $currentRenderLayer, $camera );
						$submitCounter += $count;
					}
					else
					{
						int $count = SetupDependentJigsawAssemblerJob( $renderer, $jobIdList, $frameNumber, $assemblyRegions, $currentRenderLayer, $camera );
						$submitCounter += $count;
					}
				}
				else
				{
					string $cameraNames[] = deadlineGetRenderableCameras( false );
					for( $cameraName in $cameraNames )
					{
						string $outputPrefix = CheckSlashes( GetOutputPrefix( 1, $frameNumber, $currentRenderLayer, $cameraName, "") );
						if($regionType == $TileRegionRenderType)
						{
							int $count = SetupDependentTileAssemblerJob( $renderer, $jobIdList, $frameNumber, $tilesInX, $tilesInY, $currentRenderLayer, $cameraName );
							$submitCounter += $count;
						}
						else
						{
							int $count = SetupDependentJigsawAssemblerJob( $renderer, $jobIdList, $frameNumber, $assemblyRegions, $currentRenderLayer, $cameraName );
							$submitCounter += $count;
						}
					}
				}
			}
		}
	}
	return $submitCounter;
}

proc int SetupMentalRayExportJob( string $renderer )
{
	global int $MentalRayExportJobType;
	
	int $submitCounter = 0;
	
	string $jobId = WriteJobFilesAndSubmit( $renderer, 0, 0, $MentalRayExportJobType, "" );
	
	$submitCounter++;
		
	int $submitDependentJob = `checkBox -q -v frw_submitMentalRayJob`;
	if( $submitDependentJob )
	{
		string $frameList = `textFieldGrp -q -text frw_FrameList`;
		string $outputFilePath = CheckSlashes( `textFieldGrp -q -text frw_outputFilePath` );
		
		int $perlayer = `checkBoxGrp -query -value1 MayatomrExport_FilePerLayer`;
		int $perframe = `checkBoxGrp -query -value1 MayatomrExport_FilePerFrame`;
		int $padframe = 0;
		int $format = 0;
		if( $perframe )
		{
			$format = `optionMenuGrp -q -select MayatomrExport_FrameExtension`;
			$padframe = `intFieldGrp -q -value1 MayatomrExport_FramePadding`;
			if ($padframe > 9)
				$padframe = 9;
		}
		
		string $inputPath = CheckSlashes( `textFieldGrp -q -text frw_mentalRayFilePath` );
		string $inputDirectory = dirname( $inputPath ) + "/";
		string $inputFilename = basenameEx( $inputPath );
		string $inputExtension = fileExtension( $inputPath );
		
		string $padding = "";
		if( $perframe )
		{
			$padding = match( "[0-9]+", $frameList );
			while( size($padding) < $padframe )
				$padding = "0" + $padding;
		}
		
		
		string $renderLayerList[] = getRenderableRenderLayers(false);
		for( $i = 0; $i < size( $renderLayerList ); $i++ )
		{
			string $jobName = `textFieldGrp -q -text frw_JobName`;
			
			if( $perlayer )
			{
					$jobName = $jobName + " - " + $renderLayerList[$i];
			}
			
			string $tempDir = CallDeadlineCommand( "-GetCurrentUserHomeDirectory", false ) + "/temp";
			
			string $submitFilename = CheckSlashes( $tempDir + "/mr_deadline_info.job" );
			$fileId = `fopen $submitFilename "w"`;
			if( $fileId == 0 )
				print( "Error in Deadline Submission Script: could not create " + $submitFilename + "\n" );
			
			fprint $fileId ( "Plugin=MentalRay\n" );
			fprint $fileId ( "Name=" + $jobName + "\n" );
			fprint $fileId ( "BatchName=" + `textFieldGrp -q -text frw_JobName` + "\n" );
			fprint $fileId ( "Comment=" + `textFieldGrp -q -text frw_JobComment` + "\n" );
			fprint $fileId ( "Pool=" + `optionMenuGrp -q -value frw_deadlineMentalPool` + "\n" );
			fprint $fileId ( "SecondaryPool=" + `optionMenuGrp -q -value frw_deadlineMentalSecondaryPool` + "\n" );
			fprint $fileId ( "Priority=" + `intSliderGrp -q -v frw_MentalJobPriority` + "\n" );
			fprint $fileId ( "OnJobComplete=" + `optionMenuGrp -q -value frw_MentalOnComplete` + "\n" );
			fprint $fileId ( "TaskTimeoutMinutes=" + `intSliderGrp -q -v frw_MentalSlaveTimeout` + "\n" );
			fprint $fileId ( "MinRenderTimeMinutes=" + `intSliderGrp -q -v frw_MentalMinSlaveTimeout` + "\n" );
			fprint $fileId ( "ConcurrentTasks=" + `intSliderGrp -q -v frw_MentalConcurrentTasks` + "\n" );
			fprint $fileId ( "Department=" + `textFieldGrp -q -text frw_Department` + "\n" );
			fprint $fileId ( "Group=" + `optionMenuGrp -q -value frw_MentalGroup` + "\n" );
			fprint $fileId ( "MachineLimit=" + `intSliderGrp -q -v frw_MentalLimitCount` + "\n" );
			fprint $fileId ( "LimitGroups=" + `textFieldGrp -q -text frw_MentalLimitGroups` + "\n" );
			fprint $fileId ( "OutputDirectory0=" + $outputFilePath + "\n" );
			fprint $fileId ( "JobDependencies=" + $jobId + "\n" );
			fprint $fileId ( "Frames=" + $frameList + "\n" );
			fprint $fileId ( "ChunkSize=1\n" );
			
			if( `checkBox -q -value frw_MentalIsBlacklist` )
				fprint $fileId ( "Blacklist=" + `textFieldGrp -q -text frw_MentalMachineList` + "\n" );
			else
				fprint $fileId ( "Whitelist=" + `textFieldGrp -q -text frw_MentalMachineList` + "\n" );
			
			fclose $fileId;
			
			$layer = "";
			
			// The layer name is only appended if there is more than one layer in the list.
			if( $perlayer && IsRenderLayersOn() )
			{
				// If the layer is the defaultRenderLayer, it will actually be saved with masterLayer in the name
				if( `gmatch $renderLayerList[$i] "defaultRenderLayer"` == 1 )
					$layer = "_masterLayer";
				else
					$layer = "_" + $renderLayerList[$i];
			}
			
			if( $perframe )
			{
				if( $format == 1 )
					$inputPath = $inputDirectory + $inputFilename + $layer + "." + $inputExtension + "." + $padding;
				else if( $format == 2 )
					$inputPath = $inputDirectory + $inputFilename + $layer + "." + $padding + "." + $inputExtension;
				else
					$inputPath = $inputDirectory + $inputFilename + $layer + "." + $padding;
			}
			else
				$inputPath = $inputDirectory + $inputFilename + $layer + "." + $inputExtension;
			
			string $jobFilename = CheckSlashes( $tempDir + "/mr_deadline_job.job" );
			$fileId = `fopen $jobFilename "w"`;
			if( $fileId == 0 )
				print( "Error in Deadline Submission Script: could not create " + $jobFilename + "\n" );
			
			fprint $fileId ( "InputFile=" + $inputPath + "\n" );
			fprint $fileId ( "SeparateFilesPerFrame=" + $perframe + "\n" );
			if( $perframe )
				fprint $fileId ( "StartFrameOffset=" + `intSliderGrp -q -v frw_mentalRayOffset` + "\n" );
			fprint $fileId ( "OutputPath=" + $outputFilePath + "\n" );
			fprint $fileId ( "Threads=" + `intSliderGrp -q -v frw_mentalRayThreads` + "\n" );
			fprint $fileId ( "LocalRendering=" + `checkBox -q -v frw_mentalRayLocalRendering` + "\n" );
			fprint $fileId ( "Build=" + `optionMenuGrp -q -value frw_mentalRayBuild` + "\n" );
			fprint $fileId ( "Verbose=5\n" );
			fprint $fileId ( "CommandLineOptions=" + `textFieldGrp -q -text frw_mentalRayArgs` + "\n" );
			fclose $fileId;
			
			string $argList[];
			$argList[0] = $submitFilename;
			$argList[1] = $jobFilename;
			
			// Submit the job to Deadline
			string $submissionCommandFile = CreateArgumentsFile( $argList );
			string $submitResults = CallDeadlineCommand( "\"" + $submissionCommandFile + "\"", true );
			
			// Show results
			print( "\n\nSubmission Results For Job " + $jobName + ":\n---------------------------------------------------------------------------\n" + $submitResults + "\n" );
			
			$submitCounter++;
			
			if( !$perlayer )
				break;
		}
	}
	
	return $submitCounter;
}

proc int SubmitDependentVRayJob( string $postfix, string $jobId )
{
	int $submitCounter = 0;
	
	int $submitLayers = false;
	string $currentRenderLayer = "";
	string $renderLayerList[] = {""};
	
	if( IsRenderLayersOn() )
	{
		$currentRenderLayer = `editRenderLayerGlobals -query -currentRenderLayer`;
		$renderLayerList = getRenderableRenderLayers(false);
		$submitLayers = true;
	}
	
	for( $layer in $renderLayerList )
	{
		string $jobName = `textFieldGrp -q -text frw_JobName`;
		if( $postfix != "" )
			$jobName = $jobName + " (" + $postfix + ")";
		
		int $perframe = `getAttr( "vraySettings.misc_eachFrameInFile" )`;
		string $frameList = `textFieldGrp -q -text frw_FrameList`;
		
		string $outputFilePath = CheckSlashes( `textFieldGrp -q -text frw_outputFilePath` );
		string $outputPrefix = CheckSlashes( GetOutputPrefix( 0, 0, "", "", "" ) );
		string $outputFilename = CheckSlashes( $outputFilePath  + "/" + $outputPrefix );
		
		string $inputPath = CheckSlashes( `textFieldGrp -q -text frw_vrayFilePath` );
		string $inputDirectory = dirname( $inputPath ) + "/";
		string $inputFilename = basenameEx( $inputPath );
		string $inputPadding = "";
		string $inputExtension = fileExtension( $inputPath );
		if( $inputExtension == "" )
			$inputExtension = "vrscene";
		
		if( $perframe )
			$inputPadding = "_0000";
		if( $postfix != "" )
			$inputFilename = $inputFilename + "_" + $postfix;
		
		if( $submitLayers )
		{
			// Select the render layer to make sure the render settings are updated
			if( catch(`editRenderLayerGlobals -currentRenderLayer $layer`) )
				continue;
			
			string $renderLayerName = $layer;
			if( `gmatch $renderLayerName "defaultRenderLayer"` == 1 )
				$renderLayerName = "masterLayer";
			
			$jobName = $jobName + " - " + $renderLayerName;
			$inputFilename = $inputFilename + "_" + $renderLayerName;
		}
	
		$inputPath = $inputDirectory + $inputFilename + $inputPadding + "." + $inputExtension;
		
		string $tempDir = CallDeadlineCommand( "-GetCurrentUserHomeDirectory", false ) + "/temp";
		
		string $submitFilename = CheckSlashes( $tempDir + "/vray_deadline_info.job" );
		$fileId = `fopen $submitFilename "w"`;
		if( $fileId == 0 )
			print( "Error in Deadline Submission Script: could not create " + $submitFilename + "\n" );
		
		fprint $fileId ( "Plugin=Vray\n" );
		fprint $fileId ( "Name=" + $jobName + "\n" );
		string $batchName = `textFieldGrp -q -text frw_JobName`;
		//This will group the jobs created later in the same batch
		fprint $fileId ( "BatchName=" + $batchName + "\n" );
		fprint $fileId ( "Comment=" + `textFieldGrp -q -text frw_JobComment` + "\n" );
		fprint $fileId ( "Pool=" + `optionMenuGrp -q -value frw_deadlineVrayPool` + "\n" );
		fprint $fileId ( "SecondaryPool=" + `optionMenuGrp -q -value frw_deadlineVraySecondaryPool` + "\n" );
		fprint $fileId ( "Priority=" + `intSliderGrp -q -v frw_VrayJobPriority` + "\n" );
		fprint $fileId ( "TaskTimeoutMinutes=" + `intSliderGrp -q -v frw_VraySlaveTimeout` + "\n" );
		fprint $fileId ( "MinRenderTimeMinutes=" + `intSliderGrp -q -v frw_VrayMinSlaveTimeout` + "\n" );
		fprint $fileId ( "ConcurrentTasks=" + `intSliderGrp -q -v frw_VrayConcurrentTasks` + "\n" );
		fprint $fileId ( "OnJobComplete=" + `optionMenuGrp -q -value frw_VrayOnComplete` + "\n" );
		fprint $fileId ( "Department=" + `textFieldGrp -q -text frw_Department` + "\n" );
		fprint $fileId ( "Group=" + `optionMenuGrp -q -value frw_VrayGroup` + "\n" );
		fprint $fileId ( "MachineLimit=" + `intSliderGrp -q -v frw_VrayLimitCount` + "\n" );
		fprint $fileId ( "LimitGroups=" + `textFieldGrp -q -text frw_VrayLimitGroups` + "\n" );
		//fprint $fileId ( "OutputDirectory0=" + $outputFilePath + "\n" );
		fprint $fileId ( "OutputFilename0=" + $outputFilename + "\n" );
		fprint $fileId ( "JobDependencies=" + $jobId + "\n" );
		fprint $fileId ( "Frames=" + $frameList + "\n" );
		fprint $fileId ( "ChunkSize=1\n" );
		
		if( `checkBox -q -value frw_VrayIsBlacklist` )
			fprint $fileId ( "Blacklist=" + `textFieldGrp -q -text frw_VrayMachineList` + "\n" );
		else
			fprint $fileId ( "Whitelist=" + `textFieldGrp -q -text frw_VrayMachineList` + "\n" );
		
		fclose $fileId;
		
		string $jobFilename = CheckSlashes( $tempDir + "/vray_deadline_job.job" );
		$fileId = `fopen $jobFilename "w"`;
		if( $fileId == 0 )
			print( "Error in Deadline Submission Script: could not create " + $jobFilename + "\n" );
		
		fprint $fileId ( "InputFilename=" + $inputPath + "\n" );
		fprint $fileId ( "SeparateFilesPerFrame=" + $perframe + "\n" );
		fprint $fileId ( "Threads=" + `intSliderGrp -q -v frw_vrayThreads` + "\n" );
		fprint $fileId ( "Width=0\n" );
		fprint $fileId ( "Height=0\n" );
		//fprint $fileId ( "OutputFilename=" + $outputFilePath + "\n" );
		fclose $fileId;
		
		string $argList[] ;
		$argList[0] = $submitFilename;
		$argList[1] = $jobFilename;
		
		// Submit the job to Deadline
		string $submissionCommandFile = CreateArgumentsFile( $argList );
		string $submitResults = CallDeadlineCommand( "\"" + $submissionCommandFile + "\"", true );
				
		$submitCounter++;
		
		// Show results
		print( "\n\nSubmission Results For Job " + $jobName + ":\n---------------------------------------------------------------------------\n" + $submitResults + "\n" );
		
		int $submitDependentJob = `checkBox -q -v frw_submitVRayJob`;
		if( `checkBox -q -v frw_submitVrimg2ExrJob` && $submitDependentJob  )
		{
			if( fileExtension( $outputFilename ) == "vrimg" )
			{
				string $convertJobId = "";
				string $jobIdRegEx = "[a-z,A-Z,0-9]+_[0-9]+_[a-z,A-Z,0-9]+_[0-9,a-f,A-F]+";
				$matches = `match $jobIdRegEx $submitResults`;
				if( size( $matches ) > 0 )
					$convertJobId = $matches;
				
				string $vrimgPrefix = CheckSlashes( GetOutputPrefix( 1, 0, "", "", "" ) );
				string $inputVrimgFilename = CheckSlashes( $outputFilePath  + "/" + $vrimgPrefix );
				
				string $outputExrDirectory = dirname( $inputVrimgFilename );
				string $outputExrPrefix = basename( CheckSlashes( GetOutputPrefix( 0, 0, "", "", "" ) ), ".vrimg" );
				string $outputExrFilename = CheckSlashes( $outputExrDirectory  + "/" + $outputExrPrefix + ".exr" );
				
				$jobName = $jobName + " - Conversion Job";
				
				string $convertSubmitFilename = CheckSlashes( $tempDir + "/vrimg_deadline_info.job" );
				$fileId = `fopen $convertSubmitFilename "w"`;
				if( $fileId == 0 )
					print( "Error in Deadline Submission Script: could not create " + $convertSubmitFilename + "\n" );
				
				fprint $fileId ( "Plugin=Vrimg2Exr\n" );
				fprint $fileId ( "Name=" + $jobName + "\n" );
				fprint $fileId ( "BatchName=" + `textFieldGrp -q -text frw_JobName` + "\n" );
				fprint $fileId ( "Comment=" + `textFieldGrp -q -text frw_JobComment` + "\n" );
				fprint $fileId ( "Department=" + `textFieldGrp -q -text frw_Department` + "\n" );
				fprint $fileId ( "Pool=" + `optionMenuGrp -q -value frw_deadlineVrayPool` + "\n" );
				fprint $fileId ( "SecondaryPool=" + `optionMenuGrp -q -value frw_deadlineVraySecondaryPool` + "\n" );
				fprint $fileId ( "Group=" + `optionMenuGrp -q -value frw_VrayGroup` + "\n" );
				fprint $fileId ( "Priority=" + `intSliderGrp -q -v frw_VrayJobPriority` + "\n" );
				fprint $fileId ( "LimitGroups=" + `textFieldGrp -q -text frw_VrayLimitGroups` + "\n" );
				fprint $fileId ( "OnJobComplete=" + `optionMenuGrp -q -value frw_VrayOnComplete` + "\n" );
				fprint $fileId ( "MachineLimit=" + `intSliderGrp -q -v frw_VrayLimitCount` + "\n" );
				fprint $fileId ( "Frames=" + $frameList + "\n" );
				fprint $fileId ( "ChunkSize=1\n" );
				fprint $fileId ( "OutputFilename0=" + $outputExrFilename + "\n" );
				fprint $fileId ( "JobDependencies=" + $convertJobId + "\n" );
				
				if( `checkBox -q -value frw_VrayIsBlacklist` )
					fprint $fileId ( "Blacklist=" + `textFieldGrp -q -text frw_VrayMachineList` + "\n" );
				else
					fprint $fileId ( "Whitelist=" + `textFieldGrp -q -text frw_VrayMachineList` + "\n" );
				
				fclose $fileId;
				
				string $convertPluginFilename = CheckSlashes( $tempDir + "/vrimg_plugin_info.job" );
				$fileId = `fopen $convertPluginFilename "w"`;
				if( $fileId == 0 )
					print( "Error in Deadline Submission Script: could not create " + $convertPluginFilename + "\n" );
				
				fprint $fileId ( "InputFile=" + $inputVrimgFilename + "\n" );
				fprint $fileId ( "OutputFile=\n" );
				fprint $fileId ( "Half=False\n" );
				fprint $fileId ( "sRGB=False\n" );
				fprint $fileId ( "DataWindow=True\n" );
				fprint $fileId ( "SeparateFiles=False\n" );
				fprint $fileId ( "MultiPart=False\n" );
				fprint $fileId ( "SetGamma=False\n" );
				fprint $fileId ( "Gamma=1.8\n" );
				fprint $fileId ( "SetChannel=False\n" );
				fprint $fileId ( "Channel=\n" );
				fprint $fileId ( "LongChanNames=False\n" );
				fprint $fileId ( "SetCompression=False\n" );
				fprint $fileId ( "Compression=zip\n" );
				fprint $fileId ( "SetBufferSize=False\n" );
				fprint $fileId ( "BufferSize=10\n" );
				fprint $fileId ( "Threads=0\n" );
				
				if( `checkBox -q -v frw_deleteVrimgFiles` )
					fprint $fileId ( "DeleteInputFiles=True\n" );
				else
					fprint $fileId ( "DeleteInputFiles=False\n" );
				
				fclose $fileId;
				
				// Submit the job to Deadline
				string $convertSubmissionCommand = "\"" + $convertSubmitFilename + "\" \"" + $convertPluginFilename + "\"";
				string $convertSubmitResults = CallDeadlineCommand( $convertSubmissionCommand, true );
				
				// Show results
				print( "\n\nSubmission Results For Job " + $jobName + ":\n---------------------------------------------------------------------------\n" + $convertSubmitResults + "\n" );
				
				$submitCounter++;
			}
			else
				print( "\n\nWARNING: Vrimg2Exr job not submitted because output format is not vrimg\n" );
		}
	}
	
	if( $submitLayers )
	{
		// Reselect the current render layer
		editRenderLayerGlobals -currentRenderLayer $currentRenderLayer;
	}
	
	return $submitCounter;
}

proc int SetupVRayExportJob( string $renderer )
{
	global int $VRayExportJobType;
	
	int $submitCounter = 0;
	
	//string $jobId = WriteJobFilesAndSubmit( $renderer, 0, 0, 0, 1, 0, "" );
	string $jobId = WriteJobFilesAndSubmit( $renderer, 0, 0, $VRayExportJobType, "" );
	
	$submitCounter++;
		
	int $submitDependentJob = `checkBox -q -v frw_submitVRayJob`;
	if( $submitDependentJob )
	{
		// Dependent job does not support the Separate Files option.
		if( !`getAttr( "vraySettings.misc_separateFiles" )` )
		{
			$submitCounter = $submitCounter + SubmitDependentVRayJob( "", $jobId );
		}
		
		//~ SubmitDependentVRayJob( "", $jobId );
		//~ $submitCounter++;
		
		//~ if( `getAttr( "vraySettings.misc_separateFiles" )` )
		//~ {
			//~ int $exportLights = `getAttr( "vraySettings.misc_exportLights" )`;
			//~ if( $exportLights )
			//~ {
				//~ SubmitDependentVRayJob( "lights", $jobId );
				//~ $submitCounter++;
			//~ }
			
			//~ int $exportNodes = `getAttr( "vraySettings.misc_exportNodes" )`;
			//~ if( $exportNodes )
			//~ {
				//~ SubmitDependentVRayJob( "nodes", $jobId );
				//~ $submitCounter++;
			//~ }
			
			//~ int $exportGeometry = `getAttr( "vraySettings.misc_exportGeometry" )`;
			//~ if( $exportGeometry )
			//~ {
				//~ $submitCounter++;
				//~ SubmitDependentVRayJob( "geometry", $jobId );
			//~ }
			
			//~ int $exportMaterials = `getAttr( "vraySettings.misc_exportMaterials" )`;
			//~ if( $exportMaterials )
			//~ {
				//~ SubmitDependentVRayJob( "materials", $jobId );
				//~ $submitCounter++;
			//~ }
			
			//~ int $exportTextures = `getAttr( "vraySettings.misc_exportTextures" )`;
			//~ if( $exportTextures )
			//~ {
				//~ SubmitDependentVRayJob( "textures", $jobId );
				//~ $submitCounter++;
			//~ }
			
			//~ int $exportBitmaps = `getAttr( "vraySettings.misc_exportBitmaps" )`;
			//~ if( $exportBitmaps )
			//~ {
				//~ SubmitDependentVRayJob( "bitmaps", $jobId );
				//~ $submitCounter++;
			//~ }
		//~ }
	}
	
	return $submitCounter;
}

proc int SetupArnoldKickRegionJob(string $jobId, string $camera, string $renderLayer)
{
	global int $PreviousImageCompType;
	global int $SelectedImageCompType;

	global int $TileRegionRenderType;
	global int $JigsawRegionRenderType;
	
	print("Start Arnold Kick Region Job");
	string $jobName = `textFieldGrp -q -text frw_JobName`;
	string $batchName = `textFieldGrp -q -text frw_JobName`;
	string $frameList = `textFieldGrp -q -text frw_FrameList`;
	
	int $submitEachRenderLayer = IsRenderLayersOn() ? `checkBox -q -value frw_submitEachRenderLayer` : false;
	$overrideLayerSettings = `checkBox -q -value frw_overrideLayerSettings`;
	if( $submitEachRenderLayer )
	{		
		if($overrideLayerSettings)
		{
			$field = "frw_FrameList_" + $renderLayer;
			$frameList = `textFieldGrp -q -text $field`;
		}
		else
		{
			int $range[] = GetFrameRange();
			int $fromFrame = $range[0];
			int $toFrame = $range[1];
			int $byFrame = $range[2];
			
			$frameList = $fromFrame + "-" + $toFrame;
			if( $byFrame > 1 )
				$frameList = $frameList + "x" + $byFrame;
		}
	}
	
	int $frameRange[] = GetFramesArray($frameList);
	
	int $submitDependentJob = `checkBox -q -v frw_submitTileDependentJob`;
	
	int $submissionCount = 0;
	
	int $singleRegionJob = `checkBox -q -v frw_submitTileSingleJob`;
	string $projectPath = `textFieldGrp -q -text frw_projectPath`;
	string $assExportFolder = `workspace -fre "ASS"`;
	if( $assExportFolder == "" )
		$assExportFolder = "data";
	
	string $outputFilePath = CheckSlashes( `textFieldGrp -q -text frw_outputFilePath` );
	string $assFileName = GetStrippedSceneFileName();
	
	int $exportLocal = `checkBox -q -v frw_exportArnoldLocal`;
	
	int $renderHeight = `getAttr "defaultResolution.height"`;
	int $renderWidth = `getAttr "defaultResolution.width"`;
	
	int $tilesInX = `intSliderGrp -q -v frw_tilesInX`;
	int $tilesInY = `intSliderGrp -q -v frw_tilesInY`;
	
	int $regions[];
	int $assemblyRegions[];
	int $regionType = `optionMenuGrp -q -select frw_regionRenderType`;
	if($regionType == $TileRegionRenderType)
	{
		for( $y = 1; $y <= $tilesInY; $y++ )
		{
			for( $x = 1; $x <= $tilesInX; $x++ )
			{
				$regions[size($regions)]= ($x-1)*($renderWidth/$tilesInX);
				$assemblyRegions[ size($assemblyRegions) ] = ($x-1)*($renderWidth/$tilesInX);
				$regions[size($regions)]= ($x)*($renderWidth/$tilesInX);
				$assemblyRegions[ size($assemblyRegions) ] = ($x)*($renderWidth/$tilesInX);
				$regions[size($regions)]= ($y-1)*($renderHeight/$tilesInY);
				$assemblyRegions[ size($assemblyRegions) ] = ($tilesInY - $y)*($renderHeight/$tilesInY);
				$regions[size($regions)]= ($y)*($renderHeight/$tilesInY);
				$assemblyRegions[ size($assemblyRegions) ] = ($tilesInY - $y + 1)*($renderHeight/$tilesInY);
			}
		}
	}
	else
	{
		if(catchQuiet(`python("jigsawThread.isAlive()")`))
		{
			confirmDialog -title "Jigsaw Rendering" -message "In order to submit Jigsaw renders the Jigsaw window must be open." -button "OK" -defaultButton "OK";
			return 0;
		}
		if(`python("jigsawThread.isAlive()")`)
		{
			python("jigsawThread.requestSave()");
			$regions = `python("jigsawThread.getRegions(False)")`;
			$assemblyRegions = `python("jigsawThread.getRegions(True)")`;
		}
		else
		{
			confirmDialog -title "Jigsaw Rendering" -message "In order to submit Jigsaw renders the Jigsaw window must be open." -button "OK" -defaultButton "OK";
			return 0;
		}
	}
	
	int $numRegions = size($regions)/4;
	
	int $ignoreOutFormatControl = false;
	if( `getAttr "defaultRenderGlobals.animation"` )
	{
		int $paddingSize = `getAttr "defaultRenderGlobals.extensionPadding"`;
		string $padding = "";
		while( size($padding) < $paddingSize )
			$padding = "0" + $padding;
			
		int $periodInExt = `getAttr "defaultRenderGlobals.periodInExt"`;
		int $putFrameBeforeExt = `getAttr "defaultRenderGlobals.putFrameBeforeExt"`;
			
		if( $periodInExt == 0 ) // name#.ext
		{
			$assFileName += $padding;
		}
		else if( $periodInExt == 1 )
		{
			if( $putFrameBeforeExt ) // name.# or name.#.ext
			{
				$assFileName += "." + $padding;
			}
			else // name.ext.#
			{
				$assFileName += ".ass." + $padding;
				$ignoreOutFormatControl = true;
			}
		}
		else if( $periodInExt == 2 ) // name_#.ext
		{
			$assFileName += "_" + $padding;
		}
	}
	if( !$ignoreOutFormatControl && `getAttr "defaultRenderGlobals.outFormatControl"` == 0 )
		$assFileName += ".ass";
	
	string $inputPath = $projectPath + "/" + $assExportFolder + "/";
	
	if ( IsRenderLayersOn() )
	{
		string $layerName = $renderLayer;
		if( $renderLayer == "defaultRenderLayer" )
			$layerName = "masterLayer";
		$inputPath = $inputPath + $layerName + "/";
	}
		
	string $renderableCameras[] = deadlineGetRenderableCameras( false );
	int $multipleRenderableCams = ( size ( $renderableCameras ) > 1 );
	if ( $multipleRenderableCams )
		$inputPath = $inputPath + $camera + "/";
		
	$inputPath = $inputPath + CheckSlashes( $assFileName );
	
	string $tempDir = CallDeadlineCommand( "-GetCurrentUserHomeDirectory", false ) + "/temp";
	int $singleRegionFrame = `intSliderGrp -q -v frw_tileSingleFrame`;
	
	string $singleJobName = $jobName;
	// Append camera name to the job
	if( $camera != "" )
		$singleJobName += " - " + $camera;

	// Append render layer name to the job
	if( $renderLayer != "" )
		$singleJobName += " - " + $renderLayer;
	
	string $elements[] = getArnoldElements();
	string $elementNames[] = getArnoldElementNames();
	
	string $extension = fileExtension( GetOutputPrefix( 0, 0, "", "", "" ) );
	
	if($singleRegionJob)
	{
		string $submitFilename = CheckSlashes( $tempDir + "/arnold_deadline_info.job" );
		$fileId = `fopen $submitFilename "w"`;
		if( $fileId == 0 )
			print( "Error in Deadline Submission Script: could not create " + $submitFilename + "\n" );
			
		fprint $fileId ( "Plugin=Arnold\n" );
		fprint $fileId ( "Name=" + $singleJobName + " - Export\n" );
		
		if( !$exportLocal || $submitDependentJob )
			fprint $fileId ( "BatchName=" + $batchName + "\n" );

		fprint $fileId ( "Comment=" + `textFieldGrp -q -text frw_JobComment` + "\n" );
		fprint $fileId ( "Pool=" + `optionMenuGrp -q -value frw_deadlineArnoldPool` + "\n" );
		fprint $fileId ( "SecondaryPool=" + `optionMenuGrp -q -value frw_deadlineArnoldSecondaryPool` + "\n" );
		fprint $fileId ( "Priority=" + `intSliderGrp -q -v frw_ArnoldJobPriority` + "\n" );
		fprint $fileId ( "OnJobComplete=" + `optionMenuGrp -q -value frw_ArnoldOnComplete` + "\n" );
		fprint $fileId ( "TaskTimeoutMinutes=" + `intSliderGrp -q -v frw_ArnoldSlaveTimeout` + "\n" );
		fprint $fileId ( "MinRenderTimeMinutes=" + `intSliderGrp -q -v frw_ArnoldMinSlaveTimeout` + "\n" );
		fprint $fileId ( "ConcurrentTasks=" + `intSliderGrp -q -v frw_ArnoldConcurrentTasks` + "\n" );
		fprint $fileId ( "Department=" + `textFieldGrp -q -text frw_Department` + "\n" );
		fprint $fileId ( "Group=" + `optionMenuGrp -q -value frw_ArnoldGroup` + "\n" );
		fprint $fileId ( "MachineLimit=" + `intSliderGrp -q -v frw_ArnoldLimitCount` + "\n" );
		fprint $fileId ( "LimitGroups=" + `textFieldGrp -q -text frw_ArnoldLimitGroups` + "\n" );
		int $fileCount = 0;
		for( $element in $elementNames )
		{
			string $outputPrefix = CheckSlashes( GetOutputPrefix( 1, $singleRegionFrame, $renderLayer, $camera, $element ) );
			$outputPrefix = swapDeepExr( $outputPrefix );
			fprint $fileId ( "OutputFilename" + $fileCount + "=" + CheckSlashes( $outputFilePath + "/" + $outputPrefix ) + "\n" );
			$fileCount++;
		}
		fprint $fileId ( "JobDependencies=" + $jobId + "\n" );
		fprint $fileId ( "Frames=0-" + ($numRegions-1) + "\n" );
		fprint $fileId ( "ChunkSize=1\n" );
		
		if( `checkBox -q -value frw_ArnoldIsBlacklist` )
			fprint $fileId ( "Blacklist=" + `textFieldGrp -q -text frw_ArnoldMachineList` + "\n" );
		else
			fprint $fileId ( "Whitelist=" + `textFieldGrp -q -text frw_ArnoldMachineList` + "\n" );
		
		fclose $fileId;
		
		string $jobFilename = CheckSlashes( $tempDir + "/arnold_deadline_job.job" );
		$fileId = `fopen $jobFilename "w"`;
		if( $fileId == 0 )
			print( "Error in Deadline Submission Script: could not create " + $jobFilename + "\n" );
			
		fprint $fileId ( "InputFile=" + $inputPath + "\n" );
		fprint $fileId ( "Threads=" + `intSliderGrp -q -v frw_arnoldThreads` + "\n" );
		fprint $fileId ( "CommandLineOptions=" + `textFieldGrp -q -text frw_arnoldArgs` + "\n" );
		fprint $fileId ( "Verbose=4\n" );
		fprint $fileId ( "RegionJob=True\n" );
		fprint $fileId ( "SingleAss=True\n" );
		fprint $fileId ( "SingleRegionFrame="+$singleRegionFrame+"\n" );
		fprint $fileId ( "CommandLineOptions=" + `textFieldGrp -q -text frw_arnoldArgs` + "\n" );
		if( size($elements) > 0)
		{
			fprint $fileId ( "HasAOVs=True\n" );
			int $aovCount = 0;
			for( $curAOV in $elements )
			{
			
				string $aovName = `getAttr ($curAOV+".name")`;
				string $aovDriver[] = `listConnections ($curAOV+".outputs[0].driver")`;
				string $aovExtension = `getAttr ($aovDriver[0]+".aiTranslator")`;
				fprint $fileId ( "ASSAOV"+ $aovCount +"Name="+$aovDriver[0]+"@driver_"+$aovExtension+".RGBA."+$aovName+".filename\n" );
				$aovCount++;
			}
		}
		
		for($curRegion =0;$curRegion<$numRegions;$curRegion++)
		{
			int $top = ($regions[$curRegion*4+2]);
			int $right = ($regions[$curRegion*4+1]-1);
			int $left = ($regions[$curRegion*4]);
			int $bottom = ($regions[$curRegion*4+3]-1);

			if( $right == $renderWidth )
				$right -=1;
			if( $bottom == $renderHeight )
				$bottom -=1;
			
			fprint $fileId ( "RegionLeft"+$curRegion+"="+$left+"\n" );
			fprint $fileId ( "RegionTop"+$curRegion+"="+$top+"\n" );
			fprint $fileId ( "RegionRight"+$curRegion+"="+$right+"\n" );
			fprint $fileId ( "RegionBottom"+$curRegion+"="+$bottom+"\n" );
			
			int $elementCount = 0;
			for( $element in $elementNames )
			{
				string $outputPrefix = CheckSlashes( GetOutputPrefix( 1, $singleRegionFrame, $renderLayer, $camera, $element ) );
				$outputPrefix = swapDeepExr( $outputPrefix );
				$outputPrefix = GetJigsawOutputPrefix( $outputPrefix, $curRegion, "arnold" );
				if( $elementCount == 0)
				{
					fprint $fileId ( "RegionFilename"+$curRegion+"="+ CheckSlashes( $outputFilePath + "/" + $outputPrefix ) +"\n" );
				}
				else
				{
					fprint $fileId ( "AOV" + ( $elementCount - 1 ) + "Filename" + $curRegion + "=" + CheckSlashes( $outputFilePath + "/" + $outputPrefix )+"\n" );
				}
				$elementCount++;
			}
		}
		
		fclose $fileId;
			
		string $argList[] ;
		$argList[0] = $submitFilename;
		$argList[1] = $jobFilename;
		
		// Submit the job to Deadline
		string $submissionCommandFile = CreateArgumentsFile( $argList );
		string $submitResults = CallDeadlineCommand( "\"" + $submissionCommandFile + "\"", true );
			
		// Show results
		print( "\n\nSubmission Results For Job " + $jobName + ":\n---------------------------------------------------------------------------\n" + $submitResults + "\n" );
		// Get the job id to return
		string $jobId = "";
		string $resultArray[];
		$resultArray = stringToStringArray( $submitResults, "\n" );
		for( $n = 0; $n < size($resultArray); $n++ )
		{
			if( startsWith( $resultArray[$n], "JobID=" ) )
			{
				$jobId = substituteAllString( $resultArray[$n], "JobID=", "" );
				break;
			}
		}
		$submissionCount++;
		
		
		if($submitDependentJob)
		{
			string $dependentIds[] = {$jobId};
			$submissionCount += SetupDependentJigsawAssemblerJob("arnold", $dependentIds, $singleRegionFrame, $regions, $renderLayer, $camera);
		}
	}
	else
	{					   		
		string $jobIdList[];
		
		AddStringAttribute( "deadlineRegionLeft" );
		AddStringAttribute( "deadlineRegionTop" );
		AddStringAttribute( "deadlineRegionRight" );
		AddStringAttribute( "deadlineRegionBottom" );
		string $regionLeftValues[];
		string $regionRightValues[];
		string $regionTopValues[];
		string $regionBottomValues[];
		
		for($curRegion =0;$curRegion<$numRegions;$curRegion++)
		{
			string $submitFilename = CheckSlashes( $tempDir + "/arnold_deadline_info.job" );
			$fileId = `fopen $submitFilename "w"`;
			if( $fileId == 0 )
				print( "Error in Deadline Submission Script: could not create " + $submitFilename + "\n" );
				
			fprint $fileId ( "Plugin=Arnold\n" );
			fprint $fileId ( "Name=" + $singleJobName + " - Render - Region "+$curRegion+"\n" );
			
			if( !$exportLocal || $submitDependentJob )
				fprint $fileId ( "BatchName=" + $batchName + "\n" );
				
			fprint $fileId ( "Comment=" + `textFieldGrp -q -text frw_JobComment` + "\n" );
			fprint $fileId ( "Pool=" + `optionMenuGrp -q -value frw_deadlineArnoldPool` + "\n" );
			fprint $fileId ( "SecondaryPool=" + `optionMenuGrp -q -value frw_deadlineArnoldSecondaryPool` + "\n" );
			fprint $fileId ( "Priority=" + `intSliderGrp -q -v frw_ArnoldJobPriority` + "\n" );
			fprint $fileId ( "OnJobComplete=" + `optionMenuGrp -q -value frw_ArnoldOnComplete` + "\n" );
			fprint $fileId ( "TaskTimeoutMinutes=" + `intSliderGrp -q -v frw_ArnoldSlaveTimeout` + "\n" );
			fprint $fileId ( "MinRenderTimeMinutes=" + `intSliderGrp -q -v frw_ArnoldMinSlaveTimeout` + "\n" );
			fprint $fileId ( "ConcurrentTasks=" + `intSliderGrp -q -v frw_ArnoldConcurrentTasks` + "\n" );
			fprint $fileId ( "Department=" + `textFieldGrp -q -text frw_Department` + "\n" );
			fprint $fileId ( "Group=" + `optionMenuGrp -q -value frw_ArnoldGroup` + "\n" );
			fprint $fileId ( "MachineLimit=" + `intSliderGrp -q -v frw_ArnoldLimitCount` + "\n" );
			fprint $fileId ( "LimitGroups=" + `textFieldGrp -q -text frw_ArnoldLimitGroups` + "\n" );
			int $fileCount = 0;
			for( $element in $elementNames )
			{
				string $outputPrefix = CheckSlashes( GetOutputPrefix( 0, 0, $renderLayer, $camera, $element ) );
				$outputPrefix = swapDeepExr( $outputPrefix );
				fprint $fileId ( "OutputFilename" + $fileCount + "=" + CheckSlashes( $outputFilePath + "/" + $outputPrefix ) + "\n" );
				$fileCount++;
			}
			//fprint $fileId ( "OutputFilename0=" + $outputFilename + "\n" );
			
			fprint $fileId ( "JobDependencies=" + $jobId + "\n" );
			fprint $fileId ( "IsFrameDependent=true\n" ); // this can be enabled because arnold export jobs can be done across multiple machines
			fprint $fileId ( "Frames=" + $frameList + "\n" );
			fprint $fileId ( "ChunkSize=1\n" );
			
			if( `checkBox -q -value frw_ArnoldIsBlacklist` )
				fprint $fileId ( "Blacklist=" + `textFieldGrp -q -text frw_ArnoldMachineList` + "\n" );
			else
				fprint $fileId ( "Whitelist=" + `textFieldGrp -q -text frw_ArnoldMachineList` + "\n" );
			
			fclose $fileId;
			
			string $jobFilename = CheckSlashes( $tempDir + "/arnold_deadline_job.job" );
			$fileId = `fopen $jobFilename "w"`;
			if( $fileId == 0 )
				print( "Error in Deadline Submission Script: could not create " + $jobFilename + "\n" );
				
			fprint $fileId ( "InputFile=" + $inputPath + "\n" );
			fprint $fileId ( "Threads=" + `intSliderGrp -q -v frw_arnoldThreads` + "\n" );
			fprint $fileId ( "CommandLineOptions=" + `textFieldGrp -q -text frw_arnoldArgs` + "\n" );
			fprint $fileId ( "Verbose=4\n" );
			fprint $fileId ( "RegionJob=True\n" );
			fprint $fileId ( "CommandLineOptions=" + `textFieldGrp -q -text frw_arnoldArgs` + "\n" );
			
			if( size($elements) > 0)
			{
				fprint $fileId ( "HasAOVs=True\n" );
				int $aovCount = 0;
				for( $curAOV in $elements )
				{
				
					string $aovName = `getAttr ($curAOV+".name")`;
					string $aovDriver[] = `listConnections ($curAOV+".outputs[0].driver")`;
					string $aovExtension = `getAttr ($aovDriver[0]+".aiTranslator")`;
					fprint $fileId ( "ASSAOV"+ $aovCount +"Name="+$aovDriver[0]+"@driver_"+$aovExtension+".RGBA."+$aovName+".filename\n" );
					$aovCount++;
				}
			}			
			
			int $top = ($regions[$curRegion*4+2]);
			int $right = ($regions[$curRegion*4+1]-1);
			int $left = ($regions[$curRegion*4]);
			int $bottom = ($regions[$curRegion*4+3]-1);
			
			fprint $fileId ( "RegionLeft="+$left+"\n" );
			fprint $fileId ( "RegionTop="+$top+"\n" );
			fprint $fileId ( "RegionRight="+$right+"\n" );
			fprint $fileId ( "RegionBottom="+$bottom+"\n" );
			
			int $assemblyTop = ($assemblyRegions[$curRegion*4+2]);
			int $assemblyRight = ($assemblyRegions[$curRegion*4+1]);
			int $assemblyLeft = ($assemblyRegions[$curRegion*4]);
			int $assemblyBottom = ($assemblyRegions[$curRegion*4+3]);
			stringArrayInsertAtIndex($curRegion, $regionLeftValues, ""+$assemblyLeft);
			stringArrayInsertAtIndex($curRegion, $regionTopValues, ""+ $assemblyTop);
			stringArrayInsertAtIndex($curRegion, $regionRightValues, ""+ $assemblyRight);
			stringArrayInsertAtIndex($curRegion, $regionBottomValues, ""+ $assemblyBottom);
			
			int $frameCount = 0;
			for ($frame in $frameRange)
			{
				int $elementCount = 0;
				for( $element in $elementNames )
				{
					string $outputPrefix = CheckSlashes( GetOutputPrefix( 1, $frame, $renderLayer, $camera, $element ) );
					$outputPrefix = swapDeepExr( $outputPrefix );
					$outputPrefix = GetJigsawOutputPrefix( $outputPrefix, $curRegion, "arnold" );
					if( $elementCount == 0)
					{
						fprint $fileId ( "RegionFilename"+$frame+"="+ CheckSlashes( $outputFilePath + "/" + $outputPrefix ) +"\n" );
					}
					else
					{
						fprint $fileId ( "AOV" + ( $elementCount - 1 ) + "Filename"+$frame+"=" + CheckSlashes( $outputFilePath + "/" + $outputPrefix )+"\n" );
					}
					$elementCount++;
				}
			}
			
			fclose $fileId;
			
			string $argList[] ;
			$argList[0] = $submitFilename;
			$argList[1] = $jobFilename;
			
			// Submit the job to Deadline
			string $submissionCommandFile = CreateArgumentsFile( $argList );
			string $submitResults = CallDeadlineCommand( "\"" + $submissionCommandFile + "\"", true );
				
			// Show results
			print( "\n\nSubmission Results For Job " + $jobName + ":\n---------------------------------------------------------------------------\n" + $submitResults + "\n" );
			$submissionCount += 1;
			// Get the job id to return
			string $jobId = "";
			string $resultArray[];
			$resultArray = stringToStringArray( $submitResults, "\n" );
			for( $n = 0; $n < size($resultArray); $n++ )
			{
				if( startsWith( $resultArray[$n], "JobID=" ) )
				{
					$jobId = substituteAllString( $resultArray[$n], "JobID=", "" );
					break;
				}
			}
			
			stringArrayInsertAtIndex(size($jobIdList),$jobIdList, $jobId) ;
		}
		
		int $submitDependentJob = `checkBox -q -v frw_submitTileDependentJob`;
		if($submitDependentJob)
		{	
			string $regionString = stringArrayToString($regionLeftValues,";");
			setAttr defaultRenderGlobals.deadlineRegionLeft -type "string" $regionString;
			$regionString = stringArrayToString($regionTopValues,";");
			setAttr defaultRenderGlobals.deadlineRegionTop -type "string" $regionString;
			$regionString = stringArrayToString($regionRightValues,";");
			setAttr defaultRenderGlobals.deadlineRegionRight -type "string" $regionString;
			$regionString = stringArrayToString($regionBottomValues,";");
			setAttr defaultRenderGlobals.deadlineRegionBottom -type "string" $regionString;
			$submissionCount += SetupDependentJigsawAnimationAssemblerJob("arnold", $jobIdList, $renderLayer, $camera);
		}
		
	}
	return $submissionCount;
	
}

proc SetupDependentMaxwellJob(string $jobId, string $camera, int $batch)
{
	global string $MaxwellOutputScriptListGrp;

	string $jobName = `textFieldGrp -q -text frw_JobName`;
	string $batchName = `textFieldGrp -q -text frw_JobName`;
	string $frameList = `textFieldGrp -q -text frw_FrameList`;
			
	string $inputPath = `textFieldButtonGrp -q -text $MaxwellOutputScriptListGrp`;
	int $exportLocal = `checkBox -q -v frw_exportMaxwellLocal`;
	int $animation = `getAttr "defaultRenderGlobals.animation"`;
	int $singleFile = 1;
	if($animation)
		$singleFile = 0;
	
	string $sdkVersion = `maxwell -getSDKVersion`;
	
	
	string $tempDir = CallDeadlineCommand( "-GetCurrentUserHomeDirectory", false ) + "/temp";
		
	string $submitFilename = CheckSlashes( $tempDir + "/arnold_deadline_info.job" );
	$fileId = `fopen $submitFilename "w"`;
	if( $fileId == 0 )
		print( "Error in Deadline Submission Script: could not create " + $submitFilename + "\n" );
		
	fprint $fileId ( "Plugin=Maxwell\n" );
	
	$jobName = $jobName + " - Render";
	if($camera != "")
		$jobName = $jobName + " - "+$camera;
	
	fprint $fileId ( "Name=" + $jobName + "\n" );
	
	if( !$exportLocal || $batch )
		fprint $fileId ( "BatchName=" + $batchName + "\n" );
	
	fprint $fileId ( "Comment=" + `textFieldGrp -q -text frw_JobComment` + "\n" );
	fprint $fileId ( "Pool=" + `optionMenuGrp -q -value frw_deadlineMaxwellPool` + "\n" );
	fprint $fileId ( "SecondaryPool=" + `optionMenuGrp -q -value frw_deadlineMaxwellSecondaryPool` + "\n" );
	fprint $fileId ( "Priority=" + `intSliderGrp -q -v frw_MaxwellJobPriority` + "\n" );
	fprint $fileId ( "OnJobComplete=" + `optionMenuGrp -q -value frw_MaxwellOnComplete` + "\n" );
	fprint $fileId ( "TaskTimeoutMinutes=" + `intSliderGrp -q -v frw_MaxwellSlaveTimeout` + "\n" );
	fprint $fileId ( "MinRenderTimeMinutes=" + `intSliderGrp -q -v frw_MaxwellMinSlaveTimeout` + "\n" );
	fprint $fileId ( "ConcurrentTasks=" + `intSliderGrp -q -v frw_MaxwellConcurrentTasks` + "\n" );
	fprint $fileId ( "Department=" + `textFieldGrp -q -text frw_Department` + "\n" );
	fprint $fileId ( "Group=" + `optionMenuGrp -q -value frw_MaxwellGroup` + "\n" );
	fprint $fileId ( "MachineLimit=" + `intSliderGrp -q -v frw_MaxwellLimitCount` + "\n" );
	fprint $fileId ( "LimitGroups=" + `textFieldGrp -q -text frw_MaxwellLimitGroups` + "\n" );
	fprint $fileId ( "JobDependencies=" + $jobId + "\n" );
	fprint $fileId ( "IsFrameDependent=true\n" ); // this can be enabled because arnold export jobs can be done across multiple machines
	fprint $fileId ( "Frames=" + $frameList + "\n" );
	fprint $fileId ( "ChunkSize=1\n" );
	
	if( `checkBox -q -value frw_MaxwellIsBlacklist` )
		fprint $fileId ( "Blacklist=" + `textFieldGrp -q -text frw_MaxwellMachineList` + "\n" );
	else
		fprint $fileId ( "Whitelist=" + `textFieldGrp -q -text frw_MaxwellMachineList` + "\n" );
	
	string $outputFilePath = CheckSlashes( `textFieldGrp -q -text frw_outputFilePath` );
	string $outputPrefix = CheckSlashes( GetOutputPrefix( 0, 0, "", $camera, "" ) );
	//GetOutputPrefix( int $replaceFrameNumber, int $newFrameNumber, string $layerName, string $cameraName, string $additionalReplacements )
	string $outputFilename = CheckSlashes( $outputFilePath  + "/" + $outputPrefix );
	
	fprint $fileId ( "OutputFilename0=" + $outputFilename + "\n" );
	
	string $renderFileName = substituteAllString( $outputFilename, "####.", "" );
	string $mxiFileName = substituteAllString( $renderFileName, `fileExtension($renderFileName)`+"$", "mxi" );
	fclose $fileId;
	
	string $jobFilename = CheckSlashes( $tempDir + "/maxwell_deadline_job.job" );
	$fileId = `fopen $jobFilename "w"`;
	if( $fileId == 0 )
		print( "Error in Deadline Submission Script: could not create " + $jobFilename + "\n" );
		
	fprint $fileId ( "Version="+`substring $sdkVersion 1 1`+"\n" );
	fprint $fileId ( "SingleFile=" + $singleFile + "\n" );
	fprint $fileId ( "SeparateFiles=" + $animation + "\n" );
	fprint $fileId ( "MaxwellFile=" + $inputPath + "\n" );
	fprint $fileId ( "OutputFile=" + $renderFileName + "\n" );
	fprint $fileId ( "MxiFile=" + $mxiFileName + "\n" );
	fprint $fileId ( "LocalRendering=False\n" );
	fprint $fileId ( "ResumeFromMxiFile=False\n" );
	fprint $fileId ( "Build=None\n" );
	fprint $fileId ( "RenderThreads=" + `intSliderGrp -q -v frw_maxwellThreads` + "\n" );
	fprint $fileId ( "CommandLineOptions=" + `textFieldGrp -q -text frw_maxwellArgs` + "\n" );
	fprint $fileId ( "Build=None\n" );
	
	fprint $fileId ( "OverrideTime=False\n" );
	fprint $fileId ( "OverrideTimeValue=10.0\n" );
	fprint $fileId ( "OverrideSampling=False\n" );
	fprint $fileId ( "OverrideSamplingValue=10.0\n" );
	fprint $fileId ( "OverrideExtraSampling=False\n" );
	fprint $fileId ( "ExtraSamplingEnabled=False\n" );
	fprint $fileId ( "ExtraSamplingLevel=10.0\n" );
	fprint $fileId ( "ExtraSamplingMask=Alpha\n" );
	fprint $fileId ( "ExtraSamplingCustomAlphaName=\n" );
	fprint $fileId ( "ExtraSamplingBitmapFile=\n" );
	fprint $fileId ( "ExtraSamplingInvertMask=False\n" );
	fprint $fileId ( "Verbosity=All\n" );
	fprint $fileId ( "MergeJob=False\n" );
	fprint $fileId ( "Camera=" + $camera + "\n" );
	fprint $fileId ( "AppendFrame=" + $animation +"\n" );
	int $paddingSize = `getAttr "defaultRenderGlobals.extensionPadding"`;
	fprint $fileId ( "AnimationPadding=" + $paddingSize +"\n" );
	
	fclose $fileId;
	
	string $argList[];
	$argList[0] = $submitFilename;
	$argList[1] = $jobFilename;
	
	// Submit the job to Deadline
	string $submissionCommandFile = CreateArgumentsFile( $argList );
	string $submitResults = CallDeadlineCommand( "\"" + $submissionCommandFile + "\"", true );
			
	// Show results
	print( "\n\nSubmission Results For Job " + $jobName + ":\n---------------------------------------------------------------------------\n" + $submitResults + "\n" );
	
}

proc SetupArnoldKickJob(string $jobId, string $camera, string $renderLayer)
{
	string $jobName = `textFieldGrp -q -text frw_JobName`;
	string $batchName = `textFieldGrp -q -text frw_JobName`;
	string $frameList = `textFieldGrp -q -text frw_FrameList`;
	string $outputFilePath = CheckSlashes( `textFieldGrp -q -text frw_outputFilePath` );
	string $projectPath = `textFieldGrp -q -text frw_projectPath`;	
	string $assExportFolder = `workspace -fre "ASS"`;
	if( $assExportFolder == "" )
		$assExportFolder = "data";
	string $assFileName = GetStrippedSceneFileName();
	
	int $exportLocal = `checkBox -q -v frw_exportArnoldLocal`;
	
	// Append camera name to the job
	if( $camera != "" )
		$jobName = $jobName + " - " + $camera;

	// Append render layer name to the job
	if( $renderLayer != "" )
		$jobName += " - " + $renderLayer;

	int $ignoreOutFormatControl = false;
	if( `getAttr "defaultRenderGlobals.animation"` )
	{
		int $paddingSize = `getAttr "defaultRenderGlobals.extensionPadding"`;
		string $padding = "";
		while( size($padding) < $paddingSize )
			$padding = "0" + $padding;
			
		int $periodInExt = `getAttr "defaultRenderGlobals.periodInExt"`;
		int $putFrameBeforeExt = `getAttr "defaultRenderGlobals.putFrameBeforeExt"`;
			
		if( $periodInExt == 0 ) // name#.ext
		{
			$assFileName += $padding;
		}
		else if( $periodInExt == 1 )
		{
			if( $putFrameBeforeExt ) // name.# or name.#.ext
			{
				$assFileName += "." + $padding;
			}
			else // name.ext.#
			{
				$assFileName += ".ass." + $padding;
				$ignoreOutFormatControl = true;
			}
		}
		else if( $periodInExt == 2 ) // name_#.ext
		{
			$assFileName += "_" + $padding;
		}
	}
	
	if( !$ignoreOutFormatControl && `getAttr "defaultRenderGlobals.outFormatControl"` == 0 )
		$assFileName += ".ass";
	
	string $inputPath = $projectPath + "/" + $assExportFolder + "/";
	
	if ( IsRenderLayersOn() ) // swap default to master
	{
		if( $renderLayer == "defaultRenderLayer" )
		{
			$renderLayer = "masterLayer";
		}

		$inputPath = $inputPath + $renderLayer + "/";
	}
	
	string $renderableCameras[] = deadlineGetRenderableCameras( false );
	int $multipleRenderableCams = ( size ( $renderableCameras ) > 1 );
	if ( $multipleRenderableCams )
		$inputPath = $inputPath + $camera + "/";
		
	$inputPath = $inputPath + CheckSlashes( $assFileName );
	
	string $tempDir = CallDeadlineCommand( "-GetCurrentUserHomeDirectory", false ) + "/temp";
		
	string $submitFilename = CheckSlashes( $tempDir + "/arnold_deadline_info.job" );
	$fileId = `fopen $submitFilename "w"`;
	if( $fileId == 0 )
		print( "Error in Deadline Submission Script: could not create " + $submitFilename + "\n" );
		
	fprint $fileId ( "Plugin=Arnold\n" );
	fprint $fileId ( "Name=" + $jobName + "\n" );
	
	if( !$exportLocal )
		fprint $fileId ( "BatchName=" + $batchName + "\n" );
	
	fprint $fileId ( "Comment=" + `textFieldGrp -q -text frw_JobComment` + "\n" );
	fprint $fileId ( "Pool=" + `optionMenuGrp -q -value frw_deadlineArnoldPool` + "\n" );
	fprint $fileId ( "SecondaryPool=" + `optionMenuGrp -q -value frw_deadlineArnoldSecondaryPool` + "\n" );
	fprint $fileId ( "Priority=" + `intSliderGrp -q -v frw_ArnoldJobPriority` + "\n" );
	fprint $fileId ( "OnJobComplete=" + `optionMenuGrp -q -value frw_ArnoldOnComplete` + "\n" );
	fprint $fileId ( "TaskTimeoutMinutes=" + `intSliderGrp -q -v frw_ArnoldSlaveTimeout` + "\n" );
	fprint $fileId ( "MinRenderTimeMinutes=" + `intSliderGrp -q -v frw_ArnoldMinSlaveTimeout` + "\n" );
	fprint $fileId ( "ConcurrentTasks=" + `intSliderGrp -q -v frw_ArnoldConcurrentTasks` + "\n" );
	fprint $fileId ( "Department=" + `textFieldGrp -q -text frw_Department` + "\n" );
	fprint $fileId ( "Group=" + `optionMenuGrp -q -value frw_ArnoldGroup` + "\n" );
	fprint $fileId ( "MachineLimit=" + `intSliderGrp -q -v frw_ArnoldLimitCount` + "\n" );
	fprint $fileId ( "LimitGroups=" + `textFieldGrp -q -text frw_ArnoldLimitGroups` + "\n" );
	
	string $elements[] = getArnoldElementNames();
	int $counter = 0;
	for($element in $elements)
	{
		string $outputPrefix = "";
		$outputPrefix = CheckSlashes( GetOutputPrefix( 0, 0, $renderLayer, $camera, $element ) );
		$outputPrefix = swapDeepExr( $outputPrefix );
		fprint $fileId ( "OutputFilename" + $counter + "=" + CheckSlashes( $outputFilePath + "/" + $outputPrefix ) + "\n" );
		$counter += 1;
	}
	
	fprint $fileId ( "JobDependencies=" + $jobId + "\n" );
	fprint $fileId ( "IsFrameDependent=true\n" ); // this can be enabled because arnold export jobs can be done across multiple machines
	fprint $fileId ( "Frames=" + $frameList + "\n" );
	fprint $fileId ( "ChunkSize=1\n" );
	
	if( `checkBox -q -value frw_ArnoldIsBlacklist` )
		fprint $fileId ( "Blacklist=" + `textFieldGrp -q -text frw_ArnoldMachineList` + "\n" );
	else
		fprint $fileId ( "Whitelist=" + `textFieldGrp -q -text frw_ArnoldMachineList` + "\n" );
	
	fclose $fileId;
		
	string $jobFilename = CheckSlashes( $tempDir + "/arnold_deadline_job.job" );
	$fileId = `fopen $jobFilename "w"`;
	if( $fileId == 0 )
		print( "Error in Deadline Submission Script: could not create " + $jobFilename + "\n" );
		
	fprint $fileId ( "InputFile=" + $inputPath + "\n" );
	fprint $fileId ( "Threads=" + `intSliderGrp -q -v frw_arnoldThreads` + "\n" );
	fprint $fileId ( "CommandLineOptions=" + `textFieldGrp -q -text frw_arnoldArgs` + "\n" );
	fprint $fileId ( "Verbose=4\n" );
	fclose $fileId;
	
	string $argList[];
	$argList[0] = $submitFilename;
	$argList[1] = $jobFilename;
	
	// Submit the job to Deadline
	string $submissionCommandFile = CreateArgumentsFile( $argList );
	string $submitResults = CallDeadlineCommand( "\"" + $submissionCommandFile + "\"", true );
			
	// Show results
	print( "\n\nSubmission Results For Job " + $jobName + ":\n---------------------------------------------------------------------------\n" + $submitResults + "\n" );
}

proc int SetupMaxwellExportJob( string $renderer )
{
	global int $MaxwellExportJobType;
	global string $MaxwellOutputScriptListGrp;
	
	int $submitCounter = 0;
	int $submitDependentJob = `checkBox -q -v frw_submitMaxwellJob`;
	int $exportLocal = `checkBox -q -v frw_exportMaxwellLocal`;
	
	string $camera = "";
	int $renderableCameras = 0;
	string $selectedCamera = `optionMenuGrp -q -value frw_camera`;
	string $cameraNames[] = `listTransforms -cameras`;
	for( $cameraName in $cameraNames )
	{
		if( $selectedCamera != "" && $cameraName == $selectedCamera )
		{
			$camera = $selectedCamera;
			break;
		}
		
		if( IsCameraRenderable( $cameraName ) )
			$renderableCameras = $renderableCameras + 1;
	}
	
	
	string $outputScript = `textFieldButtonGrp -q -text $MaxwellOutputScriptListGrp`;
	string $jobId = "";
	if(!$exportLocal || !$submitDependentJob)
	{
		$jobId = WriteJobFilesAndSubmit( $renderer, 0, 0, $MaxwellExportJobType, "" );
		$submitCounter++;
		
	}
	else
	{
		int $start = 0;
		int $end = 0;
		int $exportOnly = 0;
		string $mxsPath = "";
		int $persistentMxs = 0;
		string $cmdLine = "";
		
		if( `objExists maxwellRenderOptions` == 0 )
		{
			print( "Error in Deadline Submission Script: Maxwell is not available.\n" );
			return 0;
		}
		$exportOnly = `getAttr maxwellRenderOptions.exportOnly`;
		$cmdLine = `getAttr maxwellRenderOptions.cmdLine`;
		$persistentMxs = `getAttr maxwellRenderOptions.persistentMXS`;
		$mxsPath = `getAttr maxwellRenderOptions.mxsPath`;
		
		removeRenderLayerAdjustmentAndUnlock maxwellRenderOptions.exportOnly;
		catch(`setAttr maxwellRenderOptions.exportOnly 1`);
		
		setAttr -type "string" maxwellRenderOptions.cmdLine "-node";
		maxwellUnlockAndSet maxwellRenderOptions.persistentMXS 1;
		setAttr -type "string" maxwellRenderOptions.mxsPath $outputScript;
		
		removeRenderLayerAdjustmentAndUnlock maxwellRenderOptions.exportOnly;
		catch(`setAttr maxwellRenderOptions.exportOnly 1`);
		
		string $maxwellVersion = `pluginInfo -q -version "maxwell"`;
		string $maxwellVersionTokens[];
		tokenize($maxwellVersion, ".", $maxwellVersionTokens);
		int $majorVersion = $maxwellVersionTokens[0];
		int $minorVersion = $maxwellVersionTokens[1];
		if( $majorVersion > 2 || ( $majorVersion == 2 && $minorVersion >= 5 ) )
		{
			maxwellBatchRender("");
		} 
		else
		{
			maxwell -batchRender;
		}
		
		setAttr maxwellRenderOptions.exportOnly $exportOnly;
		setAttr -type "string" maxwellRenderOptions.cmdLine $cmdLine;
		setAttr maxwellRenderOptions.persistentMXS $persistentMxs;
		setAttr -type "string" maxwellRenderOptions.mxsPath $mxsPath;
	}
	
	if( $submitDependentJob )
	{
		if( $camera == "" && $renderableCameras > 1 )
		{
			string $cameraNames[] = deadlineGetRenderableCameras( false );
			for( $cameraName in $cameraNames )
			{
				SetupDependentMaxwellJob( $jobId, $cameraName, 1 );
				$submitCounter++;
			}
		}
		else
		{
			SetupDependentMaxwellJob( $jobId, "", 0 );
			$submitCounter++;
		}
	}
	
	return $submitCounter;
}

proc int SetupArnoldExportJob( string $renderer )
{
	global int $ArnoldExportJobType;
	
	int $submitCounter = 0;
	int $regionRendering = `checkBox -q -value frw_regionRendering`;
	int $submitDependentJob = `checkBox -q -v frw_submitArnoldJob`;
	int $exportLocal = `checkBox -q -v frw_exportArnoldLocal`;
	int $singleRegionJob = `checkBox -q -v frw_submitTileSingleJob`;
	int $singleRegionRendering = `checkBox -q -v frw_submitTileSingleJob`;
	
	if($submitDependentJob == 0)
	{
		$regionRendering = 0;
	}
	string $jobId = "";
	if(!$exportLocal || !$submitDependentJob)
	{
		$jobId = WriteJobFilesAndSubmit( $renderer, 0, $regionRendering, $ArnoldExportJobType, "" );
		$submitCounter++;
	}
	else
	{
		removeRenderLayerAdjustmentAndUnlock defaultArnoldRenderOptions.renderType;
		catch(`setAttr defaultArnoldRenderOptions.renderType 1`);
		setMayaSoftwareLayers("", "");
		setImageSizePercent(-1.);
		
		int $start = 0;
		int $end = 0;
		
		if( $regionRendering && $singleRegionRendering )
		{
			$start = `getAttr defaultRenderGlobals.startFrame`;
			$end = `getAttr defaultRenderGlobals.endFrame`;
			
			int $singleRegionFrame = `intSliderGrp -q -v frw_tileSingleFrame`;
			setAttr defaultRenderGlobals.startFrame $singleRegionFrame;
			setAttr defaultRenderGlobals.endFrame $singleRegionFrame;
		}
		
		mayaBatchRenderProcedure(0, "", "", "arnold", "");
		
		if( $regionRendering && $singleRegionRendering )
		{
			setAttr defaultRenderGlobals.startFrame $start;
			setAttr defaultRenderGlobals.endFrame $end;
		}
	}
	
	
	if( $submitDependentJob )
	{
		// Figure out the camera to use (if specified).
		string $selectedCamera = `optionMenuGrp -q -value frw_camera`;
		string $cameraNames[] = {};
		string $renderLayers[] = {""};
		if( $selectedCamera != " " )
		{
			stringArrayInsertAtIndex(0, $cameraNames, $selectedCamera );
		}
		else
		{
			$cameraNames  = deadlineGetRenderableCameras( false );
		}
		if( IsRenderLayersOn() )
		{
			$renderLayers = getRenderableRenderLayers(false);
		}
		
		for( $renderLayer in $renderLayers )
		{
			//if ( $renderLayer == "defaultRenderLayer" )
			//$renderLayer = "masterLayer";
			for( $cameraName in $cameraNames )
			{
				if( !$regionRendering )
				{
					SetupArnoldKickJob($jobId, $cameraName, $renderLayer );
					$submitCounter++;
				}
				else
				{
					$submitCounter += SetupArnoldKickRegionJob($jobId, $cameraName, $renderLayer );
				}
			}
		}
	}
	
	return $submitCounter;
}

proc SetupRenderManJob( string $jobId, string $renderLayer )
{
	string $jobName = `textFieldGrp -q -text frw_JobName`;
	if( $renderLayer != "" )
		$jobName = $jobName + " - " + $renderLayer;
	
	string $batchName = `textFieldGrp -q -text frw_JobName`;
	string $frameList = `textFieldGrp -q -text frw_FrameList`;
	
	string $outputFilePath = CheckSlashes( `textFieldGrp -q -text frw_outputFilePath` );
	
	string $projectPath = `textFieldGrp -q -text frw_projectPath`;
	
	string $inputPath = "";
	if( $renderLayer == "" )
		$inputPath = CheckSlashes( $projectPath + "/renderman/" + GetStrippedSceneFileName() + "/rib/0000/0000.rib\n" );
	else
		$inputPath = CheckSlashes( $projectPath + "/renderman/" + GetStrippedSceneFileName() + "/rib/0000/0000_" + $renderLayer + ".rib\n" );
	
	string $tempDir = CallDeadlineCommand( "-GetCurrentUserHomeDirectory", false ) + "/temp";
	
	string $submitFilename = CheckSlashes( $tempDir + "/renderman_deadline_info.job" );
	$fileId = `fopen $submitFilename "w"`;
	if( $fileId == 0 )
		print( "Error in Deadline Submission Script: could not create " + $submitFilename + "\n" );
	
	fprint $fileId ( "Plugin=RenderMan\n" );
	fprint $fileId ( "Name=" + $jobName + "\n" );
	fprint $fileId ( "BatchName=" + $batchName + "\n" );
	fprint $fileId ( "Comment=" + `textFieldGrp -q -text frw_JobComment` + "\n" );
	fprint $fileId ( "Pool=" + `optionMenuGrp -q -value frw_deadlineRendermanPool` + "\n" );
	fprint $fileId ( "SecondaryPool=" + `optionMenuGrp -q -value frw_deadlineRendermanSecondaryPool` + "\n" );
	fprint $fileId ( "Priority=" + `intSliderGrp -q -v frw_RendermanJobPriority` + "\n" );
	fprint $fileId ( "OnJobComplete=" + `optionMenuGrp -q -value frw_RendermanOnComplete` + "\n" );
	fprint $fileId ( "TaskTimeoutMinutes=" + `intSliderGrp -q -v frw_RendermanSlaveTimeout` + "\n" );
	fprint $fileId ( "MinRenderTimeMinutes=" + `intSliderGrp -q -v frw_RendermanMinSlaveTimeout` + "\n" );
	fprint $fileId ( "ConcurrentTasks=" + `intSliderGrp -q -v frw_RendermanConcurrentTasks` + "\n" );
	fprint $fileId ( "Department=" + `textFieldGrp -q -text frw_Department` + "\n" );
	fprint $fileId ( "Group=" + `optionMenuGrp -q -value frw_RendermanGroup` + "\n" );
	fprint $fileId ( "MachineLimit=" + `intSliderGrp -q -v frw_RendermanLimitCount` + "\n" );
	fprint $fileId ( "LimitGroups=" + `textFieldGrp -q -text frw_RendermanLimitGroups` + "\n" );
	
	string $renderableCameras[] = deadlineGetRenderableCameras( false );
	int $outputCount = 0;
	for( $camera in $renderableCameras )
	{
		$outputPrefix = GetOutputPrefix( 0, 0, $renderLayer, $camera, "" );
		fprint $fileId ( "OutputFilename" + $outputCount + "=" + CheckSlashes( $outputFilePath + "/" + $outputPrefix)  + "\n" );
		$outputCount++;
	}
	
	fprint $fileId ( "JobDependencies=" + $jobId + "\n" );
	fprint $fileId ( "IsFrameDependent=" + `checkBox -q -v frw_renderManFrameDependent` + "\n" ); // this can be enabled because renderman export jobs can be done across multiple machines
	fprint $fileId ( "Frames=" + $frameList + "\n" );
	fprint $fileId ( "ChunkSize=1\n" );
	
	if( `checkBox -q -value frw_RendermanIsBlacklist` )
		fprint $fileId ( "Blacklist=" + `textFieldGrp -q -text frw_RendermanMachineList` + "\n" );
	else
		fprint $fileId ( "Whitelist=" + `textFieldGrp -q -text frw_RendermanMachineList` + "\n" );

	fclose $fileId;
	
	string $jobFilename = CheckSlashes( $tempDir + "/renderman_deadline_job.job" );
	$fileId = `fopen $jobFilename "w"`;
	if( $fileId == 0 )
		print( "Error in Deadline Submission Script: could not create " + $jobFilename + "\n" );
	
	fprint $fileId ( "RibFile=" + $inputPath + "\n" );
	fprint $fileId ( "WorkingDirectory=" + CheckSlashes( $projectPath ) + "\n" );
	fprint $fileId ( "Threads=" + `intSliderGrp -q -v frw_rendermanThreads` + "\n" );
	fprint $fileId ( "CommandLineOptions=" + `textFieldGrp -q -text frw_rendermanArgs` + "\n" );
	fclose $fileId;
	
	string $argList[];
	$argList[0] = $submitFilename;
	$argList[1] = $jobFilename;
	
	// Submit the job to Deadline
	string $submissionCommandFile = CreateArgumentsFile( $argList );
	string $submitResults = CallDeadlineCommand( "\"" + $submissionCommandFile + "\"", true );
	
	// Show results
	print( "\n\nSubmission Results For Job " + $jobName + ":\n---------------------------------------------------------------------------\n" + $submitResults + "\n" );
}

proc int SetupRendermanExportJob( string $renderer )
{
	global int $RendermanExportJobType;
	
	int $submitCounter = 0;
	
	string $jobId = WriteJobFilesAndSubmit( $renderer, 0, 0, $RendermanExportJobType, "" );
	
	$submitCounter++;
	
	int $submitDependentJob = `checkBox -q -v frw_submitRenderManJob`;
	if( $submitDependentJob )
	{
		if (!IsRenderLayersOn())
		{
			SetupRenderManJob( $jobId, "" );
			$submitCounter++;
		}
		else
		{
			
			// Loop through the render layers
			string $renderLayerList[] = getRenderableRenderLayers(false);
			for( $i = 0; $i < size( $renderLayerList ); $i++ )
			{
				string $renderLayer = $renderLayerList[$i];
				if ( $renderLayer == "defaultRenderLayer" )
					$renderLayer = "masterLayer";
					
				SetupRenderManJob( $jobId, $renderLayer );
				$submitCounter++;
			}
		}
	}
	
	return $submitCounter;
}

global proc SetupSubmission()
{
	global string $DeadlineSubmitterWindow;
	global string $StartupScriptPathGrp;
	global int $MayaRenderJobType;
	global int $MentalRayExportJobType;
	global int $VRayExportJobType;
	global int $RendermanExportJobType;
	global int $ArnoldExportJobType;
	global int $MaxwellExportJobType;

	global int $BifrostSimulationJobType;
	global int $AlembicExportJobType;
	global int $MayaScriptJobType;
	global int $GeometryCachingJobType;
	global int $FluidCachingJobType;
	
	SavePersistentDeadlineOptions();
	print( "Submitting job to Deadline...\n" );
		
	// Get the current renderer
	string $renderer = GetCurrentRenderer();
	
	// Check if we are doing a mental ray export
	int $jobType = `optionMenuGrp -q -select frw_mayaJobType`;
	
	/*
	// Check that if the renderer is Gelato that we are using MayaBatch
	if( $renderer == "gelato" && `getAttr defaultRenderGlobals.deadlineUseMayaBatchPlugin` != 1)
	{
		string $errorMessage = "The Maya plugin does not support the Gelato renderer.  Please select the checkbox to use the MayaBatch plugin.\n\n";
		string $result = `confirmDialog -title "Submission Error" -message ( $errorMessage ) -button "OK" -defaultButton "OK"`;
		return;
	}
	*/
	
	/*
	// Ensure that the scene is animated
	if( !IsAnimatedOn() )
	{
		string $errorMessage = "";
		if ( $renderer == "vray" )
		{
			if( IsOldVray() )
				$errorMessage = "Animation checkbox under Image File Output is not checked. Deadline requires that animation be enabled.\n\n";
			else
				$errorMessage = "Frame/Animation Ext in render globals is set for a single frame. Deadline requires that animation be enabled.\n\n";
		}
		else
			$errorMessage = "Frame/Animation Ext in render globals is set for a single frame. Deadline requires that animation be enabled.\n\n";
		
		string $result = `confirmDialog -title "Submission Error" -message ( $errorMessage ) -button "OK" -defaultButton "OK"`;
		return;
	}
	*/
	
	// Check all the paths for problems, and warn the user if any are found
	string $projectPath = CheckSlashes( `textFieldGrp -q -text frw_projectPath` );
	string $outputFilePath = CheckSlashes( `textFieldGrp -q -text frw_outputFilePath` );
	string $sceneFilePath = CheckSlashes( `file -q -sceneName` );
	string $mentalRayFilename = CheckSlashes( `textFieldGrp -q -text frw_mentalRayFilePath` );
	string $vrayFilename = CheckSlashes( `textFieldGrp -q -text frw_vrayFilePath` );
	string $maxwellExportFilename = CheckSlashes( `textFieldGrp -q -text frw_maxwellScriptName` );
	
	int $submitMayaSceneFile = `checkBox -q -value frw_submitMayaScene`;

	string $message = "";
	if( !$submitMayaSceneFile && IsLocalDrive( $sceneFilePath ) )
		$message = $message + "Maya Scene file, \"" + $sceneFilePath + "\" is on a local drive and is not being submitted.\nSlaves will not be able to access the scene file.\n\n";
	
	if( IsLocalDrive( $projectPath ) )
		$message = $message + "Project path, \"" + $projectPath + "\" is on a local drive.\nParticle caching and other Maya features will not be available.\n\n";
	
	int $exportDependentJob = false;
	if( $jobType == $MentalRayExportJobType )
	{
		$binary = false;
		if( catch( $binary = `radioButton -query -select MayatomrExport_Binary` ) )
		{
			string $result = `confirmDialog -parent $DeadlineSubmitterWindow -title "Error Reading Export Options" -message "Could not read in Mental Ray Export settings. Please ensure that the Mental Ray Export settings dialog is open when submitting the job to Deadline." -button "Export Settings..." -button "Cancel" -defaultButton "Export Settings..." -cancelButton "Cancel" `;
			if( $result == "Export Settings..." )
				OpenExportSettings();
			return;
		}
		
		string $mentalRayPath = dirname( $mentalRayFilename );
		if( ! `filetest -d $mentalRayPath` )
			$message = $message + "Mental Ray output path \"" + $mentalRayPath + "\" does not exist!  Your Mental Ray files will be lost!\n\n";
		else if( IsLocalDrive( $mentalRayFilename ) )
			$message = $message + "Mental Ray output file \"" + $mentalRayFilename + "\" is on a local drive.\nSlaves will not be able to copy the Mental Ray files to this drive.\n\n";
		else if( size( $mentalRayFilename ) == 0 )
			$message = $message + "Mental Ray output file is blank! Your Mental Ray files will be lost!\n\n";
		
		$exportDependentJob = `checkBox -q -v frw_submitMentalRayJob`;
	}
	else if( $jobType == $VRayExportJobType )
	{
		string $vrayPath = dirname( $vrayFilename );
		if( ! `filetest -d $vrayPath` )
			$message = $message + "VRay export path \"" + $vrayPath + "\" does not exist!  Your VRay files will be lost!\n\n";
		else if( IsLocalDrive( $vrayFilename ) )
			$message = $message + "VRay output file \"" + $vrayFilename + "\" is on a local drive.\nSlaves will not be able to copy the exported VRay files to this drive.\n\n";
		else if( size( $vrayFilename ) == 0 )
			$message = $message + "VRay output file is blank! Your exported VRay files will be lost!\n\n";
		
		int $submitDependentJob = `checkBox -q -v frw_submitVRayJob`;
		if( $submitDependentJob && `getAttr( "vraySettings.misc_separateFiles" )` )
			$message = $message + "Dependent VRay standalone job option is not compatible with the 'Separate Files' option in the VRay Translator settings. No dependent jobs will be submitted.\n\n";
		
		if( `checkBox -q -v frw_submitVrimg2ExrJob` && $submitDependentJob )
		{
			string $vrimgOutputPrefix = CheckSlashes( GetOutputPrefix( 0, 0, "", "", "" ) );
			string $vrimgOutputFilename = CheckSlashes( $outputFilePath  + "/" + $vrimgOutputPrefix );
			
			if( fileExtension( $vrimgOutputFilename ) != "vrimg" )
				$message = $message + "Dependent Vrimg2Exr job is enabled, but the output format is not vrimg!\n\n";
		}
		
		$exportDependentJob = `checkBox -q -v frw_submitVRayJob`;
	}
	else if( $jobType == $RendermanExportJobType )
	{
		$exportDependentJob = `checkBox -q -v frw_submitRenderManJob`;
	}
	else if( $jobType == $ArnoldExportJobType )
	{
		$exportDependentJob = `checkBox -q -v frw_submitArnoldJob`;
	}
	else if( $jobType == $MaxwellExportJobType )
	{
		string $maxwellExportDirectory = dirname( $maxwellExportFilename );
		if( size( $maxwellExportFilename ) == 0 )
			$message = $message + "Maxwell script name is blank! No maxwell script will be exported!\n\n";
		else if( !`filetest -d $maxwellExportDirectory` )
			$message = $message + "Maxwell export directory \"" + $maxwellExportDirectory + "\" does not exist!  No maxwell script will be exported!\n\n";
		else if( IsLocalDrive( $maxwellExportDirectory ) )
			$message = $message + "Maxwell export directory \"" + $maxwellExportDirectory + "\" is on a local drive.\nSlaves will not be able to copy the exported Maxwell Files to this drive.\n\n";
	}
	
	// If not an export job, or it is an export job with a dependent job, warn about the output.
	if( $jobType == $MayaRenderJobType || $exportDependentJob )
	{
		if( ! `filetest -d $outputFilePath` )
			$message = $message + "Image Output Path \"" + $outputFilePath + "\" does not exist! Your final images will be lost!\n\n";
		else if( IsLocalDrive( $outputFilePath ) )
			$message = $message + "Image Output Path \"" + $outputFilePath + "\" is on a local drive.\nSlaves will not be able to copy images to this drive.\n\n";
		else if( size( $outputFilePath ) == 0 )
			$message = $message + "Image Output Path is blank! Your final images will be lost!\n\n";
	}
	
	// If there is a startup script, make sure it exists and that it isn't local.
	if( `checkBox -q -v frw_useMayaBatchPlugin` )
	{
		string $startupScript = `textFieldButtonGrp -q -text $StartupScriptPathGrp`;
		$startupScript = `strip $startupScript`;
		if( $startupScript != "" )
		{
			if( ! `filetest -e $startupScript` )
				$message = $message + "Startup Script \"" + $startupScript + "\" does not exist!\n\n";
			else if( IsLocalDrive( $startupScript ) )
				$message = $message + "Startup Script \"" + $startupScript + "\" is on a local drive.\nSlaves will not be able to access it at render time.\n\n";
		}
	}
	
	int $submitEachRenderLayer = IsRenderLayersOn() ? `checkBox -q -value frw_submitEachRenderLayer` : false;
	if( $jobType == $MayaRenderJobType && IsRenderLayersOn() && $submitEachRenderLayer )
	{
		string $tempMessage = "";
		string $renderLayerList[] = getRenderableRenderLayers(true);
		
		for( $renderLayerName in $renderLayerList )
		{
			$tempMessage = $tempMessage + "  " + $renderLayerName + "\n";
		}
		
		if( $tempMessage != "" )
			$message = $message + "The following renderable referenced layers will not be submitted with the job:\n" + $tempMessage + "\n";
	}
	
	int $regionRendering = `checkBox -q -value frw_regionRendering`;
	if( $regionRendering )
	{
		string $extension = fileExtension( GetOutputPrefix( 0, 0, "", "", "" ) );
		$extension = tolower( $extension );
		if( $extension != "bmp" && $extension != "dds" && $extension != "exr" && $extension != "jpg" && $extension != "png" && $extension != "sgi" && $extension != "tga" && $extension != "tif" )
			$message = $message + "The image format used is not compatible with the Tile Assembler, so you will have to assemble the final image manually.\nThe following formats are currently supported: bmp, dds, exr, jpg, png, sgi, tga, tif.\n\n";
	}

	if( $jobType == $GeometryCachingJobType )
	{
		string $geos[] = `listTransforms -geometry`;
		string $sels[] = `ls -sl`;

		string $selectedGeos[] = IntersectTwoStringArray($geos, $sels); // This is all of the selected Geometry

		if( !size( $selectedGeos ) )
		{
			confirmDialog -parent $DeadlineSubmitterWindow -title "No Selected Geometry Found" -message "No Geometry from this scene were selected. Make sure to select at least one Geometry before submitting a Geometry cache job." -button "OK";
			return;
		}

		string $geoDir = `textFieldButtonGrp -q -text frw_GeometricCacheOutputDir`;
		if( ! `filetest -d $geoDir` )
		{
			$message = $message + "No output directory has been specified. The results of this Geometry caching job may not be saved.\n\n";
		}
		
	}

	if( $jobType == $MayaScriptJobType ) // Make sure script file exists
	{
		string $mayaFile = `textFieldButtonGrp -q -text frw_mayaScriptJob`;
		if( ! `filetest -e $mayaFile` )
		{
			$message = $message + "The Script file specified does not exist. This script job may produce unexpected results.\n\n";
		}
	}

	if( $jobType == $AlembicExportJobType) // Make sure a file name has been specified
	{
		if( ! size(`ls -sl`) && `radioButtonGrp -q -select frw_AlembicExportSelection` == 2) // Chose to submit a custom selection, but nothing was selected
		{
			confirmDialog -parent $DeadlineSubmitterWindow -title "No Selected Items Found" -message "Nothing in this scene has been selected. Please select at least one item or change the Export option to \"All\" " -button "OK";
			return;
		}

		string $alembicFile = `textFieldButtonGrp -q -text frw_alembicExportFile`;
		if( ! `filetest -e $alembicFile` )
		{
			$message = $message + "No file has been set for Alembic export. The file must be saved or the job may produce unexpected results.\n\n";
		}
	}

	if( $jobType == $BifrostSimulationJobType ) // Make sure directory exists
	{
		string $biFrostDir = `textFieldButtonGrp -q -text frw_bifrostCacheDir`;
		if( ! `filetest -d $biFrostDir` )
		{
			$message = $message + "No output directory has been specified. The results of this Bifrost caching job may not be saved.\n\n";
		}
	}

	if( $jobType == $FluidCachingJobType ) // Make sure directory exists
	{
		string $fluids[] = `listTransforms "-type fluidShape"`;
		string $sels[] = `ls -sl`;

		print(size($fluids) + " " + size($sels) + " " + size(IntersectTwoStringArray($fluids, $sels) ) );

		if( !size( IntersectTwoStringArray( $fluids, $sels ) ) )
		{
			confirmDialog -parent $DeadlineSubmitterWindow -title "No Selected Fluids Found" -message "No Fluids from this scene were selected. Make sure to select at least one Fluid before submitting a Fluid cache job." -button "OK";
			return;
		}

		string $fluidDir = `textFieldButtonGrp -q -text frw_FluidCacheOutputDir`;
		if( ! `filetest -d $fluidDir` )
		{
			$message = $message + "No output directory has been specified. The results of this Fluid caching job may not be saved.\n\n";
		}
	}


		
	// Display any warning messages
	if( size( $message ) > 0 )
	{
		$message = $message + "\nAre you sure you want to submit this job?";
		string $result = `confirmDialog -parent $DeadlineSubmitterWindow -title "Confirm" -message ( $message ) -button "Yes" -button "No" -defaultButton "Yes" -cancelButton "No" -dismissString "No"`;
		if( $result == "No" )
			return;
	}
	
	// Save scene, if necessary
	if( `file -q -modified` )
	{
		print( "Maya scene has been modified, saving file\n" );
		file -save;
	}
	else
		print( "Maya scene has not been modified, skipping save\n" );
	
	// If this is not a mental ray export job, check if we need to submit each layer as a separate job.
	if( $jobType == $MayaRenderJobType && IsRenderLayersOn() && $submitEachRenderLayer )
	{
		int $submitCounter = 0;
		
		// Store the currently selected render layer
		string $currentRenderLayer = `editRenderLayerGlobals -query -currentRenderLayer`;
		string $renderLayerList[] = getRenderableRenderLayers(false);
		
		// Loop through the render layer if the checkbox is on
		for( $renderLayerName in $renderLayerList )
		{
			// Select the render layer to make sure the render settings are updated
			if( !catch(`editRenderLayerGlobals -currentRenderLayer $renderLayerName`) )
			{
				$renderer = GetCurrentRenderer();
				
				// Check if we're submitting each camera as a separate job.
				if( `checkBox -q -v frw_submitEachCamera` )
				{
					int $ignoreDefaultCameras = `checkBox -q -v frw_ignoreDefaultCameras`;
					
					string $cameraNames[] = deadlineGetRenderableCameras( $ignoreDefaultCameras );;
					if( size($cameraNames) == 0 )
					{
						confirmDialog -parent $DeadlineSubmitterWindow -title "Submission Results" -message "The scene contains no renderable non-default cameras." -button "Close";
						return;
					}
					for( $cameraName in $cameraNames )
					{
						// Set up a tile rendering job if necessary.
						if( $regionRendering && SupportsRegionRendering( $renderer ) )
							$submitCounter += SetupRegionRenderingJob( $renderer, $cameraName );
						else
						{
							WriteJobFilesAndSubmit( $renderer, 0, 0, $jobType, $cameraName );
							$submitCounter++;
						}
					}
				}
				else
				{
					// Set up a tile rendering job if necessary.
					if( $regionRendering && SupportsRegionRendering( $renderer ) )
						$submitCounter += SetupRegionRenderingJob( $renderer, "" );
					else
					{
						WriteJobFilesAndSubmit( $renderer, 0, 0, $jobType, "" );
						$submitCounter++;
					}
				}
			}
		}
		
		// Reselect the current render layer
		editRenderLayerGlobals -currentRenderLayer $currentRenderLayer;
		
		string $submitsResults = "Done submitting " + $submitCounter + " jobs.\nSee script history log for complete details.";
		confirmDialog -parent $DeadlineSubmitterWindow -title "Submission Results" -message $submitsResults -button "Close";
	}
	else
	{
		if( $jobType == $MentalRayExportJobType )
		{
			int $submitCounter = SetupMentalRayExportJob( $renderer );
			confirmDialog -parent $DeadlineSubmitterWindow -title "Submission Results" -message ("Done submitting " + $submitCounter + " jobs.\nSee script history log for complete details.") -button "Close";
		}
		else if( $jobType == $VRayExportJobType )
		{
			int $submitCounter = SetupVRayExportJob( $renderer );
			confirmDialog -parent $DeadlineSubmitterWindow -title "Submission Results" -message ("Done submitting " + $submitCounter + " jobs.\nSee script history log for complete details.") -button "Close";
		}
		else if( $jobType == $RendermanExportJobType )
		{
			int $submitCounter = SetupRendermanExportJob( $renderer );
			confirmDialog -parent $DeadlineSubmitterWindow -title "Submission Results" -message ("Done submitting " + $submitCounter + " jobs.\nSee script history log for complete details.") -button "Close";
		}
		else if( $jobType == $ArnoldExportJobType )
		{
			int $submitCounter = SetupArnoldExportJob( $renderer );
			confirmDialog -parent $DeadlineSubmitterWindow -title "Submission Results" -message ("Done submitting " + $submitCounter + " jobs.\nSee script history log for complete details.") -button "Close";
		}
		else if( $jobType == $MaxwellExportJobType )
		{
			int $submitCounter = SetupMaxwellExportJob( $renderer );
			confirmDialog -parent $DeadlineSubmitterWindow -title "Submission Results" -message ("Done submitting " + $submitCounter + " jobs.\nSee script history log for complete details.") -button "Close";
		}
		else
		{
			// Check if we're submitting each camera as a separate job.
			if( `checkBox -q -v frw_submitEachCamera` )
			{
				int $submitCounter = 0;
				int $ignoreDefaultCameras = `checkBox -q -v frw_ignoreDefaultCameras`;
				
				string $cameraNames[] = deadlineGetRenderableCameras( $ignoreDefaultCameras );
				if( size($cameraNames) == 0 )
				{
					confirmDialog -parent $DeadlineSubmitterWindow -title "Submission Results" -message "The scene contains no renderable non-default cameras." -button "Close";
					return;
				}
				for( $cameraName in $cameraNames )
				{
					// Only setup a tile rendering job if it is enabled.
					if( $regionRendering && SupportsRegionRendering( $renderer ) )
						$submitCounter += SetupRegionRenderingJob( $renderer, $cameraName );
					else
					{
						WriteJobFilesAndSubmit( $renderer, 0, 0, $jobType, $cameraName );
						$submitCounter++;
					}
				}
				
				string $submitsResults = "Done submitting " + $submitCounter + " jobs.\nSee script history log for complete details.";
				confirmDialog -parent $DeadlineSubmitterWindow -title "Submission Results" -message $submitsResults -button "Close";
			}
			else
			{
				// Only setup a tile rendering job if it is enabled.
				if( $regionRendering && SupportsRegionRendering( $renderer ) )
				{
					int $submitCounter = SetupRegionRenderingJob( $renderer, "" );
					confirmDialog -parent $DeadlineSubmitterWindow -title "Submission Results" -message ("Done submitting " + $submitCounter + " jobs.\nSee script history log for complete details.") -button "Close";
				}
				else
				{
					string $jobId = WriteJobFilesAndSubmit( $renderer, 1, 0, $jobType, "" );
				}
			}
		}
	}
	
	if( `getAttr defaultRenderGlobals.deadlineCloseOnSubmission` )
	{
		deleteUI -window DeadlineSubmitWindow;
	}
	
}

global proc LayerSettingsDialog()
{
	string $renderLayerList[] = getRenderableRenderLayers(false);
	int $chunkSize = `intSliderGrp -q -v frw_FrameGroup`;
	string $jobName = `attributeExists deadlineJobName defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineJobName` : GetStrippedSceneFileName();
	
	// Add controls to the submission dialog.
	int $windowWidth = 470;
	int $windowHeight = 500;
	
	int $labelWidth = 110;
	int $controlWidth = 320;
	
	// Get the dialog's formLayout.
	//
	string $form = `setParent -q`;
	formLayout -e -width ($windowWidth+8) -height $windowHeight $form;
	
	string $window = `formLayout -q -p $form`;
	print ($form + "\n");
	
	scrollLayout -width $windowWidth -horizontalScrollBarThickness 0 mainScrollLayout;
		columnLayout -adjustableColumn true -columnAttach "both" 0;
			
			// Store the currently selected render layer
			string $currentRenderLayer = `editRenderLayerGlobals -query -currentRenderLayer`;
			
			for( $layer in $renderLayerList )
			{
				if( !catch(`editRenderLayerGlobals -currentRenderLayer $layer`) )
				{
					string $frameRange = `textFieldGrp -q -text frw_FrameList`;
					int $frameRangeEnabled = IsAnimatedOn();
					
					frameLayout -label $layer -labelVisible true -borderVisible false -collapsable true;
						columnLayout -adj true -columnAttach "both" 0 -rowSpacing 4;
						
							$layerJobName = $jobName + " - " + $layer;
							
							$FieldName = "frw_JobName_" + $layer;
							textFieldGrp -label "Job Name" -cl2 "left" "left" -cw2 $labelWidth 320 -text $layerJobName -changeCommand SavePersistentDeadlineOptions -annotation "The name of the job" $FieldName;
							
							$FieldName = "frw_FrameList_" + $layer;
							textFieldGrp -label "Frame List" -en $frameRangeEnabled -cl2 "left" "left" -cw2 $labelWidth 320 -changeCommand SavePersistentDeadlineOptions -annotation "Enter a list of frames to render, separated by commas for separate frames, or dashes for continuous sequences of frames. e.g. 1, 5-10, 100" -text $frameRange $FieldName;
							
							$FieldName = "frw_FrameGroup_" + $layer;
							intSliderGrp -label "Task Size" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 1 -maxValue 1000 -v $chunkSize -changeCommand SavePersistentDeadlineOptions -annotation "Each task for the job will consist of this many frames" $FieldName;
							
						setParent ..;
					setParent ..;
				}
			}
			
			// Reselect the current render layer
			editRenderLayerGlobals -currentRenderLayer $currentRenderLayer;
			
		setParent ..;
	setParent ..;
	
	columnLayout -adj true -columnAttach "both" 2 -rowSpacing 4 buttonColumnLayout;
		rowLayout -numberOfColumns 2 -cw2 ($windowWidth / 2) ($windowWidth / 2);
			button -label "Submit Job" -width ($windowWidth / 2 - 4) -height 26 -annotation "Submits this job to Deadline" -align "center" -c SetupSubmission;
			button -label "Close" -width ($windowWidth / 2 - 4)  -height 26 -annotation "Closes this window" -align "center" -c DismissLayoutDialog;
		setParent ..;
	setParent ..;
	
	formLayout -e
		-af buttonColumnLayout bottom 0
		-af buttonColumnLayout right 0
		-af buttonColumnLayout left 0
		-ac mainScrollLayout bottom 0 buttonColumnLayout
		-af mainScrollLayout top 0
		-af mainScrollLayout left 3
	$form;
}

//---------------------------------------------------------
// Event handler functions.
//---------------------------------------------------------

global proc OpenJigsawWindow()
{
	if(catchQuiet(`python("jigsawThread.isAlive()")`))
	{
		string $path = CheckSlashes( GetMayaRepoPath() + "MayaJigsaw.py" );	
		python("execfile(\""+$path+"\")");
	}
	else
	{
		if(`python("jigsawThread.isAlive()")`)
		{
			confirmDialog -title "Jigsaw Rendering" -message "The Jigsaw window is already open." -button "OK" -defaultButton "OK";
			return;
		}
		else
		{
			string $path = CheckSlashes( GetMayaRepoPath() + "MayaJigsaw.py" );	
			python("execfile(\""+$path+"\")");
		}
	}
}

// Event when Submit Job button is pressed
global proc DeadlineSubmitterOnOk()
{
	global string $DeadlineSubmitterWindow;
	global int $MayaRenderJobType;
	
	// Source a CustomSanityChecks.mel file, if it exists. This file can be used to set some of the defaults
	// for the properties below if necessary.
	string $sanityScriptPath = CheckSlashes( GetMayaRepoPath() + "CustomPostSanityChecks.mel" );	
	if( `file -q -exists $sanityScriptPath` )
	{
		
		print( "sourcing custom post sanity check file: " + $sanityScriptPath + "\n" );
		eval( "source \"" + $sanityScriptPath + "\";" );
		if( !CustomPostSanityCheck() )
			return;
	}
	
	// Check if we are doing a mental ray export
	int $jobType = `optionMenuGrp -q -select frw_mayaJobType`;
	if( `checkBox -q -v frw_submitEachRenderLayer` && `checkBox -q -v frw_overrideLayerSettings` && $jobType == $MayaRenderJobType )
		layoutDialog -parent $DeadlineSubmitterWindow -title "Override Layer Job Settings" -ui "LayerSettingsDialog";
	else
		SetupSubmission();
}

global proc DismissLayoutDialog()
{
	layoutDialog -dismiss "";
}

global proc OnExit()
{
	python("jigThreadExists = True");
	python("try:\n\tjigThreadExists = jigsawThread.isAlive()\nexcept:\n\tjigThreadExists = False");
	int $exists = `python("jigThreadExists")`;
	if($exists)
	{
		python("jigsawThread.closeJigsaw()");
	}
}

// ===============================================================================================================
// The main function called by the Maya proxy script
// ===============================================================================================================

global proc SubmitJobToDeadline()
{
	global string $DeadlineSubmitterWindow;
	global string $ImageOutputPathGrp;
	global string $StartupScriptPathGrp;
	global string $ProjectPathGrp;
	global string $MentalRayFilenameGrp;
	global string $CompositeNamePathGrp;
	global string $VRayFilenameGrp;
	global string $LimitGroupGrp;
	global string $DependenciesGrp;
	global string $MachineListGrp;
	global string $JobNameGrp;
	
	global string $MayaRenderOptionsRollout;
	global string $MayaRenderOptionsArnoldRollout;
	global string $MayaRenderOptionsMentalRayRollout;
	global string $MayaRenderOptionsRedshiftRollout;
	global string $MayaRenderOptionsIRayRollout;
	global string $MayaRenderOptionsVRayRollout;
	global string $MayaRenderOptionsTileRollout;
	global string $MayaRenderOptionsJigsawRollout;
	global string $MentalRayExportRollout;
	global string $MentalRayExportRenderJobRollout;
	global string $VrayExportRollout;
	global string $VrayExportRenderJobRollout;
	global string $VrayExportVrimgJobRollout;
	global string $RendermanExportRollout;
	global string $RendermanExportRenderJobRollout;
	global string $ArnoldExportRollout;
	global string $ArnoldExportRenderJobRollout;

	global string $BifrostSimulationJobRollout;
	global string $AlembicExportJobRollout;
	global string $AlembicAdvancedOptionsJobRollout;
	global string $MayaScriptJobRollout;
	global string $FluidCachingJobRollout;
	global string $GeometryCachingJobRollout;
	
	global string $MaxwellExportRollout;
	global string $MaxwellExportRenderJobRollout;
	
	global string $openJigsawBtn;
	
	global string $SGInfoKeys[];
	global string $SGInfoValues[];
	
	global string $FTInfoKeys[];
	global string $FTInfoValues[];
	
	//=========================================================================
	// NIM

	global string $NimInfoKeys[];
	global string $NimInfoValues[];

	// END NIM
	//=========================================================================

	
	global int $PreviousImageCompType;
	global int $SelectedImageCompType;
	
	global string $VrayLimitGroupGrp;
	global string $VrayMachineListGrp;
	
	global string $MentalLimitGroupGrp;
	global string $MentalMachineListGrp;
	
	global string $RendermanLimitGroupGrp;
	global string $RendermanMachineListGrp;
	
	global string $ArnoldLimitGroupGrp;
	global string $ArnoldMachineListGrp;
	
	global string $MaxwellLimitGroupGrp;
	global string $MaxwellMachineListGrp;
	global string $MaxwellOutputScriptListGrp;
	
	global string $QuickDraftFormats[];
	global string $QuickDraftFormatFile[];
	global string $QuickDraftFormatMovie[];
		
	global string $QuickDraftResolutions[];
	global string $QuickDraftResolutionsDisplay[];
	global string $QuickDraftFrameRates[];
	
	global string $QuickDraftRestrictions[];
	global string $QuickDraftFormatOptions[];

	global string $BifrostDirectoryButtonGrp;
	global string $BifrostFileButtonGrp;

	global string $MayaScriptButtonGrp;

	global string $AlembicFileButtonGrp;

	global string $GeometryCachingDirButtonGrp;
	global string $FluidCachingDirButtonGrp;
	
	
	// This is a workaround for what seems like a bug in Maya vector rendering. Without it, the
	// renderer would spit out "Error: No object matches name: defaultRenderGlobals.imageNamePrefix".
	AddStringAttribute( "imageNamePrefix" );
	
	// Source a CustomSanityChecks.mel file, if it exists. This file can be used to set some of the defaults
	// for the properties below if necessary.
	//string $root = CallDeadlineCommand( "-getrepositoryroot" );
	//string $sanityScriptPath = CheckSlashes( $root + "/submission/Maya/Main/CustomSanityChecks.mel" );
	string $sanityScriptPath = CheckSlashes( GetMayaRepoPath() + "\CustomSanityChecks.mel" );
	if( `file -q -exists $sanityScriptPath` )
	{
		print( "sourcing custom sanity check file: " + $sanityScriptPath + "\n" );
		eval( "source \"" + $sanityScriptPath + "\";" );
	}

	// Get the renderer.
	string $renderer = GetCurrentRenderer();
	// Get the initial property values.
	string $jobName = `attributeExists deadlineJobName defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineJobName` : GetStrippedSceneFileName();	
	string $jobComment =  `attributeExists deadlineJobComment defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineJobComment` : "";
	string $department = `attributeExists deadlineDepartment defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineDepartment` : "";
	string $savedGroup = `attributeExists deadlineGroup defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineGroup` : "none";

	string $savedJobPool = `attributeExists deadlineJobPool defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineJobPool` : "none";
	string $savedJobSecondaryPool = `attributeExists deadlineJobSecondaryPool defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineJobSecondaryPool` : "";
	//int $useOnlyPool = `attributeExists deadlineUseOnlyPool defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineUseOnlyPool` : false;
	int $priority = `attributeExists deadlineJobPriority defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineJobPriority` : 50;
	int $limitCount = `attributeExists deadlineLimitCount defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineLimitCount` : 0;
	int $concurrentTasks = `attributeExists deadlineConcurrentTasks defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineConcurrentTasks` : 1;
	int $SlaveTimeout = `attributeExists deadlineSlaveTimeout defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineSlaveTimeout` : 0;
	int $MinSlaveTimeout = `attributeExists deadlineMinSlaveTimeout defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineMinSlaveTimeout` : 0;
	string $limitGroups = `attributeExists deadlineLimitGroups defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineLimitGroups` : "";
	string $dependencies = "";
	int $submitAsSuspended = `attributeExists deadlineSubmitAsSuspended defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineSubmitAsSuspended` : false;
	int $closeOnSubmission = `attributeExists deadlineCloseOnSubmission defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineCloseOnSubmission` : false;
	
	//int $deleteOnComplete = `attributeExists deadlineDeleteOnComplete defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineDeleteOnComplete` : false;
	
	string $machineList = `attributeExists deadlineMachineList defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineMachineList` : "";
	int $isBlacklist = `attributeExists deadlineIsBlacklist defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineIsBlacklist` : false;
	
	int $chunkSize = `attributeExists deadlineChunkSize defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineChunkSize` : 1;
	int $submitMayaScene = `attributeExists deadlineSubmitMayaScene defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineSubmitMayaScene` : false;
	//int $cpus = `attributeExists deadlineNumCPUs defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineNumCPUs` : 2;
	int $submitEachRenderLayer = `attributeExists deadlineSubmitEachRenderLayer defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineSubmitEachRenderLayer` : true;
	int $overrideGlobalRange = `attributeExists deadlineOverrideGlobalRange defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineOverrideGlobalRange` : false;
	int $overrideLayerSettings = `attributeExists deadlineOverrideLayerSettings defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineOverrideLayerSettings` : false;
	int $submitEachCamera = `attributeExists deadlineSubmitEachCamera defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineSubmitEachCamera` : false;
	int $ignoreDefaultCameras = `attributeExists deadlineIgnoreDefaultCameras defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineIgnoreDefaultCameras` : false;
	int $useMayaBatchPlugin = `attributeExists deadlineUseMayaBatchPlugin defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineUseMayaBatchPlugin` : true;
	int $localRendering = `attributeExists deadlineLocalRendering defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineLocalRendering` : false;
	int $strictErrorChecking = `attributeExists deadlineStrictErrorChecking defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineStrictErrorChecking` : true;
	string $startupScript = `attributeExists deadlineStartupScript defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineStartupScript` : "";
	string $mayaArgs = `attributeExists deadlineMayaArgs defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineMayaArgs` : "";
	
	int $submitMentalRayJob = `attributeExists deadlineSubmitMentalRayJob defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineSubmitMentalRayJob` : false;
	int $mentalRayThreads = `attributeExists deadlineMentalRayThreads defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineMentalRayThreads` : 0;
	int $mentalRayOffset = `attributeExists deadlineMentalRayOffset defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineMentalRayOffset` : 0;
	int $mentalRayLocalRendering = `attributeExists deadlineMentalRayLocalRendering defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineMentalRayLocalRendering` : false;
	string $mentalRayArgs = `attributeExists deadlineMentalRayArgs defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineMentalRayArgs` : "";
	
	//string $savedOutputFilePath = `attributeExists deadlineOutputFilePath defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineOutputFilePath` : GetImageDirectory();
	//string $projectPath = `attributeExists deadlineProjectPathOverride defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineProjectPathOverride` : `workspace -q -fullName`;	
	string $savedOutputFilePath = GetImageDirectory();
	string $projectPath = `workspace -q -fullName`;
	
	string $pmIntegration = `attributeExists deadlineProjectManagement defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineProjectManagement` : "Shotgun";	
	
	int $overrideGlobalRangeEnable = false;
	int $overrideLayerSettingsEnable = false;
	int $tileRenderingEnable = true;
	int $jigsawRenderingEnable = true;
	int $regionRendering = false;
	int $tilesInX = `attributeExists deadlineTilesInX defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineTilesInX` : 2;
	int $tilesInY = `attributeExists deadlineTilesInY defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineTilesInY` : 2;
	int $tileSingleJob = `attributeExists deadlineTileSingleJob defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineTileSingleJob` : true;
	int $tileDependentJob = `attributeExists deadlineTileDependentJob defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineTileDependentJob` : true;
	int $tileCompositeOver = `attributeExists deadlineTileCompositeOver defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineTileCompositeOver` : false;
	string $tileCompositeOverName = `attributeExists deadlineTileCompositeOverName defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineTileCompositeOverName` : "";
	int $tileCleanupJob = `attributeExists deadlineTileCleanupJob defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineTileCleanupJob` : false;
	
	int $tileErrorOnMissing = `attributeExists tileErrorOnMissing defaultRenderGlobals` ? `getAttr defaultRenderGlobals.tileErrorOnMissing` : true;
	int $tileMissingBackground = `attributeExists tileMissingBackground defaultRenderGlobals` ? `getAttr defaultRenderGlobals.tileMissingBackground` : true;
	
	int $redshiftGPUsPerTask = `attributeExists deadlineRedshiftGPUsPerTask defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineRedshiftGPUsPerTask` : 0;
	string $redshiftGPUsSelectDevices = `attributeExists deadlineRedshiftGPUsSelectDevices defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineRedshiftGPUsSelectDevices` : "";
	
	int $irayGPUsPerTask = `attributeExists deadlineIRayGPUsPerTask defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineIRayGPUsPerTask` : 0;
	string $irayGPUsSelectDevices = `attributeExists deadlineIRayGPUsSelectDevices defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineIRayGPUsSelectDevices` : "";
	int $irayUseCPUs = `attributeExists deadlineIRayUseCPUs defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineIRayUseCPUs` : 1;
	float $irayCPULoad = `attributeExists deadlineIRayCPULoad defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineIRayCPULoad` : 4.0;
	
	
	int $mentalRayAutoMemoryLimit = `attributeExists deadlineMentalRayAutoMemoryLimit defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineMentalRayAutoMemoryLimit` : true;
	int $mentalRayMemoryLimit = `attributeExists deadlineMentalRayMemoryLimit defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineMentalRayMemoryLimit` : 0;
	int $vrayAutoMemoryEnabled = `attributeExists deadlineVrayAutoMemoryEnabled defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineVrayAutoMemoryEnabled` : false;
	int $vrayAutoMemoryBuffer = `attributeExists deadlineVrayAutoMemoryBuffer defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineVrayAutoMemoryBuffer` : 500;
	
	string $mentalRayFilename = `attributeExists deadlineMentalRayFilename defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineMentalRayFilename` : "";
	
	string $vrayFilename = `attributeExists deadlineVRayFilename defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineVRayFilename` : "";
	int $submitVRayJob = `attributeExists deadlineSubmitVRayJob defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineSubmitVRayJob` : false;
	int $vrayThreads = `attributeExists deadlineVRayThreads defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineVRayThreads` : 0;
	
	int $submitVrimg2ExrJob = `attributeExists deadlineSubmitVrimg2ExrJob defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineSubmitVrimg2ExrJob` : false;
	int $deleteVrimgFiles = `attributeExists deadlineDeleteVrimgFiles defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineDeleteVrimgFiles` : false;
	
	int $exportRenderManThreads = `attributeExists deadlineExportRenderManThreads defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineExportRenderManThreads` : 0;
	int $renderRenderManWithRis = `attributeExists deadlineRenderRenderManWithRis defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineRenderRenderManWithRis` : true;
	int $submitRenderManJob = `attributeExists deadlineSubmitRenderManJob defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineSubmitRenderManJob` : false;
	int $renderManFrameDependent = `attributeExists deadlineRenderManFrameDependent defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineRenderManFrameDependent` : true;
	int $rendermanThreads = `attributeExists deadlineRenderManThreads defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineRenderManThreads` : 0;
	string $rendermanArgs = `attributeExists deadlineRenderManArgs defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineRenderManArgs` : "";
	
	int $submitArnoldJob = `attributeExists deadlineSubmitArnoldJob defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineSubmitArnoldJob` : false;
	int $exportArnoldLocal = `attributeExists deadlineExportArnoldLocal defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineExportArnoldLocal` : false;
	int $arnoldThreads = `attributeExists deadlineArnoldThreads defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineArnoldThreads` : 0;
	string $arnoldArgs = `attributeExists deadlineArnoldArgs defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineArnoldArgs` : "";

	int $submitMaxwellJob = `attributeExists deadlineSubmitMaxwellJob defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineSubmitMaxwellJob` : false;
	int $exportMaxwellLocal = `attributeExists deadlineExportMaxwellLocal defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineExportMaxwellLocal` : false;
	int $maxwellThreads = `attributeExists deadlineMaxwellThreads defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineMaxwellThreads` : 0;
	string $maxwellArgs = `attributeExists deadlineMaxwellArgs defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineMaxwellArgs` : "";

	string $draftTemplate = `attributeExists deadlineDraftTemplate defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineDraftTemplate` : "";
	string $draftUser = `attributeExists deadlineDraftUser defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineDraftUser` : "";
	string $draftEntity = `attributeExists deadlineDraftEntity defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineDraftEntity` : "";
	string $draftVersion = `attributeExists deadlineDraftVersion defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineDraftVersion` : "";
	string $draftExtraArgs = `attributeExists deadlineDraftExtraArgs defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineDraftExtraArgs` : "";
	
	int $submitDraftJob = `attributeExists deadlineUseDraft defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineUseDraft` : false;
	int $uploadDraftToShotgun = `attributeExists deadlineUploadDraftToShotgun defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineUploadDraftToShotgun` : false;
	
	int $draftQuick = `attributeExists deadlineDraftQuick defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineDraftQuick` : true;
	
	string $sgDisplayInfo = `attributeExists deadlineSGDisplayInfo defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineSGDisplayInfo` : "";
	string $sgVersionName = `attributeExists deadlineSGVersionName defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineSGVersionName` : "";
	string $sgDescription = `attributeExists deadlineSGDescription defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineSGDescription` : "";
	
	string $savedQuickDraftFormat = `attributeExists deadlineQuickDraftFormat defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineQuickDraftFormat` : "";
	string $savedQuickDraftCodec = `attributeExists deadlineQuickDraftCodec defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineQuickDraftCodec` : "";
	string $savedQuickDraftResolution = `attributeExists deadlineQuickDraftResolution defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineQuickDraftResolution` : "";
	string $savedQuickDraftFrameRate = `attributeExists deadlineQuickDraftFrameRate defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineQuickDraftFrameRate` : "24";
	int $savedQuickDraftQuality = `attributeExists deadlineQuickDraftQuality defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineQuickDraftQuality` : 85;
	
	
	if( `attributeExists deadlineSGInfoKeys defaultRenderGlobals` )
		$SGInfoKeys = `getAttr defaultRenderGlobals.deadlineSGInfoKeys`;
	else
		clear $SGInfoKeys;
	
	if( `attributeExists deadlineSGInfoValues defaultRenderGlobals` )
		$SGInfoValues = `getAttr defaultRenderGlobals.deadlineSGInfoValues`;
	else
		clear $SGInfoValues;
	
	if( `attributeExists deadlineFTInfoKeys defaultRenderGlobals` )
		$FTInfoKeys = `getAttr defaultRenderGlobals.deadlineFTInfoKeys`;
	else
		clear $FTInfoKeys;
	
	if( `attributeExists deadlineFTInfoValues defaultRenderGlobals` )
		$FTInfoValues = `getAttr defaultRenderGlobals.deadlineFTInfoValues`;
	else
		clear $FTInfoValues;
	
	tryGetFtrackData();
	
	//====================================================================================================
	// NIM
	
	int $uploadDraftToNim = `attributeExists deadlineUploadDraftToNim defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineUploadDraftToNim` : false;

	if( `attributeExists deadlineNimInfoKeys defaultRenderGlobals` )
		$NimInfoKeys = `getAttr defaultRenderGlobals.deadlineNimInfoKeys`;
	else
		clear $NimInfoKeys;
	
	if( `attributeExists deadlineNimInfoValues defaultRenderGlobals` )
		$NimInfoValues = `getAttr defaultRenderGlobals.deadlineNimInfoValues`;
	else
		clear $NimInfoValues;
	
	// END NIM
	//================
	
	
	// Read in maximum priority.
	string $priorityQuery = CallDeadlineCommand( "-getmaximumpriority", false );
	int $maximumPriority = (int) $priorityQuery;
	if( $maximumPriority == 0 )
		$maximumPriority = 100;
	
	if( $priority > $maximumPriority )
		$priority = ($maximumPriority / 2);
	
	// Read in the pools.
	string $deadlinePools[];
	string $poolsQuery = CallDeadlineCommand( "-pools", false );
	tokenize $poolsQuery "\n" $deadlinePools;
		
	// Read in the groups.
	string $deadlineGroups[];
	string $groupQuery = CallDeadlineCommand( "-groups", false );
	tokenize $groupQuery "\n" $deadlineGroups;
	
	
	ReadQuickDraftFiles();
	
	// Get the frame range.
	int $range[] = GetFrameRange();
	int $fromFrame = $range[0];
	int $toFrame = $range[1];
	int $byFrame = $range[2];
	
	int $currTime = `currentTime -query`;
	
	string $frameRange = $fromFrame + "-" + $toFrame;
	if( $byFrame > 1 )
		$frameRange = $frameRange + "x" + $byFrame;
	
	int $renderHalfFrames = false;
	if( $byFrame == 0.5 )
		$renderHalfFrames = true;
	
	// Get the CPU count
	int $cpuEnabled = EnableCpuOption( $renderer );
	int $cpus = 0;
	if( $cpuEnabled )
		$cpus = GetCpuSetting( $renderer );
	
	// Get if layers are enabled
	$renderLayerEnabled = IsRenderLayersOn();
	
	// Delete any previous windows.
	if( `window -exists DeadlineSubmitWindow` )
		deleteUI -window DeadlineSubmitWindow;
	
	// Create a new submission dialog window.
	string $window = `window DeadlineSubmitWindow`;
	if( `windowPref -exists DeadlineSubmitWindow` )
		windowPref -remove DeadlineSubmitWindow; // reset preference
	
	// Get the location of the main window.
	global string $gMainWindow;
	int $mainTopLeft[] = `window -q -tlc $gMainWindow`;
	
	// Add controls to the submission dialog.
	int $windowWidth = 560;
	int $windowHeight = 760;
	
	int $labelWidth = 160;
	int $controlWidth = 330;
	
	string $maxwellScript = "";
	if( `attributeExists mxsPath maxwellRenderOptions` )
	{
		$maxwellScript = `getAttr maxwellRenderOptions.mxsPath`;
	}
	if( $maxwellScript == "" )
	{
		string $exportDir = `workspace -q -fre "translatorData"`;
		string $sceneName = GetStrippedSceneFileName();
		
		$maxwellScript = $projectPath +"/" + $exportDir + "/"+$sceneName + ".mxs";
		
	}
	
	$DeadlineSubmitterWindow = `window -e -resizeToFitChildren true -sizeable true -title "Submit Job To Deadline" -widthHeight ($windowWidth+24) $windowHeight -tlc ($mainTopLeft[0] + 50) ($mainTopLeft[1] + 50) DeadlineSubmitWindow`;
	formLayout -width ($windowWidth+16) -nd 100 mainFormLayout;
	
	scrollLayout -width ($windowWidth+16) -horizontalScrollBarThickness 0 mainScrollLayout;
	
		$MainTabLayout = `tabLayout frw_mainTabLayout`;
			columnLayout -adj true -columnAttach "both" 4 mayaTabLayout;
			
				frameLayout -label "Job Description" -labelVisible true -borderVisible false -collapsable true;
					columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
						$JobNameGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Job Name" -buttonLabel "<" -text $jobName -changeCommand SavePersistentDeadlineOptions -annotation "The name of the job (press '<' button to use the scene file name)" frw_JobName`;
						textFieldButtonGrp -e -bc SetJobName $JobNameGrp;
						
						textFieldGrp -label "Comment" -cl2 "left" "left" -cw2 $labelWidth 320 -text $jobComment -changeCommand SavePersistentDeadlineOptions -annotation "A brief comment about the job" frw_JobComment;
						textFieldGrp -label "Department" -cl2 "left" "left" -cw2 $labelWidth 320 -text $department -changeCommand SavePersistentDeadlineOptions -annotation "The department the job (or the job's user) belongs to" frw_Department;
					setParent ..;
				setParent ..;
			
				frameLayout -label "Job Scheduling" -labelVisible true -borderVisible false -collapsable true;
					columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
						string $poolsBox = `optionMenuGrp -label "Pool" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "The pool the job belongs to" frw_deadlinePool`;
						for( $i = 0; $i < size($deadlinePools); ++$i )
						{ 
							menuItem -label $deadlinePools[$i];
							if( $deadlinePools[$i] == $savedJobPool )
								optionMenuGrp -e -select ($i+1) $poolsBox;
						}
						
						string $secondaryPoolsBox = `optionMenuGrp -label "Secondary Pool" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "The secondary pool lets you specify a Pool to use if the primary Pool does not have any available Slaves" frw_deadlineSecondaryPool`;
						menuItem -label "";
						if( "" == $savedJobSecondaryPool )
							optionMenuGrp -e -select 1 $secondaryPoolsBox;
						
						for( $i = 0; $i < size($deadlinePools); ++$i )
						{ 
							menuItem -label $deadlinePools[$i];
							if( $deadlinePools[$i] == $savedJobSecondaryPool )
								optionMenuGrp -e -select ($i+2) $secondaryPoolsBox;
						}
							
						string $groupsBox = `optionMenuGrp -label "Group" -cl2 "left" "left" -cw2 $labelWidth 320 -changeCommand SavePersistentDeadlineOptions -annotation "The group the job belongs to" frw_Group`;
						for( $i = 0; $i < size( $deadlineGroups ); ++$i )
						{ 
							menuItem -label $deadlineGroups[$i];
							if( $deadlineGroups[$i] == $savedGroup )
								optionMenuGrp -e -select ($i+1) $groupsBox;
						}
						
						intSliderGrp -label "Priority" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue $maximumPriority -v $priority -changeCommand SavePersistentDeadlineOptions -annotation "The job's priority (0 is the lowest, 100 is the highest)" frw_JobPriority;
						intSliderGrp -label "Machine Limit" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 1000 -v $limitCount -changeCommand SavePersistentDeadlineOptions -annotation "Limit the number of machines that can render this job concurrently (specify 0 for no machine limit)" frw_LimitCount;
						intSliderGrp -label "Concurrent Tasks" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 1 -maxValue 16 -v $concurrentTasks -changeCommand SavePersistentDeadlineOptions -annotation "The number of tasks a slave can dequeue for this job simultaneously" frw_ConcurrentTasks;
						intSliderGrp -label "Task Timeout" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 5000 -v $SlaveTimeout -changeCommand SavePersistentDeadlineOptions -annotation "The number of minutes a slave has to render an individual task before timing out (specify 0 for no limit)" frw_SlaveTimeout;
						intSliderGrp -label "Minimum Task Time" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 5000 -v $MinSlaveTimeout -changeCommand SavePersistentDeadlineOptions -annotation "The minimum number of minutes a slave should render a task for, otherwise an error will be reported (specify 0 for no minimum)" frw_MinSlaveTimeout;
						
						$LimitGroupGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Limit Groups" -buttonLabel "..." -text $limitGroups -changeCommand SavePersistentDeadlineOptions -annotation "The limit groups that this job requires." frw_limitGroups`;
						textFieldButtonGrp -e -bc SetLimitGroups $LimitGroupGrp;
							
						$DependenciesGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Dependencies" -buttonLabel "..." -text $dependencies -changeCommand SavePersistentDeadlineOptions -annotation "The jobs that this job is dependent on." frw_dependencies`;
						textFieldButtonGrp -e -bc SetDependencies $DependenciesGrp;
						
						$MachineListGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Machine List" -buttonLabel "..." -text $machineList -changeCommand SavePersistentDeadlineOptions -annotation "The whitelist or blacklist for the job." frw_machineList`;
						textFieldButtonGrp -e -bc SetMachineList $MachineListGrp;
						print("Machine list is "+$MachineListGrp);
						
						rowLayout -numberOfColumns 2 -cw2 (160 + $labelWidth) 160 -ct2 "left" "left";
							string $onCompleteBox = `optionMenuGrp -label "On Complete" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "What to do with the job after it completes." frw_onComplete`;
							menuItem -label "Nothing";
							menuItem -label "Archive";
							menuItem -label "Delete";
							optionMenuGrp -e -select (1) $onCompleteBox;
							
							checkBox -label "Machine List is a Blacklist" -v $isBlacklist -changeCommand SavePersistentDeadlineOptions -annotation "If checked, the machine list will be a blacklist. Otherwise, it is a whitelist." frw_isBlacklist;
						setParent ..;
						
						rowLayout -numberOfColumns 3 -cw3 $labelWidth 158 160 -ct3 "left" "left" "left";
							text -align "left" -label "" frw_dummySubmitSuspendedLabel;
							checkBox -label "Submit As Suspended" -v $submitAsSuspended -changeCommand SavePersistentDeadlineOptions -annotation "If checked, this job will be submitted in the suspended state" frw_submitAsSuspended;
							checkBox -label "Close on Submission" -v $closeOnSubmission -changeCommand SavePersistentDeadlineOptions -annotation "If checked, the submitter will close after job submission is completed" frw_closeOnSubmission;
						setParent ..;						
						
					setParent ..;
				setParent ..;
				
				frameLayout -label "Render Options" -labelVisible true -borderVisible false -collapsable true;
					columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
						int $framesEnabled = true;
						if( $renderLayerEnabled && $submitEachRenderLayer )
							$framesEnabled = $overrideLayerSettings;
						$framesEnabled = $framesEnabled && IsAnimatedOn();
						
						textFieldGrp -label "Frame List" -en $framesEnabled -cl2 "left" "left" -cw2 $labelWidth 320 -changeCommand SavePersistentDeadlineOptions -annotation "Enter a list of frames to render, separated by commas for separate frames, or dashes for continuous sequences of frames. e.g. 1, 5-10, 100" -text $frameRange frw_FrameList;
						intSliderGrp -label "Frames Per Task" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 1 -maxValue 1000 -v $chunkSize -changeCommand SavePersistentDeadlineOptions -annotation "Each task for the job will consist of this many frames" frw_FrameGroup;
						
						frameLayout -label "Additional Frame Options" -labelVisible true -borderVisible false -collapsable true -collapse true;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								
								string $renderPreviewJobFirstBox = `checkBox -en $framesEnabled -label "Render Preview Job First" -changeCommand SavePersistentDeadlineOptions -annotation "When checked, two jobs will be submitted - a PREVIEW job with a fraction of the frames, and a REST job with all other frames.\n\nThe PREVIEW job can be submitted with slightly higher priority and will provide a glimpse into the final result.\n\nIf its output looks incorrect, you can suspend the REST job before wasting render time rendering a wrong submission." frw_renderPreviewJobFirst`;
								intSliderGrp -label "Priority Offset" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 1 -maxValue $maximumPriority -v 5 -changeCommand SavePersistentDeadlineOptions -annotation "Defines the Priority Increase for the PREVIEW job.\n\nFor example if the Job Priority is set to 50 and this value is +5, the PREVIEW job will be submitted with Priority of 55 and the REST job with 50." frw_PreviewPriority;
								intSliderGrp -label "Number of Preview Frames" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 1 -maxValue 1000 -v 5 -changeCommand SavePersistentDeadlineOptions -annotation "Defines the number of frames to be submitted as a PREVIEW job.\n\nThe frames will be taken at equal intervals, for example a value of 2 will send the first and last frames, a value of 3 will send first, middle and last and so on." frw_PreviewFrames;
								checkBox -en $framesEnabled -label "Submit Dependent Job With Remaining Frames" -changeCommand SavePersistentDeadlineOptions -annotation "When checked, the [REST OF FRAMES] Job will be made dependent on the [PREVIEW FRAMES] Job.\n\nWhen unchecked, the [REST OF FRAMES] Job will use the same dependencies (none or custom) as the [PREVIEW FRAMES] Job." frw_dependent;
								
								rowLayout -numberOfColumns 1 -cw1 $labelWidth -ct1 "left";
									string $outOfOrderBox = `optionMenuGrp -label "Task Order" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "Defines the Order in which the Task List will be processed." frw_taskOrder`;
									menuItem -label "First To Last (Forward)";
									menuItem -label "Every Nth, Then Forward";
									menuItem -label "Every Nth - Block Fill";
									menuItem -label "Every Nth - Half Raster Refine";
									menuItem -label "Last To First (Reverse)";
									menuItem -label "First And Last Frames First";
									menuItem -label "From Both Ends";
									menuItem -label "From Center";
									menuItem -label "From Both Ends And From Center";
									menuItem -label "Random";
									optionMenuGrp -e -select (1) $outOfOrderBox;
								setParent ..;
								
								intSliderGrp -label "Out Of Order Step" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 1 -maxValue 1000 -v 2 -changeCommand SavePersistentDeadlineOptions -annotation "Defines the Nth frame step to use for the Task List Order settings." frw_taskOrderStep;
						
							setParent..;
						setParent..;
						
						rowLayout -numberOfColumns 1 -cw 1 400 -ct1 "left";
							string $camerasBox = `optionMenuGrp -label "Camera" -cl2 "left" "left" -cw2 $labelWidth 320 -changeCommand SavePersistentDeadlineOptions -annotation "Leave blank to render using the default camera settings." frw_camera`;
							//string $cameraList[] = `ls -cameras`;
							menuItem -label " ";
							//int $i; for( $i = 0; $i < size($cameraList); ++$i )
							//	menuItem -label $cameraList[$i];
						
							string $cameraNames[] = `listTransforms -cameras`;
							for( $cameraName in $cameraNames )
								menuItem -label $cameraName;
						
							optionMenuGrp -e -select (1) $camerasBox;
						setParent ..;
						
						$ProjectPathGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Project Path" -buttonLabel "..." -text $projectPath -changeCommand SavePersistentDeadlineOptions -annotation "Use this Maya project path to load the Maya scene" frw_projectPath`;
						textFieldButtonGrp -e -bc SetProjectDir $ProjectPathGrp;
						
						$ImageOutputPathGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Output Path" -buttonLabel "..." -text $savedOutputFilePath -changeCommand SavePersistentDeadlineOptions -annotation "The path to which the output files will be sent. Must be network accessible." frw_outputFilePath`;
						textFieldButtonGrp -e -bc SetImageDir $ImageOutputPathGrp;
						
						$mayaBuildEnabled = true;
						rowLayout -numberOfColumns 2 -cw2 (160 + $labelWidth) 160 -ct2 "left" "left";
							string $mayaBuildBox = `optionMenuGrp -en $mayaBuildEnabled -label "Maya Build" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "Force Deadline to render using the specified build of Maya" frw_mayaBuild`;
							menuItem -label "None";
							menuItem -label "32bit";
							menuItem -label "64bit";
							if( $mayaBuildEnabled )
							{
								if( `about -macOS` )
									optionMenuGrp -e -select (1) $mayaBuildBox;
								else
								{
									if( `about -is64` )
										optionMenuGrp -e -select (3) $mayaBuildBox;
									else
										optionMenuGrp -e -select (2) $mayaBuildBox;
								}
							}
							else
								optionMenuGrp -e -select (1) $mayaBuildBox;
							
							string $submitMayaSceneBox = `checkBox -label "Submit Maya Scene File" -v $submitMayaScene -changeCommand SavePersistentDeadlineOptions -annotation "If unchecked, the Maya scene file should be network accessible" frw_submitMayaScene`;
						setParent ..;
							 
						rowLayout -numberOfColumns 3 -cw3 $labelWidth 158 160 -ct3 "left" "left" "left";
							text -align "left" -label "" frw_dummyMayaBatchLabel;
							checkBox -label "Use MayaBatch Plugin" -align "left" -v $useMayaBatchPlugin -changeCommand SavePersistentDeadlineOptions -annotation "The MayaBatch plugin is a new Maya plugin which keeps the scene loaded between frames" frw_useMayaBatchPlugin;
							checkBox -enable (!$useMayaBatchPlugin) -label "Ignore Error Code 211" -align "left" -v 0 -annotation "Does not fail and requeue the render on an Exit Code of 211. Useful if the render actually succeeds and is still throwing this error." frw_ignoreError211;
						setParent ..;
						
						$StartupScriptPathGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Startup Script" -buttonLabel "..." -text $startupScript -changeCommand SavePersistentDeadlineOptions -annotation "Maya will source the specified script file on startup" frw_startupScript`;
						textFieldButtonGrp -e -bc SetStartupScriptPath $StartupScriptPathGrp;
						
						textFieldGrp -enable (!$useMayaBatchPlugin) -label "Command Line Args" -cl2 "left" "left" -cw2 $labelWidth 320 -text $mayaArgs -changeCommand SavePersistentDeadlineOptions -annotation "Additional command line options to pass to Maya" frw_mayaArgs;
						
						string $mayaJobTypeBox = `optionMenuGrp -label "Deadline Job Type" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand UpdateJobType -annotation "Select the type of job that you want to submit to Deadline" frw_mayaJobType`;
						menuItem -label "Maya Render Job";
						menuItem -label "Mental Ray Export Job";
						menuItem -label "VRay Export Job";
						menuItem -label "RenderMan Export Job";
						menuItem -label "Arnold Export Job";
						menuItem -label "Maxwell Export Job";
						menuItem -label "Bifrost Simulation Job";
						menuItem -label "Alembic Export Job";
						menuItem -label "Maya Script Job";
						menuItem -label "Fluid Caching Job";
						menuItem -label "Geometry Caching Job";

						optionMenuGrp -e -select (1) $mayaJobTypeBox;
						
						$MayaRenderOptionsRollout = `frameLayout -label "Maya Render Job" -labelVisible true -borderVisible false -collapsable true`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								rowLayout -numberOfColumns 1 -cw 1 400 -ct1 "left";
									text -align "left" -label "Renders a normal Maya job using the current Maya renderer." frw_tileLabel;
								setParent ..;
								
								intSliderGrp -en $cpuEnabled -label "Threads" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 64 -v $cpus -changeCommand SavePersistentDeadlineOptions -annotation  "The number of processors to use during rendering (specify 0 to use all processors available)" frw_MaxCPUs;
								
								int $frameNumberOffsetEnabled = IsAnimatedOn();
								intSliderGrp -label "Frame Number Offset" -en $frameNumberOffsetEnabled -cal 1 "left" -cw 1 $labelWidth -field true -minValue -10000 -maxValue 10000 -v 0 -changeCommand SavePersistentDeadlineOptions -annotation  "Uses Maya's frame renumbering option to offset the frames that are rendered" frw_frameNumberOffset;
								
								if( $renderLayerEnabled )
								{
									$tileRenderingEnable = $submitEachRenderLayer; // use to submit as separate job value for the tile rendering enable
									$overrideGlobalRangeEnable = $submitEachRenderLayer;
									$overrideLayerSettingsEnable = $submitEachRenderLayer;
									if( !$submitEachRenderLayer )
										$regionRendering = false;
								}
								
								rowLayout -numberOfColumns 2 -cw2 260 160 -ct2 "left" "left";
									string $submitEachRenderLayerBox = `checkBox -en $renderLayerEnabled -label "Submit Render Layers As Separate Jobs" -v $submitEachRenderLayer -changeCommand SavePersistentDeadlineOptions -annotation "Check this to submit each renderable Render Layer as a separate Deadline job. Note that the frame range will be pulled from the render globals for each layer." frw_submitEachRenderLayer`;
									checkBox -enable $overrideLayerSettingsEnable -label "Override Layer Job Settings" -v $overrideLayerSettings -changeCommand SavePersistentDeadlineOptions -annotation "If checked, the job name, frame range, and task size can be set for each render layer when submitting a separate job for each layer" frw_overrideLayerSettings;
								setParent ..;
								
								rowLayout -numberOfColumns 2 -cw2 260 160 -ct2 "left" "left";
									checkBox -label "Submit Cameras As Separate Jobs" -align "left" -v $submitEachCamera -changeCommand SavePersistentDeadlineOptions -annotation "Check this to submit each renderable Camera as a separate Deadline job." frw_submitEachCamera;
									checkBox -enable ($submitEachCamera) -label "Ignore Default Cameras" -align "left" -v $ignoreDefaultCameras -changeCommand SavePersistentDeadlineOptions -annotation "Check this to ignore default cameras (persp, top, etc) when submitting each renderable Camera as a separate Deadline job." frw_ignoreDefaultCameras;
								setParent ..;
								
								rowLayout -numberOfColumns 2 -cw2 260 160 -ct2 "left" "left";
									checkBox -label "Enable Local Rendering" -align "left" -v $localRendering -changeCommand SavePersistentDeadlineOptions -annotation "If this option is set to true, the slaves will render locally, and then copy the images to the network output directory on completion" frw_localRendering;
									checkBox -label "Strict Error Checking" -align "left" -v $strictErrorChecking -changeCommand SavePersistentDeadlineOptions -annotation "If checked, Deadline will fail the render job if any error message is detected" frw_strictErrorChecking;
								setParent ..;
								
								rowLayout -numberOfColumns 2 -cw2 260 160 -ct2 "left" "left";
									$halfFramesEnabled = ShowHalfFramesOption( $renderer );
									checkBox -en $halfFramesEnabled -label "Render Half Frames" -v $renderHalfFrames -changeCommand SavePersistentDeadlineOptions -annotation "If checked, frames will be split into two using a step of 0.5" frw_renderHalfFrames;
								setParent ..;
							setParent ..;
						setParent ..;
						
						$MayaRenderOptionsArnoldRollout = `frameLayout -label "Arnold Options" -labelVisible true -borderVisible false -collapsable true -visible ($renderer == "arnold")`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								
								$arnoldVerboseEnabled = ( $renderer == "arnold" );
								string $arnoldVerboseBox = `optionMenuGrp -en $arnoldVerboseEnabled -label "Arnold Verbosity" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "Set the verbosity level for Arnold renders" frw_arnoldVerbose`;
								menuItem -label "0";
								menuItem -label "1";
								menuItem -label "2";
								if( $arnoldVerboseEnabled )
									optionMenuGrp -e -select (2) $arnoldVerboseBox;
							setParent ..;
						setParent ..;
						
						$MayaRenderOptionsMentalRayRollout = `frameLayout -label "Mental Ray Options" -labelVisible true -borderVisible false -collapsable true -visible ($renderer == "mentalRay")`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								
								$mentalRayVerboseEnabled = ( $renderer == "mentalRay" );
								string $mentalRayVerboseBox = `optionMenuGrp -en $mentalRayVerboseEnabled -label "Mental Ray Verbosity" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "Set the verbosity level for Mental Ray renders" frw_mentalRayVerbose`;
								menuItem -label "No Messages";
								menuItem -label "Fatal Messages Only";
								menuItem -label "Error Messages";
								menuItem -label "Warning Messages";
								menuItem -label "Info Messages";
								menuItem -label "Progress Messages";
								menuItem -label "Detailed Messages (Debug)";
								if( $mentalRayVerboseEnabled )
									optionMenuGrp -e -select (6) $mentalRayVerboseBox;
								
								checkBox -label "Auto Memory Limit" -align "left" -v $mentalRayAutoMemoryLimit -changeCommand SavePersistentDeadlineOptions -annotation "If checked, Mental Ray will automatically detect the optimal memory limit when rendering" frw_autoMemoryLimit;
								
								intSliderGrp -enable (!$mentalRayAutoMemoryLimit) -label "Memory Limit (MB)" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 100000 -v $mentalRayMemoryLimit -changeCommand SavePersistentDeadlineOptions -annotation  "Soft limit (in MB) for the memory used by Mental Ray (specify 0 for unlimited memory)" frw_memoryLimit;
								
							setParent ..;
						setParent ..;

						$MayaRenderOptionsRedshiftRollout = `frameLayout -label "Redshift Options" -labelVisible true -borderVisible false -collapsable true -visible ($renderer == "redshift")`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								intSliderGrp -enable (strcmp($redshiftGPUsSelectDevices, "") == 0) -label "GPUs Per Task" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 16 -v $redshiftGPUsPerTask -changeCommand SavePersistentDeadlineOptions -annotation  "The number of GPUs to use per task. If set to 0, the default number of GPUs will be used." frw_redshiftGPUsPerTask;

								rowLayout -numberOfColumns 2 -cw2 (160 + $labelWidth) 160 -ct2 "left" "left";
									textFieldGrp -enable ($redshiftGPUsPerTask == 0) -label "Select GPU Devices" -cl2 "left" "left" -cw2 $labelWidth 320 -text $redshiftGPUsSelectDevices -textChangedCommand SavePersistentDeadlineOptions -annotation "A comma separated list of the GPU devices to use specified by device Id. 'GPUs Per Task' will be ignored." frw_redshiftGPUsSelectDevices;

									// the "placeholderText" parameter did not exist until Maya 2013 Extension Pack
									if ( getApplicationVersionAsFloat() > 2013)
									{
										textFieldGrp -e -placeholderText "Enter Valid GPU Device Id(s): 0 or 1 or 0,2 or 0,3,4 etc" frw_redshiftGPUsSelectDevices;
									}
								setParent ..;
								$redshiftVerboseEnabled = ( $renderer == "redshift" );
								string $redshiftVerboseBox = `optionMenuGrp -en $redshiftVerboseEnabled -label "Redshift Verbosity" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "Set the verbosity level for Redshift renders" frw_redshiftVerbose`;
								menuItem -label "Errors and Warnings";
								menuItem -label "Detailed Info";
								menuItem -label "Debug";
								if( $redshiftVerboseEnabled )
									optionMenuGrp -e -select (3) $redshiftVerboseBox;
							setParent ..;
						setParent ..;
												
						$MayaRenderOptionsIRayRollout = `frameLayout -label "IRay Options" -labelVisible true -borderVisible false -collapsable true -visible ($renderer == "ifmIrayPhotoreal")`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								intSliderGrp -enable (strcmp($irayGPUsSelectDevices, "") == 0) -label "GPUs Per Task" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 16 -v $irayGPUsPerTask -changeCommand SavePersistentDeadlineOptions -annotation  "The number of GPUs to use per task. If set to 0, the default number of GPUs will be used." frw_irayGPUsPerTask;

								rowLayout -numberOfColumns 2 -cw2 (160 + $labelWidth) 160 -ct2 "left" "left";
									textFieldGrp -enable ($irayGPUsPerTask == 0) -label "Select GPU Devices" -cl2 "left" "left" -cw2 $labelWidth 320 -text $irayGPUsSelectDevices -textChangedCommand SavePersistentDeadlineOptions -annotation "A comma separated list of the GPU devices to use specified by device Id. 'GPUs Per Task' will be ignored." frw_irayGPUsSelectDevices;
									
									// the "placeholderText" parameter did not exist until Maya 2013 Extension Pack
									if ( getApplicationVersionAsFloat() > 2013)
									{
										textFieldGrp -e -placeholderText "Enter Valid GPU Device Id(s): 0 or 1 or 0,2 or 0,3,4 etc" frw_irayGPUsSelectDevices;
									}
									
								setParent ..;
								
								checkBox -label "Render Using CPUs" -v $irayUseCPUs -changeCommand SavePersistentDeadlineOptions -annotation "If this option is set to true, then the CPUs will be used as part of the render." frw_irayUseCPUs;
								floatSliderGrp -enable ( $irayUseCPUs ) -label "CPU Load" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 1.0 -maxValue 8.0 -v $irayCPULoad -changeCommand SavePersistentDeadlineOptions -annotation  "The maximum CPU load each task can use." frw_irayCPULoad;

							setParent ..;
						setParent ..;
								
						$MayaRenderOptionsVRayRollout = `frameLayout -label "VRay Options" -labelVisible true -borderVisible false -collapsable true -visible ($renderer == "vray")`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								checkBox -enable $useMayaBatchPlugin -label "Auto Memory Limit Detection (Requires the MayaBatch Plugin)" -align "left" -v $vrayAutoMemoryEnabled -changeCommand SavePersistentDeadlineOptions -annotation "If checked, Deadline will automatically detect the dynamic memory limit for VRay prior to rendering." frw_vrayAutoMemoryEnabled;
								
								intSliderGrp -enable ($useMayaBatchPlugin && $vrayAutoMemoryEnabled) -label "Memory Buffer (MB)" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 100000 -v $vrayAutoMemoryBuffer -changeCommand SavePersistentDeadlineOptions -annotation  "Deadline subtracts this value from the system's unused memory to determine the dynamic memory limit for VRay." frw_vrayAutoMemoryBuffer;
								
							setParent ..;
						setParent ..;
						
						$MentalRayExportRollout = `frameLayout -label "Mental Ray Export Job" -labelVisible true -borderVisible false -collapsable true -visible false`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								rowLayout -numberOfColumns 1 -cw 1 400 -ct1 "left";
									text -align "left" -label "Uses Mental Ray to export mi files instead of rendering." frw_tileLabel;
								setParent ..;
								
								rowLayout -numberOfColumns 2 -cw2 $labelWidth 320 -ct2 "left" "right";
									$MentalRayFilenameGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Output File" -buttonLabel "..." -text $mentalRayFilename -changeCommand SavePersistentDeadlineOptions -annotation "The full filename of the Mental Ray files that will be exported (padding is handled automatically by the exporter)" frw_mentalRayFilePath`;
									textFieldButtonGrp -e -bc SetMentalRayFilename $MentalRayFilenameGrp;
								setParent ..;
								
								rowLayout -numberOfColumns 2 -cw2 110 290 -ct2 "left" "left";
									button -label "Export Settings..." -width 100 -c OpenExportSettings -height 26 -annotation "Opens the Export Settings dialog";
									text -label "(This dialog must be open when submitting the job)";
								setParent ..;
							setParent ..;
						setParent ..;
						
						$MentalRayExportRenderJobRollout = `frameLayout -label "Mental Ray Render Job" -labelVisible true -borderVisible false -collapsable true -visible false`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								checkBox -label "Submit Dependent Mental Ray Standalone Render Job" -align "left" -v $submitMentalRayJob -changeCommand SavePersistentDeadlineOptions -annotation "If this option is set to true, a Mental Ray Standalone job that is dependent on the export job will also be submitted" frw_submitMentalRayJob;
								
								string $mentalPoolsBox = `optionMenuGrp -label "Pool" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "The pool the job belongs to" frw_deadlineMentalPool`;
								for( $i = 0; $i < size($deadlinePools); ++$i )
								{ 
									menuItem -label $deadlinePools[$i];
									if( $deadlinePools[$i] == $savedJobPool )
										optionMenuGrp -e -select ($i+1) $mentalPoolsBox;
								}
								
								string $secondaryMentalPoolsBox = `optionMenuGrp -label "Secondary Pool" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "The secondary pool lets you specify a Pool to use if the primary Pool does not have any available Slaves" frw_deadlineMentalSecondaryPool`;
								menuItem -label "";
								if( "" == $savedJobSecondaryPool )
									optionMenuGrp -e -select 1 $secondaryMentalPoolsBox;
								
								for( $i = 0; $i < size($deadlinePools); ++$i )
								{ 
									menuItem -label $deadlinePools[$i];
									if( $deadlinePools[$i] == $savedJobSecondaryPool )
										optionMenuGrp -e -select ($i+2) $secondaryMentalPoolsBox;
								}
									
								string $groupsMentalBox = `optionMenuGrp -label "Group" -cl2 "left" "left" -cw2 $labelWidth 320 -changeCommand SavePersistentDeadlineOptions -annotation "The group the job belongs to" frw_MentalGroup`;
								for( $i = 0; $i < size( $deadlineGroups ); ++$i )
								{ 
									menuItem -label $deadlineGroups[$i];
									if( $deadlineGroups[$i] == $savedGroup )
										optionMenuGrp -e -select ($i+1) $groupsMentalBox;
								}
								
								intSliderGrp -label "Priority" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue $maximumPriority -v $priority -changeCommand SavePersistentDeadlineOptions -annotation "The job's priority (0 is the lowest, 100 is the highest)" frw_MentalJobPriority;
								intSliderGrp -label "Machine Limit" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 1000 -v $limitCount -changeCommand SavePersistentDeadlineOptions -annotation "Limit the number of machines that can render this job concurrently (specify 0 for no machine limit)" frw_MentalLimitCount;
								intSliderGrp -label "Concurrent Tasks" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 1 -maxValue 16 -v $concurrentTasks -changeCommand SavePersistentDeadlineOptions -annotation "The number of tasks a slave can dequeue for this job simultaneously" frw_MentalConcurrentTasks;
								intSliderGrp -label "Task Timeout" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 5000 -v $SlaveTimeout -changeCommand SavePersistentDeadlineOptions -annotation "The number of minutes a slave has to render an individual task before timing out (specify 0 for no limit)" frw_MentalSlaveTimeout;
								intSliderGrp -label "Minimum Task Time" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 5000 -v $MinSlaveTimeout -changeCommand SavePersistentDeadlineOptions -annotation "The minimum number of minutes a slave should render a task for, otherwise an error will be reported (specify 0 for no minimum)" frw_MentalMinSlaveTimeout;
								
								$MentalLimitGroupGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Limit Groups" -buttonLabel "..." -text "" -changeCommand SavePersistentDeadlineOptions -annotation "The limit groups that this job requires." frw_MentalLimitGroups`;
								textFieldButtonGrp -e -bc SetMentalLimitGroups $MentalLimitGroupGrp;
								
								$MentalMachineListGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Machine List" -buttonLabel "..." -text "" -changeCommand SavePersistentDeadlineOptions -annotation "The whitelist or blacklist for the job." frw_MentalMachineList`;
								textFieldButtonGrp -e -bc SetMentalMachineList $MentalMachineListGrp;
								
								rowLayout -numberOfColumns 2 -cw2 (160 + $labelWidth) 160 -ct2 "left" "left";
									string $MentalOnCompleteBox = `optionMenuGrp -label "On Complete" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "What to do with the job after it completes." frw_MentalOnComplete`;
									menuItem -label "Nothing";
									menuItem -label "Archive";
									menuItem -label "Delete";
									optionMenuGrp -e -select (1) $MentalOnCompleteBox;
									
									checkBox -label "Machine List is a Blacklist" -v $isBlacklist -changeCommand SavePersistentDeadlineOptions -annotation "If checked, the machine list will be a blacklist. Otherwise, it is a whitelist." frw_MentalIsBlacklist;
								setParent ..;
								
								intSliderGrp -label "Threads" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 256 -v $mentalRayThreads -changeCommand SavePersistentDeadlineOptions -annotation  "The number of threads to use during rendering (specify 0 to use all processors available)" frw_mentalRayThreads;
								
								intSliderGrp -label "Frame Offset" -cal 1 "left" -cw 1 $labelWidth -field true -minValue -10000 -maxValue 10000 -v $mentalRayOffset -changeCommand SavePersistentDeadlineOptions -annotation  "The value to offset the frame numbers by when rendering separate mi files per frame" frw_mentalRayOffset;
								
								rowLayout -numberOfColumns 2 -cw2 (160 + $labelWidth) 160 -ct2 "left" "left";
									string $mentalRayBuildBox = `optionMenuGrp -label "Mental Ray Build" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "Force Deadline to render using the specified build of Maya" frw_mentalRayBuild`;
									menuItem -label "None";
									menuItem -label "32bit";
									menuItem -label "64bit";
									if( $mayaBuildEnabled )
									{
										if( `about -is64` )
											optionMenuGrp -e -select (3) $mentalRayBuildBox;
										else
											optionMenuGrp -e -select (2) $mentalRayBuildBox;
									}
									else
										optionMenuGrp -e -select (1) $mentalRayBuildBox;
									
									checkBox -label "Enable Local Rendering" -v $mentalRayLocalRendering -changeCommand SavePersistentDeadlineOptions -annotation "If this option is set to true, the slaves will render locally, and then copy the images to the network output directory on completion" frw_mentalRayLocalRendering;
								setParent ..;
								
								textFieldGrp -label "Command Line Args" -cl2 "left" "left" -cw2 $labelWidth 320 -text $mentalRayArgs -changeCommand SavePersistentDeadlineOptions -annotation "Additional command line options to pass to mental ray" frw_mentalRayArgs;
							setParent ..;
						setParent ..;
						
						$VrayExportRollout = `frameLayout -label "VRay Export Job" -labelVisible true -borderVisible false -collapsable true -visible false`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								rowLayout -numberOfColumns 1 -cw 1 400 -ct1 "left";
									text -align "left" -label "Uses VRay to export vrscene files instead of rendering." frw_tileLabel;
								setParent ..;
								
								rowLayout -numberOfColumns 2 -cw2 $labelWidth 320 -ct2 "left" "right";
									$VRayFilenameGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Output File" -buttonLabel "..." -text $vrayFilename -changeCommand SavePersistentDeadlineOptions -annotation "The full filename of the VRay files that will be exported (padding is handled automatically by the exporter)" frw_vrayFilePath`;
									textFieldButtonGrp -e -bc SetVRayFilename $VRayFilenameGrp;
								setParent ..;
							setParent ..;
						setParent ..;
							
						$VrayExportRenderJobRollout = `frameLayout -label "VRay Render Job" -labelVisible true -borderVisible false -collapsable true -visible false`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								checkBox -label "Submit Dependent VRay Standalone Render Job" -align "left" -v $submitVRayJob -changeCommand SavePersistentDeadlineOptions -annotation "If this option is set to true, a VRay Standalone job that is dependent on the export job will also be submitted" frw_submitVRayJob;
								string $vrayPoolsBox = `optionMenuGrp -label "Pool" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "The pool the job belongs to" frw_deadlineVrayPool`;
								for( $i = 0; $i < size($deadlinePools); ++$i )
								{ 
									menuItem -label $deadlinePools[$i];
									if( $deadlinePools[$i] == $savedJobPool )
										optionMenuGrp -e -select ($i+1) $vrayPoolsBox;
								}
								
								string $secondaryVrayPoolsBox = `optionMenuGrp -label "Secondary Pool" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "The secondary pool lets you specify a Pool to use if the primary Pool does not have any available Slaves" frw_deadlineVraySecondaryPool`;
								menuItem -label "";
								if( "" == $savedJobSecondaryPool )
									optionMenuGrp -e -select 1 $secondaryVrayPoolsBox;
								
								for( $i = 0; $i < size($deadlinePools); ++$i )
								{ 
									menuItem -label $deadlinePools[$i];
									if( $deadlinePools[$i] == $savedJobSecondaryPool )
										optionMenuGrp -e -select ($i+2) $secondaryVrayPoolsBox;
								}
									
								string $groupsVrayBox = `optionMenuGrp -label "Group" -cl2 "left" "left" -cw2 $labelWidth 320 -changeCommand SavePersistentDeadlineOptions -annotation "The group the job belongs to" frw_VrayGroup`;
								for( $i = 0; $i < size( $deadlineGroups ); ++$i )
								{ 
									menuItem -label $deadlineGroups[$i];
									if( $deadlineGroups[$i] == $savedGroup )
										optionMenuGrp -e -select ($i+1) $groupsVrayBox;
								}
								
								intSliderGrp -label "Priority" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue $maximumPriority -v $priority -changeCommand SavePersistentDeadlineOptions -annotation "The job's priority (0 is the lowest, 100 is the highest)" frw_VrayJobPriority;
								intSliderGrp -label "Machine Limit" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 1000 -v $limitCount -changeCommand SavePersistentDeadlineOptions -annotation "Limit the number of machines that can render this job concurrently (specify 0 for no machine limit)" frw_VrayLimitCount;
								intSliderGrp -label "Concurrent Tasks" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 1 -maxValue 16 -v $concurrentTasks -changeCommand SavePersistentDeadlineOptions -annotation "The number of tasks a slave can dequeue for this job simultaneously" frw_VrayConcurrentTasks;
								intSliderGrp -label "Task Timeout" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 5000 -v $SlaveTimeout -changeCommand SavePersistentDeadlineOptions -annotation "The number of minutes a slave has to render an individual task before timing out (specify 0 for no limit)" frw_VraySlaveTimeout;
								intSliderGrp -label "Minimum Task Time" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 5000 -v $MinSlaveTimeout -changeCommand SavePersistentDeadlineOptions -annotation "The minimum number of minutes a slave should render a task for, otherwise an error will be reported (specify 0 for no minimum)" frw_VrayMinSlaveTimeout;
								
								$VrayLimitGroupGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Limit Groups" -buttonLabel "..." -text "" -changeCommand SavePersistentDeadlineOptions -annotation "The limit groups that this job requires." frw_VrayLimitGroups`;
								textFieldButtonGrp -e -bc SetVrayLimitGroups $VrayLimitGroupGrp;
								
								$VrayMachineListGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Machine List" -buttonLabel "..." -text "" -changeCommand SavePersistentDeadlineOptions -annotation "The whitelist or blacklist for the job." frw_VrayMachineList`;
								textFieldButtonGrp -e -bc SetVrayMachineList $VrayMachineListGrp;
								
								rowLayout -numberOfColumns 2 -cw2 (160 + $labelWidth) 160 -ct2 "left" "left";
									string $VrayOnCompleteBox = `optionMenuGrp -label "On Complete" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "What to do with the job after it completes." frw_VrayOnComplete`;
									menuItem -label "Nothing";
									menuItem -label "Archive";
									menuItem -label "Delete";
									optionMenuGrp -e -select (1) $VrayOnCompleteBox;
									
									checkBox -label "Machine List is a Blacklist" -v $isBlacklist -changeCommand SavePersistentDeadlineOptions -annotation "If checked, the machine list will be a blacklist. Otherwise, it is a whitelist." frw_VrayIsBlacklist;
								setParent ..;
								
								intSliderGrp -label "Threads" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 256 -v $vrayThreads -changeCommand SavePersistentDeadlineOptions -annotation  "The number of threads to use during rendering (specify 0 to use all processors available)" frw_vrayThreads;
								
							setParent ..;
						setParent ..;
						
						int $vrimg2ExrEnabled = $submitVRayJob;
						$VrayExportVrimgJobRollout = `frameLayout -label "Vrimg2Exr Conversion Job" -labelVisible true -borderVisible false -collapsable true -visible false`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								checkBox -enable $vrimg2ExrEnabled -label "Convert vrimg Files To exr With Dependent Job" -align "left" -v $submitVrimg2ExrJob -changeCommand SavePersistentDeadlineOptions -annotation "Enable this option to submit a dependent job that converts the vrimg output files to exr files" frw_submitVrimg2ExrJob;
								checkBox -enable $vrimg2ExrEnabled -label "Delete Input vrimg Files After Conversion" -align "left" -v $deleteVrimgFiles -changeCommand SavePersistentDeadlineOptions -annotation "Enable this option to delete the input vrimg file after the conversion has finished." frw_deleteVrimgFiles;
							setParent ..;
						setParent ..;
						
						$RendermanExportRollout = `frameLayout -label "RenderMan Export Job" -labelVisible true -borderVisible false -collapsable true -visible false`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								rowLayout -numberOfColumns 1 -cw 1 400 -ct1 "left";
									text -align "left" -label "Uses RenderMan to export rib files instead of rendering." frw_exportRenderManLabel;
								setParent ..;
								
								intSliderGrp -label "Threads" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 256 -v $exportRenderManThreads -changeCommand SavePersistentDeadlineOptions -annotation  "The number of threads to use during exporting (specify 0 to use all processors available)" frw_exportRenderManThreads;
								
								rowLayout -numberOfColumns 2 -cw2 $labelWidth 158 -ct2 "left" "left";
									text -align "left" -label "" frw_dummyRenderWithRisLabel;
									checkBox -label "Render With RIS" -v $renderRenderManWithRis -changeCommand SavePersistentDeadlineOptions -annotation "If checked, the exported RIB files will have RIS set as the renderer instead of REYES" frw_renderRenderManWithRis;
								setParent ..;
							setParent ..;
						setParent ..;
						
						$RendermanExportRenderJobRollout = `frameLayout -label "RenderMan Render Job" -labelVisible true -borderVisible false -collapsable true -visible false`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								checkBox -label "Submit Dependent RenderMan Standalone Render Job" -align "left" -v $submitRenderManJob -changeCommand SavePersistentDeadlineOptions -annotation "If this option is set to true, a RenderMan Standalone job that is dependent on the export job will also be submitted" frw_submitRenderManJob;
								checkBox -label "Enable RenderMan Frame Dependencies" -align "left" -v $renderManFrameDependent -changeCommand SavePersistentDeadlineOptions -annotation "If Checked, the RenderMan Job will have Frame Dependencies. If your scene contains static content, do not use!" frw_renderManFrameDependent;
								string $rendermanPoolsBox = `optionMenuGrp -label "Pool" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "The pool the job belongs to" frw_deadlineRendermanPool`;
								for( $i = 0; $i < size($deadlinePools); ++$i )
								{ 
									menuItem -label $deadlinePools[$i];
									if( $deadlinePools[$i] == $savedJobPool )
										optionMenuGrp -e -select ($i+1) $rendermanPoolsBox;
								}
								
								string $secondaryRendermanPoolsBox = `optionMenuGrp -label "Secondary Pool" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "The secondary pool lets you specify a Pool to use if the primary Pool does not have any available Slaves" frw_deadlineRendermanSecondaryPool`;
								menuItem -label "";
								if( "" == $savedJobSecondaryPool )
									optionMenuGrp -e -select 1 $secondaryRendermanPoolsBox;
								
								for( $i = 0; $i < size($deadlinePools); ++$i )
								{ 
									menuItem -label $deadlinePools[$i];
									if( $deadlinePools[$i] == $savedJobSecondaryPool )
										optionMenuGrp -e -select ($i+2) $secondaryRendermanPoolsBox;
								}
									
								string $groupsRendermanBox = `optionMenuGrp -label "Group" -cl2 "left" "left" -cw2 $labelWidth 320 -changeCommand SavePersistentDeadlineOptions -annotation "The group the job belongs to" frw_RendermanGroup`;
								for( $i = 0; $i < size( $deadlineGroups ); ++$i )
								{ 
									menuItem -label $deadlineGroups[$i];
									if( $deadlineGroups[$i] == $savedGroup )
										optionMenuGrp -e -select ($i+1) $groupsRendermanBox;
								}
								
								intSliderGrp -label "Priority" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue $maximumPriority -v $priority -changeCommand SavePersistentDeadlineOptions -annotation "The job's priority (0 is the lowest, 100 is the highest)" frw_RendermanJobPriority;
								intSliderGrp -label "Machine Limit" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 1000 -v $limitCount -changeCommand SavePersistentDeadlineOptions -annotation "Limit the number of machines that can render this job concurrently (specify 0 for no machine limit)" frw_RendermanLimitCount;
								intSliderGrp -label "Concurrent Tasks" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 1 -maxValue 16 -v $concurrentTasks -changeCommand SavePersistentDeadlineOptions -annotation "The number of tasks a slave can dequeue for this job simultaneously" frw_RendermanConcurrentTasks;
								intSliderGrp -label "Task Timeout" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 5000 -v $SlaveTimeout -changeCommand SavePersistentDeadlineOptions -annotation "The number of minutes a slave has to render an individual task before timing out (specify 0 for no limit)" frw_RendermanSlaveTimeout;
								intSliderGrp -label "Minimum Task Time" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 5000 -v $MinSlaveTimeout -changeCommand SavePersistentDeadlineOptions -annotation "The minimum number of minutes a slave should render a task for, otherwise an error will be reported (specify 0 for no minimum)" frw_RendermanMinSlaveTimeout;
								
								$RendermanLimitGroupGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Limit Groups" -buttonLabel "..." -text "" -changeCommand SavePersistentDeadlineOptions -annotation "The limit groups that this job requires." frw_RendermanLimitGroups`;
								textFieldButtonGrp -e -bc SetRendermanLimitGroups $RendermanLimitGroupGrp;
								
								$RendermanMachineListGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Machine List" -buttonLabel "..." -text "" -changeCommand SavePersistentDeadlineOptions -annotation "The whitelist or blacklist for the job." frw_RendermanMachineList`;
								textFieldButtonGrp -e -bc SetRendermanMachineList $RendermanMachineListGrp;
								
								rowLayout -numberOfColumns 2 -cw2 (160 + $labelWidth) 160 -ct2 "left" "left";
									string $RendermanOnCompleteBox = `optionMenuGrp -label "On Complete" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "What to do with the job after it completes." frw_RendermanOnComplete`;
									menuItem -label "Nothing";
									menuItem -label "Archive";
									menuItem -label "Delete";
									optionMenuGrp -e -select (1) $RendermanOnCompleteBox;
									
									checkBox -label "Machine List is a Blacklist" -v $isBlacklist -changeCommand SavePersistentDeadlineOptions -annotation "If checked, the machine list will be a blacklist. Otherwise, it is a whitelist." frw_RendermanIsBlacklist;
								setParent ..;
								
								
								intSliderGrp -label "Threads" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 256 -v $rendermanThreads -changeCommand SavePersistentDeadlineOptions -annotation  "The number of threads to use during rendering (specify 0 to use all processors available)" frw_rendermanThreads;
								
								textFieldGrp -label "Command Line Args" -cl2 "left" "left" -cw2 $labelWidth 320 -text $rendermanArgs -changeCommand SavePersistentDeadlineOptions -annotation "Additional command line options to pass to RenderMan" frw_rendermanArgs;
							setParent ..;
						setParent ..;
						
						$ArnoldExportRollout = `frameLayout -label "Arnold Export Job" -labelVisible true -borderVisible false -collapsable true -visible false`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								rowLayout -numberOfColumns 1 -cw 1 400 -ct1 "left";
									text -align "left" -label "Uses Arnold to export ass files instead of rendering." frw_exportArnoldLabel;
								setParent ..;
							setParent ..;
						setParent ..;
						
						$ArnoldExportRenderJobRollout = `frameLayout -label "Arnold Render Job" -labelVisible true -borderVisible false -collapsable true -visible false`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								checkBox -label "Submit Dependent Arnold Standalone Render Job" -align "left" -v $submitArnoldJob -changeCommand SavePersistentDeadlineOptions -annotation "If this option is set to true, an Arnold Standalone job that is dependent on the export job will also be submitted" frw_submitArnoldJob;
								checkBox -label "Local Export to Arnold" -align "left" -v $exportArnoldLocal -changeCommand SavePersistentDeadlineOptions -annotation "If this option is set to true, the arnold ass file will be exported locally" frw_exportArnoldLocal;
								
								string $arnoldPoolsBox = `optionMenuGrp -label "Pool" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "The pool the job belongs to" frw_deadlineArnoldPool`;
								for( $i = 0; $i < size($deadlinePools); ++$i )
								{ 
									menuItem -label $deadlinePools[$i];
									if( $deadlinePools[$i] == $savedJobPool )
										optionMenuGrp -e -select ($i+1) $arnoldPoolsBox;
								}
								
								string $secondaryArnoldPoolsBox = `optionMenuGrp -label "Secondary Pool" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "The secondary pool lets you specify a Pool to use if the primary Pool does not have any available Slaves" frw_deadlineArnoldSecondaryPool`;
								menuItem -label "";
								if( "" == $savedJobSecondaryPool )
									optionMenuGrp -e -select 1 $secondaryArnoldPoolsBox;
								
								for( $i = 0; $i < size($deadlinePools); ++$i )
								{ 
									menuItem -label $deadlinePools[$i];
									if( $deadlinePools[$i] == $savedJobSecondaryPool )
										optionMenuGrp -e -select ($i+2) $secondaryArnoldPoolsBox;
								}
									
								string $groupsArnoldBox = `optionMenuGrp -label "Group" -cl2 "left" "left" -cw2 $labelWidth 320 -changeCommand SavePersistentDeadlineOptions -annotation "The group the job belongs to" frw_ArnoldGroup`;
								for( $i = 0; $i < size( $deadlineGroups ); ++$i )
								{ 
									menuItem -label $deadlineGroups[$i];
									if( $deadlineGroups[$i] == $savedGroup )
										optionMenuGrp -e -select ($i+1) $groupsArnoldBox;
								}
								
								intSliderGrp -label "Priority" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue $maximumPriority -v $priority -changeCommand SavePersistentDeadlineOptions -annotation "The job's priority (0 is the lowest, 100 is the highest)" frw_ArnoldJobPriority;
								intSliderGrp -label "Machine Limit" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 1000 -v $limitCount -changeCommand SavePersistentDeadlineOptions -annotation "Limit the number of machines that can render this job concurrently (specify 0 for no machine limit)" frw_ArnoldLimitCount;
								intSliderGrp -label "Concurrent Tasks" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 1 -maxValue 16 -v $concurrentTasks -changeCommand SavePersistentDeadlineOptions -annotation "The number of tasks a slave can dequeue for this job simultaneously" frw_ArnoldConcurrentTasks;
								intSliderGrp -label "Task Timeout" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 5000 -v $SlaveTimeout -changeCommand SavePersistentDeadlineOptions -annotation "The number of minutes a slave has to render an individual task before timing out (specify 0 for no limit)" frw_ArnoldSlaveTimeout;
								intSliderGrp -label "Minimum Task Time" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 5000 -v $MinSlaveTimeout -changeCommand SavePersistentDeadlineOptions -annotation "The minimum number of minutes a slave should render a task for, otherwise an error will be reported (specify 0 for no minimum)" frw_ArnoldMinSlaveTimeout;
								
								$ArnoldLimitGroupGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Limit Groups" -buttonLabel "..." -text "" -changeCommand SavePersistentDeadlineOptions -annotation "The limit groups that this job requires." frw_ArnoldLimitGroups`;
								textFieldButtonGrp -e -bc SetArnoldLimitGroups $ArnoldLimitGroupGrp;
								
								$ArnoldMachineListGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Machine List" -buttonLabel "..." -text "" -changeCommand SavePersistentDeadlineOptions -annotation "The whitelist or blacklist for the job." frw_ArnoldMachineList`;
								textFieldButtonGrp -e -bc SetArnoldMachineList $ArnoldMachineListGrp;
								
								rowLayout -numberOfColumns 2 -cw2 (160 + $labelWidth) 160 -ct2 "left" "left";
									string $ArnoldOnCompleteBox = `optionMenuGrp -label "On Complete" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "What to do with the job after it completes." frw_ArnoldOnComplete`;
									menuItem -label "Nothing";
									menuItem -label "Archive";
									menuItem -label "Delete";
									optionMenuGrp -e -select (1) $ArnoldOnCompleteBox;
									
									checkBox -label "Machine List is a Blacklist" -v $isBlacklist -changeCommand SavePersistentDeadlineOptions -annotation "If checked, the machine list will be a blacklist. Otherwise, it is a whitelist." frw_ArnoldIsBlacklist;
								setParent ..;
								
								intSliderGrp -label "Threads" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 256 -v $arnoldThreads -changeCommand SavePersistentDeadlineOptions -annotation  "The number of threads to use during rendering (specify 0 to use all processors available)" frw_arnoldThreads;
								
								textFieldGrp -label "Command Line Args" -cl2 "left" "left" -cw2 $labelWidth 320 -text $arnoldArgs -changeCommand SavePersistentDeadlineOptions -annotation "Additional command line options to pass to Arnold" frw_arnoldArgs;
							setParent ..;
						setParent ..;
						
						$MaxwellExportRollout = `frameLayout -label "Maxwell Export Job" -labelVisible true -borderVisible false -collapsable true -visible false`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								rowLayout -numberOfColumns 1 -cw 1 400 -ct1 "left";
									text -align "left" -label "Uses Maxwell to export MXS files instead of rendering." frw_exportMaxwellLabel;
								setParent ..;
								$MaxwellOutputScriptListGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Maxwell Script Name" -buttonLabel "..." -text $maxwellScript -annotation "The Maxwell scene file to export to." frw_maxwellScriptName`;
								textFieldButtonGrp -e -bc SetMaxwellOutputScript $MaxwellOutputScriptListGrp;
							setParent ..;
						setParent ..;
						
						$MaxwellExportRenderJobRollout = `frameLayout -label "Maxwell Render Job" -labelVisible true -borderVisible false -collapsable true -visible false`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								checkBox -label "Submit Dependent Maxwell Standalone Render Job" -align "left" -v $submitMaxwellJob -changeCommand SavePersistentDeadlineOptions -annotation "If this option is set to true, a Maxwell Standalone job that is dependent on the export job will also be submitted" frw_submitMaxwellJob;
								checkBox -label "Local Export to Maxwell" -align "left" -v $exportMaxwellLocal -changeCommand SavePersistentDeadlineOptions -annotation "If this option is set to true, the Maxwell mxs file will be exported locally" frw_exportMaxwellLocal;
								
								string $maxwellPoolsBox = `optionMenuGrp -label "Pool" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "The pool the job belongs to" frw_deadlineMaxwellPool`;
								for( $i = 0; $i < size($deadlinePools); ++$i )
								{ 
									menuItem -label $deadlinePools[$i];
									if( $deadlinePools[$i] == $savedJobPool )
										optionMenuGrp -e -select ($i+1) $maxwellPoolsBox;
								}
								
								string $secondaryMaxwellPoolsBox = `optionMenuGrp -label "Secondary Pool" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "The secondary pool lets you specify a Pool to use if the primary Pool does not have any available Slaves" frw_deadlineMaxwellSecondaryPool`;
								menuItem -label "";
								if( "" == $savedJobSecondaryPool )
									optionMenuGrp -e -select 1 $secondaryMaxwellPoolsBox;
								
								for( $i = 0; $i < size($deadlinePools); ++$i )
								{ 
									menuItem -label $deadlinePools[$i];
									if( $deadlinePools[$i] == $savedJobSecondaryPool )
										optionMenuGrp -e -select ($i+2) $secondaryMaxwellPoolsBox;
								}
									
								string $groupsMaxwellBox = `optionMenuGrp -label "Group" -cl2 "left" "left" -cw2 $labelWidth 320 -changeCommand SavePersistentDeadlineOptions -annotation "The group the job belongs to" frw_MaxwellGroup`;
								for( $i = 0; $i < size( $deadlineGroups ); ++$i )
								{ 
									menuItem -label $deadlineGroups[$i];
									if( $deadlineGroups[$i] == $savedGroup )
										optionMenuGrp -e -select ($i+1) $groupsMaxwellBox;
								}
								
								intSliderGrp -label "Priority" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue $maximumPriority -v $priority -changeCommand SavePersistentDeadlineOptions -annotation "The job's priority (0 is the lowest, 100 is the highest)" frw_MaxwellJobPriority;
								intSliderGrp -label "Machine Limit" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 1000 -v $limitCount -changeCommand SavePersistentDeadlineOptions -annotation "Limit the number of machines that can render this job concurrently (specify 0 for no machine limit)" frw_MaxwellLimitCount;
								intSliderGrp -label "Concurrent Tasks" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 1 -maxValue 16 -v $concurrentTasks -changeCommand SavePersistentDeadlineOptions -annotation "The number of tasks a slave can dequeue for this job simultaneously" frw_MaxwellConcurrentTasks;
								intSliderGrp -label "Task Timeout" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 5000 -v $SlaveTimeout -changeCommand SavePersistentDeadlineOptions -annotation "The number of minutes a slave has to render an individual task before timing out (specify 0 for no limit)" frw_MaxwellSlaveTimeout;
								intSliderGrp -label "Minimum Task Time" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 5000 -v $MinSlaveTimeout -changeCommand SavePersistentDeadlineOptions -annotation "The minimum number of minutes a slave should render a task for, otherwise an error will be reported (specify 0 for no minimum)" frw_MaxwellMinSlaveTimeout;
								
								$MaxwellLimitGroupGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Limit Groups" -buttonLabel "..." -text "" -changeCommand SavePersistentDeadlineOptions -annotation "The limit groups that this job requires." frw_MaxwellLimitGroups`;
								textFieldButtonGrp -e -bc SetMaxwellLimitGroups $MaxwellLimitGroupGrp;
								
								$MaxwellMachineListGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Machine List" -buttonLabel "..." -text "" -changeCommand SavePersistentDeadlineOptions -annotation "The whitelist or blacklist for the job." frw_MaxwellMachineList`;
								textFieldButtonGrp -e -bc SetMaxwellMachineList $MaxwellMachineListGrp;
								
								rowLayout -numberOfColumns 2 -cw2 (160 + $labelWidth) 160 -ct2 "left" "left";
									string $MaxwellOnCompleteBox = `optionMenuGrp -label "On Complete" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "What to do with the job after it completes." frw_MaxwellOnComplete`;
									menuItem -label "Nothing";
									menuItem -label "Archive";
									menuItem -label "Delete";
									optionMenuGrp -e -select (1) $MaxwellOnCompleteBox;
									
									checkBox -label "Machine List is a Blacklist" -v $isBlacklist -changeCommand SavePersistentDeadlineOptions -annotation "If checked, the machine list will be a blacklist. Otherwise, it is a whitelist." frw_MaxwellIsBlacklist;
								setParent ..;
								
								intSliderGrp -label "Threads" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 256 -v $maxwellThreads -changeCommand SavePersistentDeadlineOptions -annotation  "The number of threads to use during rendering (specify 0 to use all processors available)" frw_maxwellThreads;
								
								textFieldGrp -label "Command Line Args" -cl2 "left" "left" -cw2 $labelWidth 320 -text $maxwellArgs -changeCommand SavePersistentDeadlineOptions -annotation "Additional command line options to pass to Maxwell" frw_maxwellArgs;
							setParent ..;
						setParent ..;
						
						$MayaRenderOptionsTileRollout = `frameLayout -label "Region Rendering" -labelVisible true -borderVisible false -collapsable true -collapse true`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								rowLayout -numberOfColumns 1 -cw 1 400 -ct1 "left";
									text -align "left" -label "For arnold, mayaSoftware, mentalRay, renderMan, finalRender, turtle, vray, and arnold export\njobs only. If you have multiple layers, this only works if you submit each layer as a separate job." frw_tileLabel;
								setParent ..;
								
								string $regionRenderTypeTypeBox = `optionMenuGrp -label "Region Render Type" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand UpdateRegionRenderType -annotation "Select the method of region rendering" frw_regionRenderType`;
								menuItem -label "Jigsaw Rendering";
								menuItem -label "Tile Rendering";
								optionMenuGrp -e -select (1) $regionRenderTypeTypeBox;
								
								rowLayout -numberOfColumns 1 -cw 1 $labelWidth -ct1 "left";
									checkBox -enable $tileRenderingEnable -label "Enable Region Rendering" -changeCommand SavePersistentDeadlineOptions -v $regionRendering -annotation "Tile rendering splits up a frame between multiple machines (the assembly is done automatically for bmp, exr, jpg, png, tga, and tif)" frw_regionRendering;
								setParent ..;
								
								columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4 frw_tileRenderLayout;
									rowLayout -numberOfColumns 1 -cw 1 (310 + $labelWidth) -ct1 "right";
										intSliderGrp -enable $regionRendering -label "Tiles In X" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 1 -maxValue 200 -v $tilesInX -changeCommand SavePersistentDeadlineOptions -annotation "The number of tiles in the X direction" frw_tilesInX;
									setParent ..;
									
									rowLayout -numberOfColumns 1 -cw 1 (310 + $labelWidth) -ct1 "right";
										intSliderGrp -enable $regionRendering -label "Tiles In Y" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 1 -maxValue 200 -v $tilesInY -changeCommand SavePersistentDeadlineOptions -annotation "The number of tiles in the Y direction" frw_tilesInY;
									setParent ..;
								setParent ..;
								string $tileRenderingSingleJob = `checkBox -en $regionRendering -align "left" -label "Submit All Tiles As A Single Job" -v $tileSingleJob -changeCommand SavePersistentDeadlineOptions -annotation "Check this to combine all tiles into a single job." frw_submitTileSingleJob`;
								
								rowLayout -numberOfColumns 1 -cw 1 (320 + $labelWidth) -ct1 "right";
									intSliderGrp -enable $regionRendering -label "Single Job Frame" -cal 1 "left" -cw 1 $labelWidth -field true -minValue -100000 -maxValue 100000 -v $currTime -changeCommand SavePersistentDeadlineOptions -annotation "The single frame to render." frw_tileSingleFrame;
								setParent ..;
								
								rowLayout -numberOfColumns 2 -cw2 $labelWidth 260 -ct2 "left" "left" frw_jigsawRenderLayout;
									$OpenJigsawBtn = `button -label "Open Jigsaw Panel" -width 105 -height 26 -annotation "Opens the Jigsaw panel" -c OpenJigsawWindow frw_openJigsaw`;
									text -align "left" -label "Jigsaw Panel must be open during submission." frw_jigsawLabel;
								setParent ..;
								
								rowLayout -numberOfColumns 2 -cw2 260 160 -ct2 "left" "left";
									checkBox -en $regionRendering -align "left" -label "Submit Dependent Assembly Job" -v $tileDependentJob -changeCommand SavePersistentDeadlineOptions -annotation "Check this submit an assembly job that is dependent on the first job." frw_submitTileDependentJob;
									checkBox -en $regionRendering -align "left" -label "Error on Missing Tiles" -v $tileErrorOnMissing -changeCommand SavePersistentDeadlineOptions -annotation "Check this force the render to fail on a missing tile" frw_submitTileErrorOnMissing;
									setParent ..;
								rowLayout -numberOfColumns 2 -cw2 260 160 -ct2 "left" "left";
									checkBox -en $regionRendering -align "left" -label "Cleanup Tiles After Assembly" -v $tileCleanupJob -changeCommand SavePersistentDeadlineOptions -annotation "Check this to delete all tiles after the assembly job completes." frw_submitTileCleanupJob;
								setParent ..;
								rowLayout -numberOfColumns 2 -cw2 260 160 -ct2 "left" "left";
									string $compositeTypeBox = `optionMenuGrp -label "Assemble over" -cl2 "left" "left" -cw2 $labelWidth 130 -changeCommand UpdateCompositeType -annotation "Select the image to composite over" frw_compositeType`;
									menuItem -label "Blank Image";
									menuItem -label "Previous Output";
									menuItem -label "Selected Image";
									optionMenuGrp -e -select (1) $compositeTypeBox;
								setParent ..;
								rowLayout -numberOfColumns 1 -cw2 260 160 -ct2 "left" "left" frw_compLayout;
									$CompositeNamePathGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Background Image File" -buttonLabel "..." -text $tileCompositeOverName -changeCommand SavePersistentDeadlineOptions -annotation "The name of the file to Assemble over" frw_submitTileCompositeOverName`;
									print $CompositeNamePathGrp;
									textFieldButtonGrp -e -bc SetCompositeOverPath $CompositeNamePathGrp;
								setParent ..;
								rowLayout -numberOfColumns 1 -cw2 260 160 -ct2 "left" "left";
									checkBox -en $regionRendering -align "left" -label "Error on Missing Background" -v $tileMissingBackground -changeCommand SavePersistentDeadlineOptions -annotation "Check this to have the assemble fail if the background file is missing." frw_submitTileErrorOnMissingBackground;
								setParent ..;
								
							setParent ..;
						setParent ..;

						$BifrostSimulationJobRollout = `frameLayout -label "Bifrost Simulation Job" -labelVisible true -borderVisible false -collapsable true -visible false`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								rowLayout -numberOfColumns 1 -cw 1 400 -ct1 "left";
									text -align "left" -label "Caches all bifrost containers.";
								setParent..;

								$BifrostDirectoryButtonGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Bifrost Cache Directory" -buttonLabel "..." -text $projectPath -changeCommand SavePersistentDeadlineOptions -annotation "The directory where the Bifrost cache will be sent." frw_bifrostCacheDir`;
								textFieldButtonGrp -e -bc SetBifrostCacheDirectory $BifrostDirectoryButtonGrp;

								if(IntMayaVersion() >= 2016) // Maya 2016 and beyond: Add options for format and compression index
								{
									optionMenuGrp -label "Compression Format" -cl2 "left" "left" -cw2 $labelWidth 160 -annotation "Select the Compression Format to use" frw_biFrostCompressionFormat;
									menuItem -label "Simple (lossless, least compression)";
									menuItem -label "Float (lossless)";
									menuItem -label "Quantization (lossy)";
							
								}
							setParent ..;
						setParent ..;
						
						$AlembicExportJobRollout = `frameLayout -label "Alembic Export Job" -labelVisible true -borderVisible false -collapsable true -visible false`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								rowLayout -numberOfColumns 1 -cw 1 400 -ct1 "left";
									text -align "left" -label "Export scene or selection to Alembic format (.abc).";
								setParent ..;

								$AlembicFileButtonGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Alembic Output File" -buttonLabel "..." -changeCommand SavePersistentDeadlineOptions -annotation "The file that Alembic will write to." frw_alembicExportFile`;
								textFieldButtonGrp -e -bc SetAlembicCacheFile $AlembicFileButtonGrp;
								radioButtonGrp -cl2 "left" "left" -numberOfRadioButtons 2 -label "Export:" -labelArray2 "All" "Selection" -cw3 $labelWidth 160 160 -select 1 frw_AlembicExportSelection;

							setParent ..;
						setParent ..;

						$AlembicAdvancedOptionsJobRollout = `frameLayout -label "Advanced Options" -labelVisible true -borderVisible false -collapsable true -visible false`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								rowLayout -numberOfColumns 1 -cw 1 400 -ct1 "left";
								setParent ..;

								rowLayout -numberOfColumns 3 -cw3 160 160 160 -ct3 "left" "left" "left";
									checkBox -label "Verbose" -align "left" -changeCommand SavePersistentDeadlineOptions frw_verboseCheck;
									checkBox -label "No Normals" -align "left" -changeCommand SavePersistentDeadlineOptions frw_noNormalsCheck;
									checkBox -label "Renderable Only" -changeCommand SavePersistentDeadlineOptions frw_renderableOnlyCheck;
								setParent ..;

								rowLayout -numberOfColumns 3 -cw3 160 160 160 -ct3 "left" "left" "left";
									checkBox -label "Strip Namespaces" -align "left" -changeCommand SavePersistentDeadlineOptions frw_stripNamespacesCheck;
									checkBox -label "UV Write" -align "left" -changeCommand SavePersistentDeadlineOptions frw_uvWriteCheck;
									checkBox -label "Write Color Sets" -changeCommand SavePersistentDeadlineOptions frw_writeColorSetsCheck;
								setParent ..;

								rowLayout -numberOfColumns 3 -cw3 160 160 160 -ct3 "left" "left" "left";
									checkBox -label "Write Face Sets" -align "left" -changeCommand SavePersistentDeadlineOptions frw_writeFaceSetsCheck;
									checkBox -label "Whole Frame Geo" -align "left" -changeCommand SavePersistentDeadlineOptions frw_wholeFrameGeoCheck;
									checkBox -label "World Space" -changeCommand SavePersistentDeadlineOptions frw_worldSpaceCheck;
								setParent ..;

								rowLayout -numberOfColumns 3 -cw3 160 160 160 -ct3 "left" "left" "left";
									checkBox -label "Write Visibility" -align "left" -changeCommand SavePersistentDeadlineOptions frw_writeVisibilityCheck;
									checkBox -label "Filter Euler Rotations" -align "left" -changeCommand SavePersistentDeadlineOptions frw_filterEulerRotationsCheck;
									checkBox -label "Write Creases" -changeCommand SavePersistentDeadlineOptions frw_writeCreasesCheck;
								setParent ..;
								optionMenuGrp -label "Alembic Format" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions frw_alembicFormat;
								menuItem -label "HDF5 - Maya 2014 Extension 1 and Legacy";
								menuItem -label "Ogawa - Maya 2014 Extension 1";
								
							setParent ..;
						setParent ..;

							

						$MayaScriptJobRollout = `frameLayout -label "Maya Script Job" -labelVisible true -borderVisible false -collapsable true -visible false`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								rowLayout -numberOfColumns 1 -cw 1 400 -ct1 "left";
									text -align "left" -label "Uses Python or Melscript to run a custom Maya script.";
								setParent ..;
								$MayaScriptButtonGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Script File Name" -buttonLabel "..." -annotation "The custom script to run." frw_mayaScriptJob`;
								textFieldButtonGrp -e -bc SetMayaOutputScript $MayaScriptButtonGrp;
							setParent ..;
						setParent ..;

						$FluidCachingJobRollout = `frameLayout -label "Fluid Caching Job" -labelVisible true -borderVisible false -collapsable true -visible false`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								rowLayout -numberOfColumns 1 -cw 1 400 -ct1 "left";
									text -align "left" -label "Runs a Fluid Caching Job on selected fluids.";
								setParent ..;

								$FluidCachingDirButtonGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Cache Output Directory: " -buttonLabel "..." -text $projectPath -changeCommand SavePersistentDeadlineOptions -annotation "The folder that the cache will be saved in." frw_FluidCacheOutputDir`;
								textFieldButtonGrp -e -bc SetFluidCacheDirectory $FluidCachingDirButtonGrp;
								textFieldGrp -cal 1 "left"  -cw 1 $labelWidth -cw 2 300 -label "Cache Prefix Name: " frw_FluidCacheFileName;
								optionMenuGrp -label "Cache Format: " -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions frw_FluidCacheFormat;
								menuItem -label "mcc";
								menuItem -label "mcx";

								radioButtonGrp -cl2 "left" "left" -numberOfRadioButtons 2 -label "File Distribution:" -labelArray2 "One File Per Frame" "Only One File" -cw3 $labelWidth 160 160 -select 1 -vr frw_FluidCacheFileDistRadio;
								checkBox -label "One Cache Per Fluid" -changeCommand SavePersistentDeadlineOptions frw_FluidCacheSplitCheck;			

							setParent ..;
						setParent ..;

						$GeometryCachingJobRollout = `frameLayout -label "Geometry Caching Job" -labelVisible true -borderVisible false -collapsable true -visible false`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								rowLayout -numberOfColumns 1 -cw 1 400 -ct1 "left";
									text -align "left" -label "Runs a Geometry caching job on selected geometry.";
								setParent ..;

								$GeometryCachingDirButtonGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Cache Output Directory: " -buttonLabel "..." -text $projectPath -changeCommand SavePersistentDeadlineOptions -annotation "The folder that the cache will be saved in." frw_GeometricCacheOutputDir`;
								textFieldButtonGrp -e -bc SetGeometricCacheDirectory $GeometryCachingDirButtonGrp;

								textFieldGrp -cal 1 "left"  -cw 1 $labelWidth -cw 2 300 -label "Cache Prefix Name: " frw_GeoCacheFileName;

								optionMenuGrp -label "Cache Format: " -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions frw_GeoCacheFormat;
								menuItem -label "mcc";
								menuItem -label "mcx";

								radioButtonGrp -cl2 "left" "left" -numberOfRadioButtons 2 -label "File Distribution:" -labelArray2 "One File Per Frame" "Only One File" -cw3 $labelWidth 160 160 -select 1 -vr frw_GeometricCacheFileDistRadio;
								radioButtonGrp -cl2 "left" "left" -numberOfRadioButtons 2 -label "Store Points As:" -labelArray2 "Double" "Float" -cw3 $labelWidth 160 160 -select 1 -vr frw_GeometricCacheDblOrFltRadio;
								radioButtonGrp -cl2 "left" "left" -numberOfRadioButtons 2 -label "Store Points In:" -labelArray2 "Local" "World" -cw3 $labelWidth 160 160 -select 1 -vr frw_GeometricCacheLocOrWldRadio;			
								checkBox -label "One Cache Per Geometry" -changeCommand SavePersistentDeadlineOptions frw_GeometricCacheSplitCheck;		
							setParent ..;
						setParent ..;
					setParent ..;
				setParent ..;
			setParent ..;
			
			
			columnLayout -adj true -columnAttach "both" 4 shotgunTabLayout;
				//=================================================================
				// SHOTGUN / FTRACK / NIM
				frameLayout -label "Project Management" -labelVisible true -borderVisible false -collapsable true -collapse false;
					columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4 -columnAlign "left";
						
						rowLayout -numberOfColumns 3 -cw3 ($labelWidth + 90) 100 100;

							optionMenuGrp -label "Project Management" -cl2 "left" "left" -cw2 $labelWidth 95 -changeCommand ProjectManagementChanged -annotation "Select the project management integration to use" frw_projectManagement;
							menuItem -label "Shotgun";
							menuItem -label "FTrack";
							menuItem -label "NIM";
							optionMenuGrp -e -value $pmIntegration frw_projectManagement;

							button -label "Connect..." -width 80 -command ConnectButtonPressed;
							
							//=================================================================
							// NIM
							int $enable = 1;
							if (`size $SGInfoKeys` > 0 || `size $NimInfoKeys` > 0){
								$enable = 1;
							}

							string $UseShotgun;
							string $UseFTrack;
							string $UseNim;

							if ($pmIntegration == "NIM"){
								$UseNim = `checkBox -label "Add NIM Render" -value false -enable $enable -annotation "Check to use NIM." -changeCommand CreateVersionChanged frw_projMgmtCreateVersion`;
							}
							else if ($pmIntegration == "FTrack"){
								$UseFTrack = `checkBox -label "Create New Version" -value false -enable $enable -annotation "Check to use FTrack." -changeCommand CreateVersionChanged frw_projMgmtCreateVersion`;
							}
							else {
								$UseShotgun = `checkBox -label "Create New Version" -value false -enable $enable -annotation "Check to use Shotgun." -changeCommand CreateVersionChanged frw_projMgmtCreateVersion`;
							}

							// ORIGINAL CODE DL7.1.21
							//int $enable = `size $SGInfoKeys` > 0;
							//string $UseShotgun = `checkBox -label "Create New Version" -value false -enable $enable -annotation "Check to use Shotgun." -changeCommand CreateVersionChanged frw_projMgmtCreateVersion`;
							
							// END NIM
							//=================================================================
							
							$enable = `size $SGInfoKeys` > 0;
						setParent ..;
						
						//textFieldGrp -enable false -label "Version Name" -cl2 "left" "left" -cw2 $labelWidth 325 -text $sgVersionName -annotation "The name of the Version that will be created in Shotgun." -changeCommand SavePersistentDeadlineOptions frw_projMgmtVersion;
						//textFieldGrp -enable false -label "Description" -cl2 "left" "left" -cw2 $labelWidth 325 -text $sgDescription -annotation "The description of the Version that will be created in Shotgun." -changeCommand SavePersistentDeadlineOptions frw_projMgmtDescription;

						textFieldGrp -enable false -label "Version Name" -cl2 "left" "left" -cw2 $labelWidth 325 -text "" -annotation "The name of the Version that will be created in Shotgun." -changeCommand UpdatePMInfo frw_projMgmtVersion;
						textFieldGrp -enable false -label "Description" -cl2 "left" "left" -cw2 $labelWidth 325 -text "" -annotation "The description of the Version that will be created in Shotgun." -changeCommand UpdatePMInfo frw_projMgmtDescription;
						
						rowLayout -numberOfColumns 2 -cw2 $labelWidth 300;
							text -enable false -label "Selected Entity" -annotation "Details of the selected Shotgun entity to which the created Version will be attached." frw_projMgmtDetailsLabel;
							scrollField -wordWrap false -enable false -text "" -editable false -width 325 -height 140 frw_projMgmtDetails;
						setParent ..;

						rowLayout -numberOfColumns 3 -cw3 $labelWidth 150 150;
							text -enable false -label "Draft Options" -annotation "These options require the use of a Draft license to function." frw_projMgmtDraftLabel;
							checkBox -label "Create/Upload Movie" -value false -enable $enable -annotation "Check to use create and upload a Movie on completion. Requires Draft." -changeCommand CreateVersionChanged frw_projMgmtCreateMovie;
							checkBox -label "Create/Upload Filmstrip" -value false -enable $enable -annotation "Check to use create and upload a Filmstrip on completion. Requires Draft." -changeCommand CreateVersionChanged frw_projMgmtCreateFilmstrip;
						setParent ..;
					setParent ..;
				setParent ..;
				// END SHOTGUN
				//=================================================================
	
				//=================================================================
				// DRAFT
				frameLayout -label "Draft" -labelVisible true -borderVisible false -collapsable true -collapse false;
					columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4 -columnAlign "left";
						rowLayout -numberOfColumns 3 -cw3 $labelWidth 200 120;
							text -label ""; //dummy label
							checkBox -label "Submit Draft Job On Completion" -value $submitDraftJob -changeCommand UseDraftChanged -enable true -annotation "Check to submit a Draft job in addition to the Maya job." frw_submitDraftJob;
							checkBox -label "Upload to Shotgun" -value $uploadDraftToShotgun -changeCommand SavePersistentDeadlineOptions -enable false -annotation "Check to upload Draft output to Shotgun/Nim." frw_uploadDraftToShotgun;
						setParent ..;

						radioButtonGrp -numberOfRadioButtons 2 -label "" -labelArray2 "Quick" "Custom" -cw3 $labelWidth 65 65 -changeCommand UseQuickDraftChanged frw_UseQuickDraftRadio;
						radioButtonGrp -e -select ($draftQuick ? 1 : 2) frw_UseQuickDraftRadio;

						optionMenuGrp -label "Format" -cl2 "left" "left" -cw2 $labelWidth 80 -changeCommand CustomDraftFormatChanged -annotation "The format to use for the Quick Draft job." frw_UseQuickDraftFormat;
						for( $i = 0; $i < size( $QuickDraftFormats ); ++$i )
						{ 
							menuItem -label $QuickDraftFormats[$i];
							if( $QuickDraftFormatFile[$i] == $savedQuickDraftFormat )
							{
								optionMenuGrp -e -select ($i+1) frw_UseQuickDraftFormat;
							}
						}
						
						string $currentFormat = `optionMenuGrp -q -value frw_UseQuickDraftFormat`;
						string $codecs[] = GetCodecs( $currentFormat );
						int $index = stringArrayFind( $currentFormat, 0, $QuickDraftFormats );
						if( $index >= 0)
						{
							$currentFormat = $QuickDraftFormatFile[ $index ];
						}
						else
						{
							$currentFormat = "";
						}
						$codecs = ApplyRestrictions( $currentFormat, "Codec", $codecs);
						optionMenuGrp -label "Compression" -cl2 "left" "left" -cw2 $labelWidth 80 -changeCommand CustomDraftCodecChanged -annotation "The compression to use for the Quick Draft job." frw_UseQuickDraftCodecs;
						for( $i = 0; $i < size( $codecs ); ++$i )
						{ 
							menuItem -label $codecs[$i];
							if( $codecs[$i] == $savedQuickDraftCodec )
							{
								optionMenuGrp -e -select ($i+1) frw_UseQuickDraftCodecs;
							}
						}
						
						optionMenuGrp -label "Resolution" -cl2 "left" "left" -cw2 $labelWidth 80 -changeCommand ProjectManagementChanged -annotation "The resolution to use for the Quick Draft job." frw_UseQuickDraftResolution;
						for( $i = 0; $i < size( $QuickDraftResolutionsDisplay ); ++$i )
						{ 
							menuItem -label $QuickDraftResolutionsDisplay[$i];
							if( $QuickDraftResolutionsDisplay[$i] == $savedQuickDraftResolution )
							{
								optionMenuGrp -e -select ($i+1) frw_UseQuickDraftResolution;
							}
						}
						
						string $frameRates[] = $QuickDraftFrameRates;
						string $currentCodec = `optionMenuGrp -q -value frw_UseQuickDraftCodecs`;
						$frameRates = ApplyRestrictions( $currentFormat, "FrameRate", $frameRates);
						$frameRates = ApplyRestrictions( $currentCodec, "FrameRate", $frameRates);
						optionMenuGrp -label "Frame Rate" -cl2 "left" "left" -cw2 $labelWidth 80 -changeCommand ProjectManagementChanged -annotation "The frame rate to use for the Quick Draft job." frw_UseQuickDraftFrameRate;
						for( $i = 0; $i < size( $frameRates ); ++$i )
						{ 
							menuItem -label $frameRates[$i];
							if( $frameRates[$i] == $savedQuickDraftFrameRate )
							{
								optionMenuGrp -e -select ($i+1) frw_UseQuickDraftFrameRate;
							}
							
						}
						
						intSliderGrp -label "Quality" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 100 -v $savedQuickDraftQuality -changeCommand SavePersistentDeadlineOptions -annotation "The quality to use for the Quick Draft job." frw_UseQuickDraftQuality;
								
						
						textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Draft Template" -buttonLabel "..." -text $draftTemplate -changeCommand SavePersistentDeadlineOptions -annotation "The path to the Draft Template to use." -bc GetDraftTemplate frw_DraftTemplate;
						textFieldGrp -enable true -label "User" -cl2 "left" "left" -cw2 $labelWidth 325 -text $draftUser -changeCommand SavePersistentDeadlineOptions -annotation "The name of the user (used by Draft templates)." frw_DraftUser;
						textFieldGrp -enable true -label "Entity" -cl2 "left" "left" -cw2 $labelWidth 325 -text $draftEntity -changeCommand SavePersistentDeadlineOptions -annotation "The name of the entity (used by Draft templates)." frw_DraftEntity;
						textFieldGrp -enable true -label "Version" -cl2 "left" "left" -cw2 $labelWidth 325 -text $draftVersion -changeCommand SavePersistentDeadlineOptions -annotation "The version name (used by Draft templates)."  frw_DraftVersion;
						textFieldGrp -enable true -label "Additional Args" -cl2 "left" "left" -cw2 $labelWidth 325 -text $draftExtraArgs -changeCommand SavePersistentDeadlineOptions -annotation "The additional arguments (used by Draft templates)."  frw_DraftExtraArgs;
						
						rowLayout -numberOfColumns 2 -cw2 $labelWidth 325;
							text -label ""; //dummy label
							button -label "Use Shotgun Values" -width 200 -height 26 -annotation "Uses data from Shotgun/Nim to fill out the Draft settings." -command UsePMValues frw_projMgmtCreateVersionDataButton;
						setParent ..;
					setParent ..;
				setParent ..;
				
				UseDraftChanged();
				ProjectManagementChanged();
				// END DRAFT
				//=================================================================
			
			setParent ..;
		setParent ..;
	
	setParent ..;
		
	tabLayout -e -tabLabel mayaTabLayout "Maya" $MainTabLayout;
	tabLayout -e -tabLabel shotgunTabLayout "Integration" $MainTabLayout;
	
	columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4 buttonColumnLayout;
		rowLayout -numberOfColumns 5 -cw5 75 105 105 105 105;
			progressBar -width 65 -height 26 -minValue 0 -maxValue 100 -annotation "Deadline Submission Progress" frw_progBar;
			string $B3 = `button -label "Render Globals..." -width 95 -height 26 -c unifiedRenderGlobalsWindow -annotation "Opens the Maya Render Globals Dialog" frw_GlobalsButton`;
			button -label "Edit Project..." -width 95 -height 26 -c ProjectWindow -annotation "Opens the Maya Edit Project Dialog";
			button -label "Online Help..." -width 95 -c OnlineHelp -height 26 -annotation "Opens the Online Help page in the Default Web Browser";
			button -label "Submit Job" -width 95 -height 26 -annotation "Submits this job to Deadline" -c DeadlineSubmitterOnOk;
		setParent ..;
	setParent ..;
	
	formLayout -e
		-af buttonColumnLayout bottom 5
		-af buttonColumnLayout left 5
		-ac mainScrollLayout bottom 5 buttonColumnLayout
		-af mainScrollLayout top 5
		-af mainScrollLayout left 5
	mainFormLayout;
	
	UpdateRegionRenderType();
	UpdateCompositeType();
	
	scriptJob -uiDeleted $DeadlineSubmitterWindow OnExit;
	scriptJob -e "quitApplication" OnExit;
	// Show the submission dialog window.
	showWindow DeadlineSubmitWindow;
}
